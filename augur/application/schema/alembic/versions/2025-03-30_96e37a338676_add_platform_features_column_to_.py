"""Add platform_features column to WorkerOauth

Revision ID: 96e37a338676
Revises: eae480bce055
Create Date: 2025-03-30 02:51:53.360317

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql


# revision identifiers, used by Alembic.
revision = '96e37a338676'
down_revision = 'eae480bce055'
branch_labels = None
depends_on = None


def upgrade():
    op.add_column('worker_oauth', sa.Column('platform_features', sa.JSON(), nullable=True), schema='augur_operations')
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('analysis_log',
    sa.Column('repos_id', sa.Integer(), nullable=False),
    sa.Column('status', sa.String(), nullable=False),
    sa.Column('date_attempted', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    schema='augur_data'
    )
    op.create_index('repos_id', 'analysis_log', ['repos_id'], unique=False, schema='augur_data')
    op.create_table('dm_repo_group_monthly',
    sa.Column('repo_group_id', sa.BigInteger(), nullable=False),
    sa.Column('email', sa.String(), nullable=False),
    sa.Column('affiliation', sa.String(), server_default=sa.text("'NULL'::character varying"), nullable=True),
    sa.Column('month', sa.SmallInteger(), nullable=False),
    sa.Column('year', sa.SmallInteger(), nullable=False),
    sa.Column('added', sa.BigInteger(), nullable=False),
    sa.Column('removed', sa.BigInteger(), nullable=False),
    sa.Column('whitespace', sa.BigInteger(), nullable=False),
    sa.Column('files', sa.BigInteger(), nullable=False),
    sa.Column('patches', sa.BigInteger(), nullable=False),
    sa.Column('tool_source', sa.String(), nullable=True),
    sa.Column('tool_version', sa.String(), nullable=True),
    sa.Column('data_source', sa.String(), nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=True),
    schema='augur_data'
    )
    op.create_index('projects_id,affiliation_copy_2', 'dm_repo_group_monthly', ['repo_group_id', 'affiliation'], unique=False, schema='augur_data')
    op.create_index('projects_id,email_copy_2', 'dm_repo_group_monthly', ['repo_group_id', 'email'], unique=False, schema='augur_data')
    op.create_index('projects_id,year,affiliation_copy_1', 'dm_repo_group_monthly', ['repo_group_id', 'year', 'affiliation'], unique=False, schema='augur_data')
    op.create_index('projects_id,year,email_copy_1', 'dm_repo_group_monthly', ['repo_group_id', 'year', 'email'], unique=False, schema='augur_data')
    op.create_table('repo_badging',
    sa.Column('badge_collection_id', sa.BigInteger(), server_default=sa.text("nextval('augur_data.repo_badging_badge_collection_id_seq'::regclass)"), nullable=False),
    sa.Column('repo_id', sa.BigInteger(), nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=True),
    sa.Column('tool_source', sa.String(), nullable=True),
    sa.Column('tool_version', sa.String(), nullable=True),
    sa.Column('data_source', sa.String(), nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=True),
    sa.Column('data', postgresql.JSONB(astext_type=sa.Text()), nullable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['augur_data.repo.repo_id'], ),
    sa.PrimaryKeyConstraint('badge_collection_id'),
    schema='augur_data',
    comment='This will be collected from the LF’s Badging API\nhttps://bestpractices.coreinfrastructure.org/projects.json?pq=https%3A%2F%2Fgithub.com%2Fchaoss%2Faugur\n'
    )
    op.create_table('documents_creators',
    sa.Column('document_creator_id', sa.Integer(), server_default=sa.text("nextval('spdx.documents_creators_document_creator_id_seq'::regclass)"), nullable=False),
    sa.Column('document_id', sa.Integer(), nullable=False),
    sa.Column('creator_id', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['creator_id'], ['spdx.creators.creator_id'], ),
    sa.ForeignKeyConstraint(['document_id'], ['spdx.documents.document_id'], ),
    sa.PrimaryKeyConstraint('document_creator_id'),
    schema='spdx'
    )
    #op.drop_index('pr_meta_cntrb-idx', table_name='pull_request_assignees')
    #op.drop_table('pull_request_assignees')
    #op.drop_table('files_licenses')
    #op.drop_index('commit_parents_ibfk_1', table_name='commit_parents')
    #op.drop_index('commit_parents_ibfk_2', table_name='commit_parents')
    #op.drop_table('commit_parents')
    #op.drop_table('issue_labels')
    #op.drop_index('repo_id,affiliation_copy_1', table_name='dm_repo_annual')
    #op.drop_index('repo_id,email_copy_1', table_name='dm_repo_annual')
    #op.drop_table('dm_repo_annual')
    #op.drop_table('annotation_types')
    #op.drop_index('comment_id', table_name='commit_comment_ref')
    #op.drop_table('commit_comment_ref')
    #op.drop_table('repo_insights')
    #op.drop_table('files')
    #op.drop_index('rgidm', table_name='repo_groups')
    #op.drop_index('rgnameindex', table_name='repo_groups')
    #op.drop_table('repo_groups')
    #op.drop_index('author_affiliation', table_name='commits')
    #op.drop_index('author_cntrb_id', table_name='commits')
    #op.drop_index('author_email,author_affiliation,author_date', table_name='commits')
    #op.drop_index('author_raw_email', table_name='commits')
    #op.drop_index('commited', table_name='commits')
    #op.drop_index('commits_idx_cmt_email_cmt_date_cmt_name', table_name='commits')
    #op.drop_index('committer_affiliation', table_name='commits')
    #op.drop_index('committer_raw_email', table_name='commits')
    #op.drop_index('repo_id,commit', table_name='commits')
    #op.drop_table('commits')
    #op.drop_index('cnt-fullname', table_name='contributors', postgresql_using='hash')
    #op.drop_index('cntrb-theemail', table_name='contributors', postgresql_using='hash')
    #op.drop_index('cntrb_canonica-idx11', table_name='contributors')
    #op.drop_index('cntrb_login_platform_index', table_name='contributors')
    #op.drop_index('contributor_worker_email_finder', table_name='contributors', postgresql_using='brin')
    #op.drop_index('contributor_worker_fullname_finder', table_name='contributors', postgresql_using='brin')
    #op.drop_index('contributors_idx_cntrb_email3', table_name='contributors')
    #op.drop_index('gh_login', table_name='contributors')
    #op.drop_index('login', table_name='contributors')
    #op.drop_index('login-contributor-idx', table_name='contributors')
    #op.drop_table('contributors')
    #op.drop_table('pull_request_labels')
    #op.drop_table('commit_messages')
    #op.drop_table('pull_request_review_message_ref')
    #op.drop_index('pr_anal_idx', table_name='pull_request_analysis')
    #op.drop_index('probability_idx', table_name='pull_request_analysis')
    #op.drop_table('pull_request_analysis')
    #op.drop_table('collection_status')
    #op.drop_table('message_sentiment_summary')
    #op.drop_index('pr-cntrb-idx-repo', table_name='pull_request_repo')
    #op.drop_table('pull_request_repo')
    #op.drop_table('annotations')
    #op.drop_table('message_analysis_summary')
    #op.drop_index('repos_id,status', table_name='repos_fetch_log')
    #op.drop_index('repos_id,statusops', table_name='repos_fetch_log')
    #op.drop_table('repos_fetch_log')
    #op.drop_table('documents')
    #op.drop_table('document_namespaces')
    #op.drop_table('user_session_tokens')
    #op.drop_table('refresh_tokens')
    #op.drop_table('creator_types')
    #op.drop_index('forked', table_name='repo')
    #op.drop_index('repo_idx_repo_id_repo_namex', table_name='repo')
    #op.drop_index('repogitindexrep', table_name='repo')
    #op.drop_index('reponameindex', table_name='repo', postgresql_using='hash')
    #op.drop_index('reponameindexbtree', table_name='repo')
    #op.drop_index('rggrouponrepoindex', table_name='repo')
    #op.drop_index('therepo', table_name='repo')
    #op.drop_table('repo')
    #op.drop_table('message_analysis')
    #op.drop_table('creators')
    #op.drop_table('lstm_anomaly_models')
    #op.drop_table('augur_settings')
    #op.drop_table('discourse_insights')
    #op.drop_table('repo_deps_libyear')
    #op.drop_table('contributors_aliases')
    #op.drop_table('pull_request_commits')
    #op.drop_table('users')
    #op.drop_table('external_refs')
    #op.drop_index('projects_id,affiliation_copy_1', table_name='dm_repo_group_annual')
    #op.drop_index('projects_id,email_copy_1', table_name='dm_repo_group_annual')
    #op.drop_table('dm_repo_group_annual')
    #op.drop_index('pr_events_ibfk_1', table_name='pull_request_events')
    #op.drop_index('pr_events_ibfk_2', table_name='pull_request_events')
    #op.drop_table('pull_request_events')
    #op.drop_table('lstm_anomaly_results')
    #op.drop_table('library_version')
    #op.drop_table('repo_test_coverage')
    #op.drop_index('pr-reviewers-cntrb-idx1', table_name='pull_request_reviewers')
    #op.drop_table('pull_request_reviewers')
    #op.drop_table('exclude')
    #op.drop_table('contributor_affiliations')
    #op.drop_table('identifiers')
    #op.drop_table('contributor_repo')
    #op.drop_table('repo_labor')
    #op.drop_table('sbom_scans')
    #op.drop_table('repo_topic')
    #op.drop_table('licenses')
    #op.drop_table('repo_dependencies')
    #op.drop_table('issue_message_ref')
    #op.drop_table('worker_job')
    #op.drop_table('all')
    #op.drop_table('repo_sbom_scans')
    #op.drop_table('working_commits')
    #op.drop_table('pull_request_message_ref')
    #op.drop_table('repo_group_insights')
    #op.drop_table('dei_badging')
    #op.drop_table('utility_log')
    #op.drop_table('worker_oauth')
    #op.drop_index('repo_info_idx_repo_id_data_date_1x', table_name='repo_info')
    #op.drop_index('repo_info_idx_repo_id_data_datex', table_name='repo_info')
    #op.drop_table('repo_info')
    #op.drop_index('id_node', table_name='pull_requests')
    #op.drop_index('pr_ID_prs_table', table_name='pull_requests')
    #op.drop_index('pull_requests_idx_repo_id_data_datex', table_name='pull_requests')
    #op.drop_table('pull_requests')
    #op.drop_table('user_repos')
    #op.drop_index('lister', table_name='repo_groups_list_serve')
    #op.drop_table('repo_groups_list_serve')
    #op.drop_table('config')
    #op.drop_index('projects_id,affiliation', table_name='dm_repo_group_weekly')
    #op.drop_index('projects_id,email', table_name='dm_repo_group_weekly')
    #op.drop_index('projects_id,year,affiliation', table_name='dm_repo_group_weekly')
    #op.drop_index('projects_id,year,email', table_name='dm_repo_group_weekly')
    #op.drop_table('dm_repo_group_weekly')
    #op.drop_table('worker_settings_facade')
    #op.drop_table('relationship_types')
    #op.drop_index('dater', table_name='repo_insights_records')
    #op.drop_table('repo_insights_records')
    #op.drop_index('issue-cntrb-idx2', table_name='issue_events')
    #op.drop_index('issue_events_ibfk_1', table_name='issue_events')
    #op.drop_index('issue_events_ibfk_2', table_name='issue_events')
    #op.drop_table('issue_events')
    #op.drop_table('relationships')
    #op.drop_table('unresolved_commit_emails')
    #op.drop_table('scanners')
    #op.drop_table('client_applications')
    #op.drop_table('message_sentiment')
    #op.drop_index('type,projects_id', table_name='unknown_cache')
    #op.drop_table('unknown_cache')
    #op.drop_table('subscription_types')
    #op.drop_table('chaoss_metric_status')
    #op.drop_table('libraries')
    #op.drop_table('pull_request_teams')
    #op.drop_table('user_groups')
    #op.drop_table('augur_repo_map')
    #op.drop_index('pr_meta-cntrbid-idx', table_name='pull_request_meta')
    #op.drop_table('pull_request_meta')
    #op.drop_table('settings')
    #op.drop_index('issue-cntrb-dix2', table_name='issues')
    #op.drop_index('issues_ibfk_1', table_name='issues')
    #op.drop_index('issues_ibfk_2', table_name='issues')
    #op.drop_index('issues_ibfk_4', table_name='issues')
    #op.drop_table('issues')
    #op.drop_table('file_contributors')
    #op.drop_table('packages_scans')
    #op.drop_index('repo_id,affiliation_copy_2', table_name='dm_repo_monthly')
    #op.drop_index('repo_id,email_copy_2', table_name='dm_repo_monthly')
    #op.drop_index('repo_id,year,affiliation_copy_1', table_name='dm_repo_monthly')
    #op.drop_index('repo_id,year,email_copy_1', table_name='dm_repo_monthly')
    #op.drop_table('dm_repo_monthly')
    #op.drop_table('file_types')
    #op.drop_table('subscriptions')
    #op.drop_index('messagegrouper', table_name='message')
    #op.drop_index('msg-cntrb-id-idx', table_name='message')
    #op.drop_index('platformgrouper', table_name='message')
    #op.drop_table('message')
    #op.drop_table('packages')
    #op.drop_index('plat', table_name='platform')
    #op.drop_table('platform')
    #op.drop_table('repo_clones_data')
    #op.drop_table('worker_history')
    #op.drop_table('topic_words')
    #op.drop_index('pr_id_pr_reviews', table_name='pull_request_reviews')
    #op.drop_table('pull_request_reviews')
    #op.drop_table('repo_meta')
    #op.drop_table('files_scans')
    #op.drop_index('issue-cntrb-assign-idx-1', table_name='issue_assignees')
    #op.drop_table('issue_assignees')
    #op.drop_table('packages_files')
    #op.drop_table('releases')
    #op.drop_table('repo_stats')
    #op.drop_index('REPO_DEP', table_name='library_dependencies')
    #op.drop_table('library_dependencies')
    #op.drop_table('repo_deps_scorecard')
    #op.drop_index('pr_id_pr_files', table_name='pull_request_files')
    #op.drop_table('pull_request_files')
    #op.drop_table('projects')
    #op.drop_table('repo_cluster_messages')
    #op.drop_table('chaoss_user')
    #op.drop_index('repo_id,affiliation', table_name='dm_repo_weekly')
    #op.drop_index('repo_id,email', table_name='dm_repo_weekly')
    #op.drop_index('repo_id,year,affiliation', table_name='dm_repo_weekly')
    #op.drop_index('repo_id,year,email', table_name='dm_repo_weekly')
    #op.drop_table('dm_repo_weekly')
    op.drop_constraint('cmt_ght_author_cntrb_id_fk', 'commits', schema='augur_data', type_='foreignkey')
    op.create_foreign_key(None, 'commits', 'contributors', ['cmt_ght_author_id'], ['cntrb_id'], source_schema='augur_data', referent_schema='augur_data')
    #op.create_foreign_key('fk_commits_contributors_3', 'commits', 'contributors', ['cmt_author_platform_username'], ['cntrb_login'], source_schema='augur_data', referent_schema='augur_data', onupdate='CASCADE', ondelete='CASCADE', initially='DEFERRED', deferrable=True)
    #op.drop_index('gh_login', table_name='contributors', schema='augur_data')
    op.create_unique_constraint('GH-UNIQUE-C', 'contributors', ['gh_login'], deferrable=True, initially='DEFERRED', schema='augur_data')
    op.create_unique_constraint('GL-cntrb-LOGIN-UNIQUE', 'contributors', ['cntrb_login'], schema='augur_data')
    op.add_column('platform', sa.Column('pretty_name', sa.String(length=255), nullable=True), schema='augur_data')
    op.add_column('platform', sa.Column('enabled', sa.Boolean(), nullable=True), schema='augur_data')
    op.drop_constraint('pr_events_repo_id_event_src_id_unique', 'pull_request_events', schema='augur_data', type_='unique')
    #op.drop_index('pr_id_pr_files', table_name='pull_request_files', schema='augur_data')
    #op.drop_index('pr_id_pr_reviews', table_name='pull_request_reviews', schema='augur_data')
    op.drop_constraint('pr_review_unique', 'pull_request_reviews', schema='augur_data', type_='unique')
    op.create_unique_constraint(None, 'pull_request_reviews', ['pr_review_src_id', 'tool_source'], schema='augur_data')
    #op.drop_index('pr_ID_prs_table', table_name='pull_requests', schema='augur_data')
    #op.drop_index('id_node', table_name='pull_requests', schema='augur_data')
    #op.create_index('id_node', 'pull_requests', ['pr_src_id', 'pr_src_node_id'], unique=False, schema='augur_data')
    op.alter_column('releases', 'release_id',
               existing_type=sa.CHAR(length=256),
               type_=sa.CHAR(length=128),
               existing_nullable=False,
               existing_server_default=sa.text('nextval(\'"augur_data".releases_release_id_seq\'::regclass)'),
               schema='augur_data')
    op.drop_constraint('repo_src_id_unique', 'repo', schema='augur_data', type_='unique')
    op.drop_constraint('collection_status_repo_id_fk', 'collection_status', schema='augur_operations', type_='foreignkey')
    op.create_foreign_key('collection_status_repo_id_fk', 'collection_status', 'repo', ['repo_id'], ['repo_id'], source_schema='augur_operations', referent_schema='augur_data')
    op.alter_column('user_groups', 'user_id',
               existing_type=sa.INTEGER(),
               nullable=True,
               schema='augur_operations')
    op.drop_constraint('user_groups_user_id_name_key', 'user_groups', schema='augur_operations', type_='unique')
    op.create_unique_constraint('user_group_unique', 'user_groups', ['user_id', 'name'], schema='augur_operations')
    op.drop_constraint('user_repos_repo_id_fkey', 'user_repos', schema='augur_operations', type_='foreignkey')
    op.create_foreign_key('user_repo_user_id_fkey', 'user_repos', 'repo', ['repo_id'], ['repo_id'], source_schema='augur_operations', referent_schema='augur_data')
    op.alter_column('user_session_tokens', 'user_id',
               existing_type=sa.INTEGER(),
               nullable=True,
               schema='augur_operations')
    op.alter_column('user_session_tokens', 'application_id',
               existing_type=sa.VARCHAR(),
               nullable=False,
               schema='augur_operations')
    op.drop_column('users', 'email_verified', schema='augur_operations')
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('worker_oauth', 'platform_features', schema='augur_operations')
    op.add_column('users', sa.Column('email_verified', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False), schema='augur_operations')
    op.alter_column('user_session_tokens', 'application_id',
               existing_type=sa.VARCHAR(),
               nullable=True,
               schema='augur_operations')
    op.alter_column('user_session_tokens', 'user_id',
               existing_type=sa.INTEGER(),
               nullable=False,
               schema='augur_operations')
    op.drop_constraint('user_repo_user_id_fkey', 'user_repos', schema='augur_operations', type_='foreignkey')
    op.create_foreign_key('user_repos_repo_id_fkey', 'user_repos', 'repo', ['repo_id'], ['repo_id'], source_schema='augur_operations')
    op.drop_constraint('user_group_unique', 'user_groups', schema='augur_operations', type_='unique')
    op.create_unique_constraint('user_groups_user_id_name_key', 'user_groups', ['user_id', 'name'], schema='augur_operations')
    op.alter_column('user_groups', 'user_id',
               existing_type=sa.INTEGER(),
               nullable=False,
               schema='augur_operations')
    op.drop_constraint('collection_status_repo_id_fk', 'collection_status', schema='augur_operations', type_='foreignkey')
    op.create_foreign_key('collection_status_repo_id_fk', 'collection_status', 'repo', ['repo_id'], ['repo_id'], source_schema='augur_operations')
    op.create_unique_constraint('repo_src_id_unique', 'repo', ['repo_src_id'], schema='augur_data')
    op.alter_column('releases', 'release_id',
               existing_type=sa.CHAR(length=128),
               type_=sa.CHAR(length=256),
               existing_nullable=False,
               existing_server_default=sa.text('nextval(\'"augur_data".releases_release_id_seq\'::regclass)'),
               schema='augur_data')
    #op.drop_index('id_node', table_name='pull_requests', schema='augur_data')
    op.create_index('id_node', 'pull_requests', [sa.literal_column('pr_src_id DESC'), sa.literal_column('pr_src_node_id DESC NULLS LAST')], unique=False, schema='augur_data')
    op.create_index('pr_ID_prs_table', 'pull_requests', ['pull_request_id'], unique=False, schema='augur_data')
    op.drop_constraint(None, 'pull_request_reviews', schema='augur_data', type_='unique')
    op.create_unique_constraint('pr_review_unique', 'pull_request_reviews', ['pr_review_src_id'], schema='augur_data')
    op.create_index('pr_id_pr_reviews', 'pull_request_reviews', ['pull_request_id'], unique=False, schema='augur_data')
    op.create_index('pr_id_pr_files', 'pull_request_files', ['pull_request_id'], unique=False, schema='augur_data')
    op.create_unique_constraint('pr_events_repo_id_event_src_id_unique', 'pull_request_events', ['repo_id', 'issue_event_src_id'], schema='augur_data')
    op.drop_column('platform', 'enabled', schema='augur_data')
    op.drop_column('platform', 'pretty_name', schema='augur_data')
    op.drop_constraint('GL-cntrb-LOGIN-UNIQUE', 'contributors', schema='augur_data', type_='unique')
    op.drop_constraint('GH-UNIQUE-C', 'contributors', schema='augur_data', type_='unique')
    op.create_index('gh_login', 'contributors', [sa.literal_column('gh_login NULLS FIRST')], unique=False, schema='augur_data')
    op.drop_constraint('fk_commits_contributors_3', 'commits', schema='augur_data', type_='foreignkey')
    op.drop_constraint(None, 'commits', schema='augur_data', type_='foreignkey')
    op.create_foreign_key('cmt_ght_author_cntrb_id_fk', 'commits', 'contributors', ['cmt_ght_author_id'], ['cntrb_id'], source_schema='augur_data', referent_schema='augur_data', onupdate='CASCADE', ondelete='RESTRICT', initially='DEFERRED', deferrable=True)
    op.create_table('dm_repo_weekly',
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('email', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('affiliation', sa.VARCHAR(), server_default=sa.text("'NULL'::character varying"), autoincrement=False, nullable=True),
    sa.Column('week', sa.SMALLINT(), autoincrement=False, nullable=False),
    sa.Column('year', sa.SMALLINT(), autoincrement=False, nullable=False),
    sa.Column('added', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('removed', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('whitespace', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('files', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('patches', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True)
    )
    op.create_index('repo_id,year,email', 'dm_repo_weekly', ['repo_id', 'year', 'email'], unique=False)
    op.create_index('repo_id,year,affiliation', 'dm_repo_weekly', ['repo_id', 'year', 'affiliation'], unique=False)
    op.create_index('repo_id,email', 'dm_repo_weekly', ['repo_id', 'email'], unique=False)
    op.create_index('repo_id,affiliation', 'dm_repo_weekly', ['repo_id', 'affiliation'], unique=False)
    op.create_table('chaoss_user',
    sa.Column('chaoss_id', sa.BIGINT(), autoincrement=True, nullable=False),
    sa.Column('chaoss_login_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('chaoss_login_hashword', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('chaoss_email', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('chaoss_text_phone', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('chaoss_first_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('chaoss_last_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(timezone=True, precision=6), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('chaoss_id', name='chaoss_user_pkey'),
    sa.UniqueConstraint('chaoss_email', name='chaoss_unique_email_key')
    )
    op.create_table('repo_cluster_messages',
    sa.Column('msg_cluster_id', sa.BIGINT(), server_default=sa.text("nextval('repo_cluster_messages_msg_cluster_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('cluster_content', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('cluster_mechanism', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_repo_cluster_messages_repo_1'),
    sa.PrimaryKeyConstraint('msg_cluster_id', name='repo_cluster_messages_pkey')
    )
    op.create_table('projects',
    sa.Column('package_id', sa.INTEGER(), server_default=sa.text("nextval('projects_package_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('name', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('homepage', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('uri', sa.TEXT(), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('package_id', name='projects_pkey')
    )
    op.create_table('pull_request_files',
    sa.Column('pr_file_id', sa.BIGINT(), server_default=sa.text("nextval('pull_request_files_pr_file_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('pull_request_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_file_additions', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_file_deletions', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_file_path', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['pull_request_id'], ['pull_requests.pull_request_id'], name='fk_pull_request_commits_pull_requests_1_copy_1', onupdate='CASCADE', ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_pull_request_files_repo_id', onupdate='CASCADE', ondelete='RESTRICT', initially='DEFERRED', deferrable=True),
    sa.PrimaryKeyConstraint('pr_file_id', name='pull_request_files_pkey'),
    sa.UniqueConstraint('pull_request_id', 'repo_id', 'pr_file_path', name='prfiles_unique'),
    comment='Pull request commits are an enumeration of each commit associated with a pull request. \nNot all pull requests are from a branch or fork into master. \nThe commits table intends to count only commits that end up in the master branch (i.e., part of the deployed code base for a project).\nTherefore, there will be commit “SHA”’s in this table that are no associated with a commit SHA in the commits table. \nIn cases where the PR is to the master branch of a project, you will find a match. In cases where the PR does not involve the master branch, you will not find a corresponding commit SHA in the commits table. This is expected. '
    )
    op.create_index('pr_id_pr_files', 'pull_request_files', ['pull_request_id'], unique=False)
    op.create_table('repo_deps_scorecard',
    sa.Column('repo_deps_scorecard_id', sa.BIGINT(), server_default=sa.text("nextval('repo_deps_scorecard_repo_deps_scorecard_id_seq1'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('score', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('scorecard_check_details', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='repo_id_copy_1'),
    sa.PrimaryKeyConstraint('repo_deps_scorecard_id', name='repo_deps_scorecard_pkey1'),
    sa.UniqueConstraint('repo_id', 'name', name='deps-scorecard-insert-unique')
    )
    op.create_table('library_dependencies',
    sa.Column('lib_dependency_id', sa.BIGINT(), server_default=sa.text("nextval('library_dependencies_lib_dependency_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('library_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('manifest_platform', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('manifest_filepath', sa.VARCHAR(length=1000), server_default=sa.text('NULL::character varying'), autoincrement=False, nullable=True),
    sa.Column('manifest_kind', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('repo_id_branch', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['library_id'], ['libraries.library_id'], name='fk_library_dependencies_libraries_1'),
    sa.PrimaryKeyConstraint('lib_dependency_id', name='library_dependencies_pkey')
    )
    op.create_index('REPO_DEP', 'library_dependencies', ['library_id'], unique=False)
    op.create_table('repo_stats',
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('rstat_id', sa.BIGINT(), server_default=sa.text("nextval('repo_stats_rstat_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('rstat_name', sa.VARCHAR(length=400), autoincrement=False, nullable=True),
    sa.Column('rstat_value', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_repo_stats_repo_1'),
    sa.PrimaryKeyConstraint('rstat_id', 'repo_id', name='repo_stats_pkey'),
    comment='Project Watchers'
    )
    op.create_table('releases',
    sa.Column('release_id', sa.CHAR(length=256), server_default=sa.text("nextval('releases_release_id_seq'::regclass)"), autoincrement=False, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('release_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('release_description', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('release_author', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('release_created_at', postgresql.TIMESTAMP(precision=6), autoincrement=False, nullable=True),
    sa.Column('release_published_at', postgresql.TIMESTAMP(precision=6), autoincrement=False, nullable=True),
    sa.Column('release_updated_at', postgresql.TIMESTAMP(precision=6), autoincrement=False, nullable=True),
    sa.Column('release_is_draft', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('release_is_prerelease', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('release_tag_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('release_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tag_only', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=6), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_releases_repo_1'),
    sa.PrimaryKeyConstraint('release_id', name='releases_pkey')
    )
    op.create_table('packages_files',
    sa.Column('package_file_id', sa.INTEGER(), server_default=sa.text("nextval('packages_files_package_file_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('package_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('file_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('concluded_license_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('license_comment', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('file_name', sa.TEXT(), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['concluded_license_id'], ['licenses.license_id'], name='packages_files_concluded_license_id_fkey'),
    sa.ForeignKeyConstraint(['file_id'], ['files.file_id'], name='packages_files_file_id_fkey'),
    sa.ForeignKeyConstraint(['package_id'], ['packages.package_id'], name='fk_package_files_packages'),
    sa.PrimaryKeyConstraint('package_file_id', name='packages_files_pkey'),
    sa.UniqueConstraint('package_id', 'file_name', name='uc_package_id_file_name'),
    postgresql_ignore_search_path=False
    )
    op.create_table('issue_assignees',
    sa.Column('issue_assignee_id', sa.BIGINT(), server_default=sa.text("nextval('issue_assignees_issue_assignee_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('issue_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('issue_assignee_src_id', sa.BIGINT(), autoincrement=False, nullable=True, comment='This ID comes from the source. In the case of GitHub, it is the id that is the first field returned from the issue events API in the issue_assignees embedded JSON object. We may discover it is an ID for the person themselves; but my hypothesis is that its not.'),
    sa.Column('issue_assignee_src_node', sa.VARCHAR(), autoincrement=False, nullable=True, comment='This character based identifier comes from the source. In the case of GitHub, it is the id that is the second field returned from the issue events API in the issue_assignees embedded JSON object. We may discover it is an ID for the person themselves; but my hypothesis is that its not.'),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('cntrb_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['cntrb_id'], ['contributors.cntrb_id'], name='issue_assignees_cntrb_id_fkey'),
    sa.ForeignKeyConstraint(['issue_id'], ['issues.issue_id'], name='fk_issue_assignees_issues_1'),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_issue_assignee_repo_id', onupdate='CASCADE', ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('issue_assignee_id', name='issue_assignees_pkey'),
    sa.UniqueConstraint('issue_assignee_src_id', 'issue_id', name='issue-assignee-insert-unique')
    )
    op.create_index('issue-cntrb-assign-idx-1', 'issue_assignees', ['cntrb_id'], unique=False)
    op.create_table('files_scans',
    sa.Column('file_scan_id', sa.INTEGER(), server_default=sa.text("nextval('files_scans_file_scan_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('file_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('scanner_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['file_id'], ['files.file_id'], name='files_scans_file_id_fkey'),
    sa.ForeignKeyConstraint(['scanner_id'], ['scanners.scanner_id'], name='files_scans_scanner_id_fkey'),
    sa.PrimaryKeyConstraint('file_scan_id', name='files_scans_pkey'),
    sa.UniqueConstraint('file_id', 'scanner_id', name='uc_file_scanner_id')
    )
    op.create_table('repo_meta',
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('rmeta_id', sa.BIGINT(), server_default=sa.text("nextval('repo_meta_rmeta_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('rmeta_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('rmeta_value', sa.VARCHAR(), server_default=sa.text('0'), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_repo_meta_repo_1'),
    sa.PrimaryKeyConstraint('rmeta_id', 'repo_id', name='repo_meta_pkey'),
    comment='Project Languages'
    )
    op.create_table('pull_request_reviews',
    sa.Column('pr_review_id', sa.BIGINT(), server_default=sa.text("nextval('pull_request_reviews_pr_review_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('pull_request_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_review_author_association', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_review_state', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_review_body', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_review_submitted_at', postgresql.TIMESTAMP(precision=6), autoincrement=False, nullable=True),
    sa.Column('pr_review_src_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_review_node_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_review_html_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_review_pull_request_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_review_commit_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('platform_id', sa.BIGINT(), server_default=sa.text('25150'), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('cntrb_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['cntrb_id'], ['contributors.cntrb_id'], name='pull_request_reviews_cntrb_id_fkey', onupdate='CASCADE', ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['platform_id'], ['platform.pltfrm_id'], name='fk-review-platform', onupdate='CASCADE', ondelete='RESTRICT', initially='DEFERRED', deferrable=True),
    sa.ForeignKeyConstraint(['pull_request_id'], ['pull_requests.pull_request_id'], name='fk_pull_request_reviews_pull_requests_1', onupdate='CASCADE', ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_repo_review', onupdate='CASCADE', ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('pr_review_id', name='pull_request_review_id'),
    sa.UniqueConstraint('pr_review_src_id', name='pr_review_unique'),
    postgresql_ignore_search_path=False
    )
    op.create_index('pr_id_pr_reviews', 'pull_request_reviews', ['pull_request_id'], unique=False)
    op.create_table('topic_words',
    sa.Column('topic_words_id', sa.BIGINT(), server_default=sa.text("nextval('topic_words_topic_words_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('topic_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('word', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('word_prob', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('topic_words_id', name='topic_words_pkey')
    )
    op.create_table('worker_history',
    sa.Column('history_id', sa.BIGINT(), server_default=sa.text("nextval('gh_worker_history_history_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('worker', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.Column('job_model', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.Column('oauth_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('timestamp', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=False),
    sa.Column('status', sa.VARCHAR(length=7), autoincrement=False, nullable=False),
    sa.Column('total_results', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('history_id', name='history_pkey'),
    comment='This table stores the complete history of job execution, including success and failure. It is useful for troubleshooting. '
    )
    op.create_table('repo_clones_data',
    sa.Column('repo_clone_data_id', sa.BIGINT(), server_default=sa.text("nextval('repo_clones_data_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('unique_clones', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('count_clones', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('clone_data_timestamp', postgresql.TIMESTAMP(precision=6), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='repo_clones_data_repo_id_fkey', onupdate='CASCADE', ondelete='RESTRICT', initially='DEFERRED', deferrable=True),
    sa.PrimaryKeyConstraint('repo_clone_data_id', name='repo_clones_data_pkey')
    )
    op.create_table('platform',
    sa.Column('pltfrm_id', sa.BIGINT(), server_default=sa.text("nextval('platform_pltfrm_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('pltfrm_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pltfrm_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pltfrm_release_date', sa.DATE(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('pltfrm_id', name='theplat'),
    postgresql_ignore_search_path=False
    )
    op.create_index('plat', 'platform', ['pltfrm_id'], unique=True)
    op.create_table('packages',
    sa.Column('package_id', sa.INTEGER(), server_default=sa.text("nextval('packages_package_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('name', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.Column('version', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.Column('file_name', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('supplier_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('originator_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('download_location', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('verification_code', sa.VARCHAR(length=64), autoincrement=False, nullable=False),
    sa.Column('ver_code_excluded_file_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('sha256', sa.VARCHAR(length=64), autoincrement=False, nullable=True),
    sa.Column('home_page', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('source_info', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('concluded_license_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('declared_license_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('license_comment', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('copyright_text', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('summary', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('description', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('comment', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('dosocs2_dir_code', sa.VARCHAR(length=64), autoincrement=False, nullable=True),
    sa.CheckConstraint('((sha256 IS NOT NULL)::integer + (dosocs2_dir_code IS NOT NULL)::integer) = 1', name='uc_sha256_ds2_dir_code_exactly_one'),
    sa.ForeignKeyConstraint(['concluded_license_id'], ['licenses.license_id'], name='packages_concluded_license_id_fkey'),
    sa.ForeignKeyConstraint(['declared_license_id'], ['licenses.license_id'], name='packages_declared_license_id_fkey'),
    sa.ForeignKeyConstraint(['originator_id'], ['creators.creator_id'], name='packages_originator_id_fkey'),
    sa.ForeignKeyConstraint(['supplier_id'], ['creators.creator_id'], name='packages_supplier_id_fkey'),
    sa.ForeignKeyConstraint(['ver_code_excluded_file_id'], ['packages_files.package_file_id'], name='fk_package_packages_files'),
    sa.PrimaryKeyConstraint('package_id', name='packages_pkey'),
    sa.UniqueConstraint('sha256', name='uc_package_sha256'),
    sa.UniqueConstraint('verification_code', 'dosocs2_dir_code', name='uc_dir_code_ver_code'),
    postgresql_ignore_search_path=False
    )
    op.create_table('message',
    sa.Column('msg_id', sa.BIGINT(), server_default=sa.text("nextval('message_msg_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('rgls_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('platform_msg_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('platform_node_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('msg_text', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('msg_timestamp', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.Column('msg_sender_email', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('msg_header', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pltfrm_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('cntrb_id', sa.UUID(), autoincrement=False, nullable=True, comment='Not populated for mailing lists. Populated for GitHub issues. '),
    sa.ForeignKeyConstraint(['cntrb_id'], ['contributors.cntrb_id'], name='message_cntrb_id_fkey', onupdate='CASCADE', ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['pltfrm_id'], ['platform.pltfrm_id'], name='fk_message_platform_1', onupdate='CASCADE', ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_message_repoid', onupdate='CASCADE', ondelete='CASCADE', initially='DEFERRED', deferrable=True),
    sa.ForeignKeyConstraint(['rgls_id'], ['repo_groups_list_serve.rgls_id'], name='fk_message_repo_groups_list_serve_1', onupdate='CASCADE', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('msg_id', name='message_pkey'),
    sa.UniqueConstraint('platform_msg_id', 'pltfrm_id', name='message-insert-unique'),
    postgresql_ignore_search_path=False
    )
    op.create_index('platformgrouper', 'message', ['msg_id', 'pltfrm_id'], unique=False)
    op.create_index('msg-cntrb-id-idx', 'message', ['cntrb_id'], unique=False)
    op.create_index('messagegrouper', 'message', ['msg_id', 'rgls_id'], unique=True)
    op.create_table('subscriptions',
    sa.Column('application_id', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('type_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['application_id'], ['client_applications.id'], name='subscriptions_application_id_fkey'),
    sa.ForeignKeyConstraint(['type_id'], ['subscription_types.id'], name='subscriptions_type_id_fkey'),
    sa.PrimaryKeyConstraint('application_id', 'type_id', name='subscriptions_pkey')
    )
    op.create_table('file_types',
    sa.Column('file_type_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('name', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('name', name='uc_file_type_name')
    )
    op.create_table('dm_repo_monthly',
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('email', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('affiliation', sa.VARCHAR(), server_default=sa.text("'NULL'::character varying"), autoincrement=False, nullable=True),
    sa.Column('month', sa.SMALLINT(), autoincrement=False, nullable=False),
    sa.Column('year', sa.SMALLINT(), autoincrement=False, nullable=False),
    sa.Column('added', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('removed', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('whitespace', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('files', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('patches', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True)
    )
    op.create_index('repo_id,year,email_copy_1', 'dm_repo_monthly', ['repo_id', 'year', 'email'], unique=False)
    op.create_index('repo_id,year,affiliation_copy_1', 'dm_repo_monthly', ['repo_id', 'year', 'affiliation'], unique=False)
    op.create_index('repo_id,email_copy_2', 'dm_repo_monthly', ['repo_id', 'email'], unique=False)
    op.create_index('repo_id,affiliation_copy_2', 'dm_repo_monthly', ['repo_id', 'affiliation'], unique=False)
    op.create_table('packages_scans',
    sa.Column('package_scan_id', sa.INTEGER(), server_default=sa.text("nextval('packages_scans_package_scan_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('package_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('scanner_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['package_id'], ['packages.package_id'], name='packages_scans_package_id_fkey'),
    sa.ForeignKeyConstraint(['scanner_id'], ['scanners.scanner_id'], name='packages_scans_scanner_id_fkey'),
    sa.PrimaryKeyConstraint('package_scan_id', name='packages_scans_pkey'),
    sa.UniqueConstraint('package_id', 'scanner_id', name='uc_package_scanner_id')
    )
    op.create_table('file_contributors',
    sa.Column('file_contributor_id', sa.INTEGER(), server_default=sa.text("nextval('file_contributors_file_contributor_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('file_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('contributor', sa.TEXT(), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['file_id'], ['files.file_id'], name='file_contributors_file_id_fkey'),
    sa.PrimaryKeyConstraint('file_contributor_id', name='file_contributors_pkey')
    )
    op.create_table('issues',
    sa.Column('issue_id', sa.BIGINT(), server_default=sa.text("nextval('issue_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pull_request', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pull_request_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.Column('issue_title', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('issue_body', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('comment_count', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.Column('closed_at', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.Column('due_on', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.Column('repository_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('issue_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('labels_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('comments_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('events_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('html_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('issue_state', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('issue_node_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('gh_issue_number', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('gh_issue_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('gh_user_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('reporter_id', sa.UUID(), autoincrement=False, nullable=True, comment='The ID of the person who opened the issue. '),
    sa.Column('cntrb_id', sa.UUID(), autoincrement=False, nullable=True, comment='The ID of the person who closed the issue. '),
    sa.ForeignKeyConstraint(['cntrb_id'], ['contributors.cntrb_id'], name='issues_cntrb_id_fkey'),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_issues_repo', onupdate='CASCADE', ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['reporter_id'], ['contributors.cntrb_id'], name='issues_reporter_id_fkey'),
    sa.PrimaryKeyConstraint('issue_id', name='issues_pkey'),
    sa.UniqueConstraint('issue_url', name='issue-insert-unique'),
    sa.UniqueConstraint('repo_id', 'gh_issue_id', name='unique-issue'),
    postgresql_ignore_search_path=False
    )
    op.create_index('issues_ibfk_4', 'issues', ['pull_request_id'], unique=False)
    op.create_index('issues_ibfk_2', 'issues', ['reporter_id'], unique=False)
    op.create_index('issues_ibfk_1', 'issues', ['repo_id'], unique=False)
    op.create_index('issue-cntrb-dix2', 'issues', ['cntrb_id'], unique=False)
    op.create_table('settings',
    sa.Column('id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('setting', sa.VARCHAR(length=32), autoincrement=False, nullable=False),
    sa.Column('value', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('last_modified', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name='settings_pkey')
    )
    op.create_table('pull_request_meta',
    sa.Column('pr_repo_meta_id', sa.BIGINT(), server_default=sa.text("nextval('pull_request_meta_pr_repo_meta_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('pull_request_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_head_or_base', sa.VARCHAR(), autoincrement=False, nullable=True, comment='Each pull request should have one and only one head record; and one and only one base record. '),
    sa.Column('pr_src_meta_label', sa.VARCHAR(), autoincrement=False, nullable=True, comment='This is a representation of the repo:branch information in the pull request. Head is issueing the pull request and base is taking the pull request. For example:  (We do not store all of this)\n\n "head": {\n      "label": "chaoss:pull-request-worker",\n      "ref": "pull-request-worker",\n      "sha": "6b380c3d6d625616f79d702612ebab6d204614f2",\n      "user": {\n        "login": "chaoss",\n        "id": 29740296,\n        "node_id": "MDEyOk9yZ2FuaXphdGlvbjI5NzQwMjk2",\n        "avatar_url": "https://avatars2.githubusercontent.com/u/29740296?v=4",\n        "gravatar_id": "",\n        "url": "https://api.github.com/users/chaoss",\n        "html_url": "https://github.com/chaoss",\n        "followers_url": "https://api.github.com/users/chaoss/followers",\n        "following_url": "https://api.github.com/users/chaoss/following{/other_user}",\n        "gists_url": "https://api.github.com/users/chaoss/gists{/gist_id}",\n        "starred_url": "https://api.github.com/users/chaoss/starred{/owner}{/repo}",\n        "subscriptions_url": "https://api.github.com/users/chaoss/subscriptions",\n        "organizations_url": "https://api.github.com/users/chaoss/orgs",\n        "repos_url": "https://api.github.com/users/chaoss/repos",\n        "events_url": "https://api.github.com/users/chaoss/events{/privacy}",\n        "received_events_url": "https://api.github.com/users/chaoss/received_events",\n        "type": "Organization",\n        "site_admin": false\n      },\n      "repo": {\n        "id": 78134122,\n        "node_id": "MDEwOlJlcG9zaXRvcnk3ODEzNDEyMg==",\n        "name": "augur",\n        "full_name": "chaoss/augur",\n        "private": false,\n        "owner": {\n          "login": "chaoss",\n          "id": 29740296,\n          "node_id": "MDEyOk9yZ2FuaXphdGlvbjI5NzQwMjk2",\n          "avatar_url": "https://avatars2.githubusercontent.com/u/29740296?v=4",\n          "gravatar_id": "",\n          "url": "https://api.github.com/users/chaoss",\n          "html_url": "https://github.com/chaoss",\n          "followers_url": "https://api.github.com/users/chaoss/followers",\n          "following_url": "https://api.github.com/users/chaoss/following{/other_user}",\n          "gists_url": "https://api.github.com/users/chaoss/gists{/gist_id}",\n          "starred_url": "https://api.github.com/users/chaoss/starred{/owner}{/repo}",\n          "subscriptions_url": "https://api.github.com/users/chaoss/subscriptions",\n          "organizations_url": "https://api.github.com/users/chaoss/orgs",\n          "repos_url": "https://api.github.com/users/chaoss/repos",\n          "events_url": "https://api.github.com/users/chaoss/events{/privacy}",\n          "received_events_url": "https://api.github.com/users/chaoss/received_events",\n          "type": "Organization",\n          "site_admin": false\n        },\n        "html_url": "https://github.com/chaoss/augur",\n        "description": "Python library and web service for Open Source Software Health and Sustainability metrics & data collection.",\n        "fork": false,\n        "url": "https://api.github.com/repos/chaoss/augur",\n        "forks_url": "https://api.github.com/repos/chaoss/augur/forks",\n        "keys_url": "https://api.github.com/repos/chaoss/augur/keys{/key_id}",\n        "collaborators_url": "https://api.github.com/repos/chaoss/augur/collaborators{/collaborator}",\n        "teams_url": "https://api.github.com/repos/chaoss/augur/teams",\n        "hooks_url": "https://api.github.com/repos/chaoss/augur/hooks",\n        "issue_events_url": "https://api.github.com/repos/chaoss/augur/issues/events{/number}",\n        "events_url": "https://api.github.com/repos/chaoss/augur/events",\n        "assignees_url": "https://api.github.com/repos/chaoss/augur/assignees{/user}",\n        "branches_url": "https://api.github.com/repos/chaoss/augur/branches{/branch}",\n        "tags_url": "https://api.github.com/repos/chaoss/augur/tags",\n        "blobs_url": "https://api.github.com/repos/chaoss/augur/git/blobs{/sha}",\n        "git_tags_url": "https://api.github.com/repos/chaoss/augur/git/tags{/sha}",\n        "git_refs_url": "https://api.github.com/repos/chaoss/augur/git/refs{/sha}",\n        "trees_url": "https://api.github.com/repos/chaoss/augur/git/trees{/sha}",\n        "statuses_url": "https://api.github.com/repos/chaoss/augur/statuses/{sha}",\n        "languages_url": "https://api.github.com/repos/chaoss/augur/languages",\n        "stargazers_url": "https://api.github.com/repos/chaoss/augur/stargazers",\n        "contributors_url": "https://api.github.com/repos/chaoss/augur/contributors",\n        "subscribers_url": "https://api.github.com/repos/chaoss/augur/subscribers",\n        "subscription_url": "https://api.github.com/repos/chaoss/augur/subscription",\n        "commits_url": "https://api.github.com/repos/chaoss/augur/commits{/sha}",\n        "git_commits_url": "https://api.github.com/repos/chaoss/augur/git/commits{/sha}",\n        "comments_url": "https://api.github.com/repos/chaoss/augur/comments{/number}",\n        "issue_comment_url": "https://api.github.com/repos/chaoss/augur/issues/comments{/number}",\n        "contents_url": "https://api.github.com/repos/chaoss/augur/contents/{+path}",\n        "compare_url": "https://api.github.com/repos/chaoss/augur/compare/{base}...{head}",\n        "merges_url": "https://api.github.com/repos/chaoss/augur/merges",\n        "archive_url": "https://api.github.com/repos/chaoss/augur/{archive_format}{/ref}",\n        "downloads_url": "https://api.github.com/repos/chaoss/augur/downloads",\n        "issues_url": "https://api.github.com/repos/chaoss/augur/issues{/number}",\n        "pulls_url": "https://api.github.com/repos/chaoss/augur/pulls{/number}",\n        "milestones_url": "https://api.github.com/repos/chaoss/augur/milestones{/number}",\n        "notifications_url": "https://api.github.com/repos/chaoss/augur/notifications{?since,all,participating}",\n        "labels_url": "https://api.github.com/repos/chaoss/augur/labels{/name}",\n        "releases_url": "https://api.github.com/repos/chaoss/augur/releases{/id}",\n        "deployments_url": "https://api.github.com/repos/chaoss/augur/deployments",\n        "created_at": "2017-01-05T17:34:54Z",\n        "updated_at": "2019-11-15T00:56:12Z",\n        "pushed_at": "2019-12-02T06:27:26Z",\n        "git_url": "git://github.com/chaoss/augur.git",\n        "ssh_url": "git@github.com:chaoss/augur.git",\n        "clone_url": "https://github.com/chaoss/augur.git",\n        "svn_url": "https://github.com/chaoss/augur",\n        "homepage": "http://augur.osshealth.io/",\n        "size": 82004,\n        "stargazers_count": 153,\n        "watchers_count": 153,\n        "language": "Python",\n        "has_issues": true,\n        "has_projects": false,\n        "has_downloads": true,\n        "has_wiki": false,\n        "has_pages": true,\n        "forks_count": 205,\n        "mirror_url": null,\n        "archived": false,\n        "disabled": false,\n        "open_issues_count": 14,\n        "license": {\n          "key": "mit",\n          "name": "MIT License",\n          "spdx_id": "MIT",\n          "url": "https://api.github.com/licenses/mit",\n          "node_id": "MDc6TGljZW5zZTEz"\n        },\n        "forks": 205,\n        "open_issues": 14,\n        "watchers": 153,\n        "default_branch": "master"\n      }\n    },\n    "base": {\n      "label": "chaoss:dev",\n      "ref": "dev",\n      "sha": "bfd2d34b51659613dd842cf83c3873f7699c2a0e",\n      "user": {\n        "login": "chaoss",\n        "id": 29740296,\n        "node_id": "MDEyOk9yZ2FuaXphdGlvbjI5NzQwMjk2",\n        "avatar_url": "https://avatars2.githubusercontent.com/u/29740296?v=4",\n        "gravatar_id": "",\n        "url": "https://api.github.com/users/chaoss",\n        "html_url": "https://github.com/chaoss",\n        "followers_url": "https://api.github.com/users/chaoss/followers",\n        "following_url": "https://api.github.com/users/chaoss/following{/other_user}",\n        "gists_url": "https://api.github.com/users/chaoss/gists{/gist_id}",\n        "starred_url": "https://api.github.com/users/chaoss/starred{/owner}{/repo}",\n        "subscriptions_url": "https://api.github.com/users/chaoss/subscriptions",\n        "organizations_url": "https://api.github.com/users/chaoss/orgs",\n        "repos_url": "https://api.github.com/users/chaoss/repos",\n        "events_url": "https://api.github.com/users/chaoss/events{/privacy}",\n        "received_events_url": "https://api.github.com/users/chaoss/received_events",\n        "type": "Organization",\n        "site_admin": false\n      },\n      "repo": {\n        "id": 78134122,\n        "node_id": "MDEwOlJlcG9zaXRvcnk3ODEzNDEyMg==",\n        "name": "augur",\n        "full_name": "chaoss/augur",\n        "private": false,\n        "owner": {\n          "login": "chaoss",\n          "id": 29740296,\n          "node_id": "MDEyOk9yZ2FuaXphdGlvbjI5NzQwMjk2",\n          "avatar_url": "https://avatars2.githubusercontent.com/u/29740296?v=4",\n          "gravatar_id": "",\n          "url": "https://api.github.com/users/chaoss",\n          "html_url": "https://github.com/chaoss",\n          "followers_url": "https://api.github.com/users/chaoss/followers",\n          "following_url": "https://api.github.com/users/chaoss/following{/other_user}",\n          "gists_url": "https://api.github.com/users/chaoss/gists{/gist_id}",\n          "starred_url": "https://api.github.com/users/chaoss/starred{/owner}{/repo}",\n          "subscriptions_url": "https://api.github.com/users/chaoss/subscriptions",\n          "organizations_url": "https://api.github.com/users/chaoss/orgs",\n          "repos_url": "https://api.github.com/users/chaoss/repos",\n          "events_url": "https://api.github.com/users/chaoss/events{/privacy}",\n          "received_events_url": "https://api.github.com/users/chaoss/received_events",\n          "type": "Organization",\n          "site_admin": false\n        },\n'),
    sa.Column('pr_src_meta_ref', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_sha', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('cntrb_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['cntrb_id'], ['contributors.cntrb_id'], name='pull_request_meta_cntrb_id_fkey'),
    sa.ForeignKeyConstraint(['pull_request_id'], ['pull_requests.pull_request_id'], name='fk_pull_request_meta_pull_requests_1', onupdate='CASCADE', ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_pull_request_repo_meta_repo_id', onupdate='CASCADE', ondelete='RESTRICT', initially='DEFERRED', deferrable=True),
    sa.PrimaryKeyConstraint('pr_repo_meta_id', name='pull_request_meta_pkey'),
    sa.UniqueConstraint('pull_request_id', 'pr_head_or_base', 'pr_sha', name='pull-request-meta-insert-unique'),
    comment='Pull requests contain referencing metadata.  There are a few columns that are discrete. There are also head and base designations for the repo on each side of the pull request. Similar functions exist in GitLab, though the language here is based on GitHub. The JSON Being adapted to as of the development of this schema is here:      "base": {       "label": "chaoss:dev",       "ref": "dev",       "sha": "dc6c6f3947f7dc84ecba3d8bda641ef786e7027d",       "user": {         "login": "chaoss",         "id": 29740296,         "node_id": "MDEyOk9yZ2FuaXphdGlvbjI5NzQwMjk2",         "avatar_url": "https://avatars2.githubusercontent.com/u/29740296?v=4",         "gravatar_id": "",         "url": "https://api.github.com/users/chaoss",         "html_url": "https://github.com/chaoss",         "followers_url": "https://api.github.com/users/chaoss/followers",         "following_url": "https://api.github.com/users/chaoss/following{/other_user}",         "gists_url": "https://api.github.com/users/chaoss/gists{/gist_id}",         "starred_url": "https://api.github.com/users/chaoss/starred{/owner}{/repo}",         "subscriptions_url": "https://api.github.com/users/chaoss/subscriptions",         "organizations_url": "https://api.github.com/users/chaoss/orgs",         "repos_url": "https://api.github.com/users/chaoss/repos",         "events_url": "https://api.github.com/users/chaoss/events{/privacy}",         "received_events_url": "https://api.github.com/users/chaoss/received_events",         "type": "Organization",         "site_admin": false       },       "repo": {         "id": 78134122,         "node_id": "MDEwOlJlcG9zaXRvcnk3ODEzNDEyMg==",         "name": "augur",         "full_name": "chaoss/augur",         "private": false,         "owner": {           "login": "chaoss",           "id": 29740296,           "node_id": "MDEyOk9yZ2FuaXphdGlvbjI5NzQwMjk2",           "avatar_url": "https://avatars2.githubusercontent.com/u/29740296?v=4",           "gravatar_id": "",           "url": "https://api.github.com/users/chaoss",           "html_url": "https://github.com/chaoss",           "followers_url": "https://api.github.com/users/chaoss/followers",           "following_url": "https://api.github.com/users/chaoss/following{/other_user}",           "gists_url": "https://api.github.com/users/chaoss/gists{/gist_id}",           "starred_url": "https://api.github.com/users/chaoss/starred{/owner}{/repo}",           "subscriptions_url": "https://api.github.com/users/chaoss/subscriptions",           "organizations_url": "https://api.github.com/users/chaoss/orgs",           "repos_url": "https://api.github.com/users/chaoss/repos",           "events_url": "https://api.github.com/users/chaoss/events{/privacy}",           "received_events_url": "https://api.github.com/users/chaoss/received_events",           "type": "Organization",           "site_admin": false         }, ',
    postgresql_ignore_search_path=False
    )
    op.create_index('pr_meta-cntrbid-idx', 'pull_request_meta', ['cntrb_id'], unique=False)
    op.create_table('augur_repo_map',
    sa.Column('map_id', sa.INTEGER(), server_default=sa.text("nextval('augur_repo_map_map_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('dosocs_pkg_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('dosocs_pkg_name', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('repo_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('repo_path', sa.TEXT(), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('map_id', name='augur_repo_map_pkey')
    )
    op.create_table('user_groups',
    sa.Column('group_id', sa.BIGINT(), server_default=sa.text("nextval('user_groups_group_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('user_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('name', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('favorited', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.user_id'], name='user_groups_user_id_fkey'),
    sa.PrimaryKeyConstraint('group_id', name='user_groups_pkey'),
    sa.UniqueConstraint('user_id', 'name', name='user_groups_user_id_name_key'),
    postgresql_ignore_search_path=False
    )
    op.create_table('pull_request_teams',
    sa.Column('pr_team_id', sa.BIGINT(), server_default=sa.text("nextval('pull_request_teams_pr_team_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('pull_request_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_src_team_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_src_team_node', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_src_team_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_team_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_team_slug', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_team_description', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_team_privacy', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_team_permission', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_team_src_members_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_team_src_repositories_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_team_parent_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['pull_request_id'], ['pull_requests.pull_request_id'], name='fk_pull_request_teams_pull_requests_1', onupdate='CASCADE', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('pr_team_id', name='pull_request_teams_pkey')
    )
    op.create_table('libraries',
    sa.Column('library_id', sa.BIGINT(), server_default=sa.text("nextval('libraries_library_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('platform', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('created_timestamp', postgresql.TIMESTAMP(precision=0), server_default=sa.text('NULL::timestamp without time zone'), autoincrement=False, nullable=True),
    sa.Column('updated_timestamp', postgresql.TIMESTAMP(precision=0), server_default=sa.text('NULL::timestamp without time zone'), autoincrement=False, nullable=True),
    sa.Column('library_description', sa.VARCHAR(length=2000), server_default=sa.text('NULL::character varying'), autoincrement=False, nullable=True),
    sa.Column('keywords', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('library_homepage', sa.VARCHAR(length=1000), server_default=sa.text('NULL::character varying'), autoincrement=False, nullable=True),
    sa.Column('license', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('version_count', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('latest_release_timestamp', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('latest_release_number', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('package_manager_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('dependency_count', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('dependent_library_count', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('primary_language', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_libraries_repo_1'),
    sa.PrimaryKeyConstraint('library_id', name='libraries_pkey'),
    postgresql_ignore_search_path=False
    )
    op.create_table('chaoss_metric_status',
    sa.Column('cms_id', sa.BIGINT(), server_default=sa.text("nextval('chaoss_metric_status_cms_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('cm_group', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('cm_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('cm_type', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('cm_backend_status', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('cm_frontend_status', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('cm_defined', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('cm_api_endpoint_repo', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('cm_api_endpoint_rg', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('cm_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('cm_working_group', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('cm_info', postgresql.JSON(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('cm_working_group_focus_area', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('cms_id', name='chaoss_metric_status_pkey'),
    comment='This table used to track CHAOSS Metric implementations in Augur, but due to the constantly changing location of that information, it is for the moment not actively populated. '
    )
    op.create_table('subscription_types',
    sa.Column('id', sa.BIGINT(), autoincrement=True, nullable=False),
    sa.Column('name', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name='subscription_types_pkey'),
    sa.UniqueConstraint('name', name='subscription_type_title_unique')
    )
    op.create_table('unknown_cache',
    sa.Column('type', sa.VARCHAR(length=10), autoincrement=False, nullable=False),
    sa.Column('repo_group_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('email', sa.VARCHAR(length=128), autoincrement=False, nullable=False),
    sa.Column('domain', sa.VARCHAR(length=128), server_default=sa.text("'NULL'::character varying"), autoincrement=False, nullable=True),
    sa.Column('added', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True)
    )
    op.create_index('type,projects_id', 'unknown_cache', ['type', 'repo_group_id'], unique=False)
    op.create_table('message_sentiment',
    sa.Column('msg_analysis_id', sa.BIGINT(), server_default=sa.text("nextval('message_sentiment_msg_analysis_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('msg_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('worker_run_id', sa.BIGINT(), autoincrement=False, nullable=True, comment='This column is used to indicate analyses run by a worker during the same execution period, and is useful for grouping, and time series analysis.  '),
    sa.Column('sentiment_score', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True, comment='A sentiment analysis score. Zero is neutral, negative numbers are negative sentiment, and positive numbers are positive sentiment. '),
    sa.Column('reconstruction_error', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True, comment='Each message is converted to a 250 dimensin doc2vec vector, so the reconstruction error is the difference between what the predicted vector and the actual vector.'),
    sa.Column('novelty_flag', sa.BOOLEAN(), autoincrement=False, nullable=True, comment='This is an analysis of the degree to which the message is novel when compared to other messages in a repository.  For example when bots are producing numerous identical messages, the novelty score is low. It would also be a low novelty score when several people are making the same coment. '),
    sa.Column('feedback_flag', sa.BOOLEAN(), autoincrement=False, nullable=True, comment='This exists to provide the user with an opportunity provide feedback on the resulting the sentiment scores. '),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['msg_id'], ['message.msg_id'], name='fk_message_sentiment_message_1'),
    sa.PrimaryKeyConstraint('msg_analysis_id', name='message_sentiment_pkey')
    )
    op.create_table('client_applications',
    sa.Column('id', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('api_key', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('user_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('name', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('redirect_url', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.user_id'], name='client_application_user_id_fkey'),
    sa.PrimaryKeyConstraint('id', name='client_applications_pkey'),
    postgresql_ignore_search_path=False
    )
    op.create_table('scanners',
    sa.Column('scanner_id', sa.INTEGER(), server_default=sa.text("nextval('scanners_scanner_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('name', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('scanner_id', name='scanners_pkey'),
    sa.UniqueConstraint('name', name='uc_scanner_name')
    )
    op.create_table('unresolved_commit_emails',
    sa.Column('email_unresolved_id', sa.BIGINT(), server_default=sa.text("nextval('unresolved_commit_emails_email_unresolved_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('email', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('email_unresolved_id', name='unresolved_commit_emails_pkey'),
    sa.UniqueConstraint('email', name='unresolved_commit_emails_email_key')
    )
    op.create_table('relationships',
    sa.Column('relationship_id', sa.INTEGER(), server_default=sa.text("nextval('relationships_relationship_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('left_identifier_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('right_identifier_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('relationship_type_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('relationship_comment', sa.TEXT(), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['left_identifier_id'], ['identifiers.identifier_id'], name='relationships_left_identifier_id_fkey'),
    sa.ForeignKeyConstraint(['relationship_type_id'], ['relationship_types.relationship_type_id'], name='relationships_relationship_type_id_fkey'),
    sa.ForeignKeyConstraint(['right_identifier_id'], ['identifiers.identifier_id'], name='relationships_right_identifier_id_fkey'),
    sa.PrimaryKeyConstraint('relationship_id', name='relationships_pkey'),
    sa.UniqueConstraint('left_identifier_id', 'right_identifier_id', 'relationship_type_id', name='uc_left_right_relationship_type')
    )
    op.create_table('issue_events',
    sa.Column('event_id', sa.BIGINT(), server_default=sa.text("nextval('issue_events_event_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('issue_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('action', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('action_commit_hash', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=False),
    sa.Column('node_id', sa.VARCHAR(), autoincrement=False, nullable=True, comment='This should be renamed to issue_event_src_node_id, as its the varchar identifier in GitHub and likely common in other sources as well. However, since it was created before we came to this naming standard and workers are built around it, we have it simply named as node_id. Anywhere you see node_id in the schema, it comes from GitHubs terminology.'),
    sa.Column('node_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('platform_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('issue_event_src_id', sa.BIGINT(), autoincrement=False, nullable=True, comment='This ID comes from the source. In the case of GitHub, it is the id that is the first field returned from the issue events API'),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('cntrb_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['cntrb_id'], ['contributors.cntrb_id'], name='issue_events_cntrb_id_fkey', onupdate='CASCADE', ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['issue_id'], ['issues.issue_id'], name='fk_issue_events_issues_1', onupdate='CASCADE', ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['platform_id'], ['platform.pltfrm_id'], name='fk_issue_event_platform_ide', onupdate='CASCADE', ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_issue_events_repo', onupdate='CASCADE', ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('event_id', name='issue_events_pkey'),
    sa.UniqueConstraint('issue_id', 'issue_event_src_id', name='unique_event_id_key')
    )
    op.create_index('issue_events_ibfk_2', 'issue_events', ['cntrb_id'], unique=False)
    op.create_index('issue_events_ibfk_1', 'issue_events', ['issue_id'], unique=False)
    op.create_index('issue-cntrb-idx2', 'issue_events', ['issue_event_src_id'], unique=False)
    op.create_table('repo_insights_records',
    sa.Column('ri_id', sa.BIGINT(), server_default=sa.text("nextval('repo_insights_records_ri_id_seq'::regclass)"), autoincrement=True, nullable=False, comment='Primary key. '),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True, comment='Refers to repo table primary key. Will have a foreign key'),
    sa.Column('ri_metric', sa.VARCHAR(), autoincrement=False, nullable=True, comment='The metric endpoint'),
    sa.Column('ri_field', sa.VARCHAR(), autoincrement=False, nullable=True, comment='The field in the metric endpoint'),
    sa.Column('ri_value', sa.VARCHAR(), autoincrement=False, nullable=True, comment='The value of the endpoint in ri_field'),
    sa.Column('ri_date', postgresql.TIMESTAMP(precision=6), autoincrement=False, nullable=True, comment='The date the insight is for; in other words, some anomaly occurred on this date. '),
    sa.Column('ri_score', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True, comment='A Score, derived from the algorithm used. '),
    sa.Column('ri_detection_method', sa.VARCHAR(), autoincrement=False, nullable=True, comment='A confidence interval or other expression of the type of threshold and the value of a threshold met in order for it to be "an insight". Example. "95% confidence interval". '),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True, comment='Standard Augur Metadata'),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True, comment='Standard Augur Metadata'),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True, comment='Standard Augur Metadata'),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=6), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True, comment='Standard Augur Metadata'),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='repo_id_ref', onupdate='CASCADE', ondelete='SET NULL'),
    sa.PrimaryKeyConstraint('ri_id', name='repo_insights_records_pkey')
    )
    op.create_index('dater', 'repo_insights_records', ['ri_date'], unique=False)
    op.create_table('relationship_types',
    sa.Column('relationship_type_id', sa.INTEGER(), server_default=sa.text("nextval('relationship_types_relationship_type_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('name', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('relationship_type_id', name='relationship_types_pkey'),
    sa.UniqueConstraint('name', name='uc_relationship_type_name')
    )
    op.create_table('worker_settings_facade',
    sa.Column('id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('setting', sa.VARCHAR(length=32), autoincrement=False, nullable=False),
    sa.Column('value', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('last_modified', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name='settings_pkey'),
    comment='For future use when we move all working tables to the augur_operations schema. '
    )
    op.create_table('dm_repo_group_weekly',
    sa.Column('repo_group_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('email', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('affiliation', sa.VARCHAR(), server_default=sa.text("'NULL'::character varying"), autoincrement=False, nullable=True),
    sa.Column('week', sa.SMALLINT(), autoincrement=False, nullable=False),
    sa.Column('year', sa.SMALLINT(), autoincrement=False, nullable=False),
    sa.Column('added', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('removed', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('whitespace', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('files', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('patches', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True)
    )
    op.create_index('projects_id,year,email', 'dm_repo_group_weekly', ['repo_group_id', 'year', 'email'], unique=False)
    op.create_index('projects_id,year,affiliation', 'dm_repo_group_weekly', ['repo_group_id', 'year', 'affiliation'], unique=False)
    op.create_index('projects_id,email', 'dm_repo_group_weekly', ['repo_group_id', 'email'], unique=False)
    op.create_index('projects_id,affiliation', 'dm_repo_group_weekly', ['repo_group_id', 'affiliation'], unique=False)
    op.create_table('config',
    sa.Column('id', sa.SMALLINT(), server_default=sa.text("nextval('config_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('section_name', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('setting_name', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('value', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('type', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('id', name='config_pkey'),
    sa.UniqueConstraint('section_name', 'setting_name', name='unique-config-setting')
    )
    op.create_table('repo_groups_list_serve',
    sa.Column('rgls_id', sa.BIGINT(), server_default=sa.text("nextval('repo_groups_list_serve_rgls_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_group_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('rgls_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('rgls_description', sa.VARCHAR(length=3000), autoincrement=False, nullable=True),
    sa.Column('rgls_sponsor', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('rgls_email', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_group_id'], ['repo_groups.repo_group_id'], name='fk_repo_groups_list_serve_repo_groups_1'),
    sa.PrimaryKeyConstraint('rgls_id', name='repo_groups_list_serve_pkey'),
    sa.UniqueConstraint('rgls_id', 'repo_group_id', name='rglistserve'),
    postgresql_ignore_search_path=False
    )
    op.create_index('lister', 'repo_groups_list_serve', ['rgls_id', 'repo_group_id'], unique=True)
    op.create_table('user_repos',
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('group_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['group_id'], ['user_groups.group_id'], name='user_repos_group_id_fkey'),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='user_repos_repo_id_fkey'),
    sa.PrimaryKeyConstraint('group_id', 'repo_id', name='user_repos_pkey')
    )
    op.create_table('pull_requests',
    sa.Column('pull_request_id', sa.BIGINT(), server_default=sa.text("nextval('pull_requests_pull_request_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), server_default=sa.text('0'), autoincrement=False, nullable=True),
    sa.Column('pr_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_src_id', sa.BIGINT(), autoincrement=False, nullable=True, comment='The pr_src_id is unique across all of github.'),
    sa.Column('pr_src_node_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_html_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_diff_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_patch_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_issue_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_augur_issue_id', sa.BIGINT(), autoincrement=False, nullable=True, comment='This is to link to the augur stored related issue'),
    sa.Column('pr_src_number', sa.BIGINT(), autoincrement=False, nullable=True, comment='The pr_src_number is unique within a repository.'),
    sa.Column('pr_src_state', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_src_locked', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('pr_src_title', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_body', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('pr_created_at', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.Column('pr_updated_at', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.Column('pr_closed_at', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.Column('pr_merged_at', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.Column('pr_merge_commit_sha', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_teams', sa.BIGINT(), autoincrement=False, nullable=True, comment='One to many with pull request teams. '),
    sa.Column('pr_milestone', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_commits_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_review_comments_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_review_comment_url', sa.VARCHAR(), autoincrement=False, nullable=True, comment='This is a field with limited utility. It does expose how to access a specific comment if needed with parameters. If the source changes URL structure, it may be useful'),
    sa.Column('pr_comments_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_statuses_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_meta_head_id', sa.VARCHAR(), autoincrement=False, nullable=True, comment='The metadata for the head repo that links to the pull_request_meta table. '),
    sa.Column('pr_meta_base_id', sa.VARCHAR(), autoincrement=False, nullable=True, comment='The metadata for the base repo that links to the pull_request_meta table. '),
    sa.Column('pr_src_issue_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_src_comments_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_src_review_comments_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_src_commits_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_src_statuses_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_src_author_association', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('pr_augur_contributor_id', sa.UUID(), autoincrement=False, nullable=True, comment='This is to link to the augur contributor record. '),
    sa.ForeignKeyConstraint(['pr_augur_contributor_id'], ['contributors.cntrb_id'], name='pull_requests_pr_augur_contributor_id_fkey', onupdate='CASCADE', ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_pull_requests_repo_1', onupdate='CASCADE', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('pull_request_id', name='pull_requests_pkey'),
    sa.UniqueConstraint('pr_url', name='pull-request-insert-unique'),
    sa.UniqueConstraint('repo_id', 'pr_src_id', name='unique-pr'),
    sa.UniqueConstraint('repo_id', 'pr_src_id', name='unique-prx'),
    postgresql_ignore_search_path=False
    )
    op.create_index('pull_requests_idx_repo_id_data_datex', 'pull_requests', ['repo_id', 'data_collection_date'], unique=False)
    op.create_index('pr_ID_prs_table', 'pull_requests', ['pull_request_id'], unique=False)
    op.create_index('id_node', 'pull_requests', [sa.literal_column('pr_src_id DESC'), sa.literal_column('pr_src_node_id DESC NULLS LAST')], unique=False)
    op.create_table('repo_info',
    sa.Column('repo_info_id', sa.BIGINT(), server_default=sa.text("nextval('repo_info_repo_info_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('last_updated', postgresql.TIMESTAMP(precision=0), server_default=sa.text('NULL::timestamp without time zone'), autoincrement=False, nullable=True),
    sa.Column('issues_enabled', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('open_issues', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('pull_requests_enabled', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('wiki_enabled', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pages_enabled', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('fork_count', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('default_branch', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('watchers_count', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('UUID', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('license', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('stars_count', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('committers_count', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('issue_contributors_count', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('changelog_file', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('contributing_file', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('license_file', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('code_of_conduct_file', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('security_issue_file', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('security_audit_file', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('status', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('keywords', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('commit_count', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('issues_count', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('issues_closed', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pull_request_count', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pull_requests_open', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pull_requests_closed', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pull_requests_merged', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_repo_info_repo_1'),
    sa.PrimaryKeyConstraint('repo_info_id', name='repo_info_pkey')
    )
    op.create_index('repo_info_idx_repo_id_data_datex', 'repo_info', ['repo_id', 'data_collection_date'], unique=False)
    op.create_index('repo_info_idx_repo_id_data_date_1x', 'repo_info', ['repo_id', 'data_collection_date'], unique=False)
    op.create_table('worker_oauth',
    sa.Column('oauth_id', sa.BIGINT(), server_default=sa.text("nextval('worker_oauth_oauth_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('name', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.Column('consumer_key', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.Column('consumer_secret', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.Column('access_token', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.Column('access_token_secret', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.Column('repo_directory', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('platform', sa.VARCHAR(), server_default=sa.text("'github'::character varying"), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('oauth_id', name='worker_oauth_pkey'),
    comment='This table stores credentials for retrieving data from platform API’s. Entries in this table must comply with the terms of service for each platform. '
    )
    op.create_table('utility_log',
    sa.Column('id', sa.BIGINT(), server_default=sa.text("nextval('utility_log_id_seq1'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('level', sa.VARCHAR(length=8), autoincrement=False, nullable=False),
    sa.Column('status', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('attempted', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name='utility_log_pkey')
    )
    op.create_table('dei_badging',
    sa.Column('id', sa.INTEGER(), autoincrement=True, nullable=False),
    sa.Column('badging_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('level', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='user_repo_user_id_fkey'),
    sa.PrimaryKeyConstraint('id', 'repo_id', name='dei_badging_pkey')
    )
    op.create_table('repo_group_insights',
    sa.Column('rgi_id', sa.BIGINT(), server_default=sa.text("nextval('repo_group_insights_rgi_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_group_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('rgi_metric', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('rgi_value', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('cms_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('rgi_fresh', sa.BOOLEAN(), autoincrement=False, nullable=True, comment='false if the date is before the statistic that triggered the insight, true if after. This allows us to automatically display only "fresh insights" and avoid displaying "stale insights". The insight worker will populate this table. '),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_group_id'], ['repo_groups.repo_group_id'], name='fk_repo_group_insights_repo_groups_1'),
    sa.PrimaryKeyConstraint('rgi_id', name='repo_group_insights_pkey'),
    comment='This table is output from an analytical worker inside of Augur. It runs through the different metrics on a REPOSITORY_GROUP and identifies the five to ten most “interesting” metrics as defined by some kind of delta or other factor. The algorithm is going to evolve. \n\nWorker Design Notes: The idea is that the "insight worker" will scan through a bunch of active metrics or "synthetic metrics" to list the most important insights. '
    )
    op.create_table('pull_request_message_ref',
    sa.Column('pr_msg_ref_id', sa.BIGINT(), server_default=sa.text("nextval('pull_request_message_ref_pr_msg_ref_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('pull_request_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('msg_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_message_ref_src_comment_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_message_ref_src_node_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_issue_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['msg_id'], ['message.msg_id'], name='fk_pull_request_message_ref_message_1', onupdate='CASCADE', ondelete='RESTRICT', initially='DEFERRED', deferrable=True),
    sa.ForeignKeyConstraint(['pull_request_id'], ['pull_requests.pull_request_id'], name='fk_pull_request_message_ref_pull_requests_1', onupdate='CASCADE', ondelete='CASCADE', initially='DEFERRED', deferrable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_pr_repo', onupdate='CASCADE', ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('pr_msg_ref_id', name='pull_request_message_ref_pkey'),
    sa.UniqueConstraint('pr_message_ref_src_comment_id', 'pull_request_id', name='pull-request-message-ref-insert-unique')
    )
    op.create_table('working_commits',
    sa.Column('repos_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('working_commit', sa.VARCHAR(length=40), server_default=sa.text("'NULL'::character varying"), autoincrement=False, nullable=True)
    )
    op.create_table('repo_sbom_scans',
    sa.Column('rsb_id', sa.BIGINT(), server_default=sa.text("nextval('repo_sbom_scans_rsb_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('sbom_scan', postgresql.JSON(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='repo_linker_sbom', onupdate='CASCADE', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('rsb_id', name='repo_sbom_scans_pkey')
    )
    op.create_table('all',
    sa.Column('Name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('Bytes', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('Lines', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('Code', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('Comment', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('Blank', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('Complexity', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('Count', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('WeightedComplexity', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('Files', sa.VARCHAR(), autoincrement=False, nullable=True)
    )
    op.create_table('worker_job',
    sa.Column('job_model', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.Column('state', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False),
    sa.Column('zombie_head', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('since_id_str', sa.VARCHAR(length=255), server_default=sa.text("'0'::character varying"), autoincrement=False, nullable=False),
    sa.Column('description', sa.VARCHAR(length=255), server_default=sa.text("'None'::character varying"), autoincrement=False, nullable=True),
    sa.Column('last_count', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('last_run', postgresql.TIMESTAMP(precision=0), server_default=sa.text('NULL::timestamp without time zone'), autoincrement=False, nullable=True),
    sa.Column('analysis_state', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=True),
    sa.Column('oauth_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('job_model', name='job_pkey'),
    comment='This table stores the jobs workers collect data for. A job is found in the code, and in the augur.config.json under the construct of a “model”. '
    )
    op.create_table('issue_message_ref',
    sa.Column('issue_msg_ref_id', sa.BIGINT(), server_default=sa.text("nextval('issue_message_ref_issue_msg_ref_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('issue_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('msg_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('issue_msg_ref_src_node_id', sa.VARCHAR(), autoincrement=False, nullable=True, comment='This character based identifier comes from the source. In the case of GitHub, it is the id that is the first field returned from the issue comments API'),
    sa.Column('issue_msg_ref_src_comment_id', sa.BIGINT(), autoincrement=False, nullable=True, comment='This ID comes from the source. In the case of GitHub, it is the id that is the first field returned from the issue comments API'),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['issue_id'], ['issues.issue_id'], name='fk_issue_message_ref_issues_1', onupdate='CASCADE', ondelete='CASCADE', initially='DEFERRED', deferrable=True),
    sa.ForeignKeyConstraint(['msg_id'], ['message.msg_id'], name='fk_issue_message_ref_message_1', onupdate='CASCADE', ondelete='RESTRICT', initially='DEFERRED', deferrable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_repo_id_fk1', onupdate='CASCADE', ondelete='RESTRICT', initially='DEFERRED', deferrable=True),
    sa.PrimaryKeyConstraint('issue_msg_ref_id', name='issue_message_ref_pkey'),
    sa.UniqueConstraint('issue_msg_ref_src_comment_id', 'issue_id', name='issue-message-ref-insert-unique')
    )
    op.create_table('repo_dependencies',
    sa.Column('repo_dependencies_id', sa.BIGINT(), server_default=sa.text("nextval('repo_dependencies_repo_dependencies_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True, comment='Forign key for repo id. '),
    sa.Column('dep_name', sa.VARCHAR(), autoincrement=False, nullable=True, comment='Name of the dependancy found in project. '),
    sa.Column('dep_count', sa.INTEGER(), autoincrement=False, nullable=True, comment='Number of times the dependancy was found. '),
    sa.Column('dep_language', sa.VARCHAR(), autoincrement=False, nullable=True, comment='Language of the dependancy. '),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='repo_id'),
    sa.PrimaryKeyConstraint('repo_dependencies_id', name='repo_dependencies_pkey'),
    sa.UniqueConstraint('repo_id', 'dep_name', 'data_collection_date', name='deps-insert-unique'),
    comment='Contains the dependencies for a repo.'
    )
    op.create_table('licenses',
    sa.Column('license_id', sa.INTEGER(), server_default=sa.text("nextval('licenses_license_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('name', sa.VARCHAR(length=255), autoincrement=False, nullable=True),
    sa.Column('short_name', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.Column('cross_reference', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('comment', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('is_spdx_official', sa.BOOLEAN(), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('license_id', name='licenses_pkey'),
    sa.UniqueConstraint('short_name', name='uc_license_short_name'),
    postgresql_ignore_search_path=False
    )
    op.create_table('repo_topic',
    sa.Column('repo_topic_id', sa.BIGINT(), server_default=sa.text("nextval('repo_topic_repo_topic_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('topic_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('topic_prob', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_repo_topic_repo_1'),
    sa.PrimaryKeyConstraint('repo_topic_id', name='repo_topic_pkey')
    )
    op.create_table('sbom_scans',
    sa.Column('repo_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('sbom_scan', postgresql.JSON(astext_type=sa.Text()), autoincrement=False, nullable=True)
    )
    op.create_table('repo_labor',
    sa.Column('repo_labor_id', sa.BIGINT(), server_default=sa.text("nextval('repo_labor_repo_labor_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('repo_clone_date', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.Column('rl_analysis_date', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.Column('programming_language', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('file_path', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('file_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('total_lines', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('code_lines', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('comment_lines', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('blank_lines', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('code_complexity', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('repo_url', sa.VARCHAR(), autoincrement=False, nullable=True, comment='This is a convenience column to simplify analysis against external datasets'),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_repo_labor_repo_1'),
    sa.PrimaryKeyConstraint('repo_labor_id', name='repo_labor_pkey'),
    sa.UniqueConstraint('repo_id', 'rl_analysis_date', 'file_path', 'file_name', name='rl-unique'),
    comment='repo_labor is a derivative of tables used to store scc code and complexity counting statistics that are inputs to labor analysis, which are components of CHAOSS value metric calculations. '
    )
    op.create_table('contributor_repo',
    sa.Column('cntrb_repo_id', sa.BIGINT(), server_default=sa.text("nextval('contributor_repo_cntrb_repo_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_git', sa.VARCHAR(), autoincrement=False, nullable=False, comment='Similar to cntrb_id, we need this data for the table to have meaningful data. '),
    sa.Column('repo_name', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('gh_repo_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('cntrb_category', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('event_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('cntrb_id', sa.UUID(), autoincrement=False, nullable=False, comment='This is not null because what is the point without the contributor in this table? '),
    sa.ForeignKeyConstraint(['cntrb_id'], ['contributors.cntrb_id'], name='contributor_repo_cntrb_id_fkey', onupdate='CASCADE', ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('cntrb_repo_id', name='cntrb_repo_id_key'),
    sa.UniqueConstraint('event_id', 'tool_version', name='eventer'),
    comment='Developed in Partnership with Andrew Brain. \nFrom: [\n  {\n    "login": "octocat",\n    "id": 1,\n    "node_id": "MDQ6VXNlcjE=",\n    "avatar_url": "https://github.com/images/error/octocat_happy.gif",\n    "gravatar_id": "",\n    "url": "https://api.github.com/users/octocat",\n    "html_url": "https://github.com/octocat",\n    "followers_url": "https://api.github.com/users/octocat/followers",\n    "following_url": "https://api.github.com/users/octocat/following{/other_user}",\n    "gists_url": "https://api.github.com/users/octocat/gists{/gist_id}",\n    "starred_url": "https://api.github.com/users/octocat/starred{/owner}{/repo}",\n    "subscriptions_url": "https://api.github.com/users/octocat/subscriptions",\n    "organizations_url": "https://api.github.com/users/octocat/orgs",\n    "repos_url": "https://api.github.com/users/octocat/repos",\n    "events_url": "https://api.github.com/users/octocat/events{/privacy}",\n    "received_events_url": "https://api.github.com/users/octocat/received_events",\n    "type": "User",\n    "site_admin": false\n  }\n]\n'
    )
    op.create_table('identifiers',
    sa.Column('identifier_id', sa.INTEGER(), server_default=sa.text("nextval('identifiers_identifier_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('document_namespace_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('id_string', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.Column('document_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('package_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('package_file_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.CheckConstraint('((document_id IS NOT NULL)::integer + (package_id IS NOT NULL)::integer + (package_file_id IS NOT NULL)::integer) = 1', name='ck_identifier_exactly_one'),
    sa.ForeignKeyConstraint(['document_id'], ['documents.document_id'], name='identifiers_document_id_fkey'),
    sa.ForeignKeyConstraint(['document_namespace_id'], ['document_namespaces.document_namespace_id'], name='identifiers_document_namespace_id_fkey'),
    sa.ForeignKeyConstraint(['package_file_id'], ['packages_files.package_file_id'], name='identifiers_package_file_id_fkey'),
    sa.ForeignKeyConstraint(['package_id'], ['packages.package_id'], name='identifiers_package_id_fkey'),
    sa.PrimaryKeyConstraint('identifier_id', name='identifiers_pkey'),
    sa.UniqueConstraint('document_namespace_id', 'document_id', name='uc_identifier_namespace_document_id'),
    sa.UniqueConstraint('document_namespace_id', 'id_string', name='uc_identifier_document_namespace_id'),
    sa.UniqueConstraint('document_namespace_id', 'package_file_id', name='uc_identifier_namespace_package_file_id'),
    sa.UniqueConstraint('document_namespace_id', 'package_id', name='uc_identifier_namespace_package_id'),
    postgresql_ignore_search_path=False
    )
    op.create_table('contributor_affiliations',
    sa.Column('ca_id', sa.BIGINT(), server_default=sa.text("nextval('contributor_affiliations_ca_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('ca_domain', sa.VARCHAR(length=64), autoincrement=False, nullable=False),
    sa.Column('ca_start_date', sa.DATE(), server_default=sa.text("'1970-01-01'::date"), autoincrement=False, nullable=True),
    sa.Column('ca_last_used', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=False),
    sa.Column('ca_affiliation', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('ca_active', sa.SMALLINT(), server_default=sa.text('1'), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('ca_id', name='contributor_affiliations_pkey'),
    sa.UniqueConstraint('ca_domain', name='unique_domain'),
    comment='This table exists outside of relations with other tables. The purpose is to provide a dynamic, owner maintained (and augur augmented) list of affiliations. This table is processed in affiliation information in the DM_ tables generated when Augur is finished counting commits using the Facade Worker. '
    )
    op.create_table('exclude',
    sa.Column('id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('projects_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('email', sa.VARCHAR(), server_default=sa.text("'NULL'::character varying"), autoincrement=False, nullable=True),
    sa.Column('domain', sa.VARCHAR(), server_default=sa.text("'NULL'::character varying"), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('id', name='exclude_pkey')
    )
    op.create_table('pull_request_reviewers',
    sa.Column('pr_reviewer_map_id', sa.BIGINT(), server_default=sa.text("nextval('pull_request_reviewers_pr_reviewer_map_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('pull_request_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_source_id', sa.BIGINT(), autoincrement=False, nullable=True, comment='The platform ID for the pull/merge request. Used as part of the natural key, along with pr_reviewer_src_id in this table. '),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_reviewer_src_id', sa.BIGINT(), autoincrement=False, nullable=True, comment='The platform ID for the pull/merge request reviewer. Used as part of the natural key, along with pr_source_id in this table. '),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('cntrb_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['cntrb_id'], ['contributors.cntrb_id'], name='pull_request_reviewers_cntrb_id_fkey', onupdate='CASCADE', ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['pull_request_id'], ['pull_requests.pull_request_id'], name='fk_pull_request_reviewers_pull_requests_1', onupdate='CASCADE', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('pr_reviewer_map_id', name='pull_request_reviewers_pkey'),
    sa.UniqueConstraint('pull_request_id', 'pr_reviewer_src_id', name='unique_pr_src_reviewer_key')
    )
    op.create_index('pr-reviewers-cntrb-idx1', 'pull_request_reviewers', ['cntrb_id'], unique=False)
    op.create_table('repo_test_coverage',
    sa.Column('repo_id', sa.BIGINT(), server_default=sa.text("nextval('repo_test_coverage_repo_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_clone_date', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.Column('rtc_analysis_date', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.Column('programming_language', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('file_path', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('file_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('testing_tool', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('file_statement_count', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('file_subroutine_count', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('file_statements_tested', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('file_subroutines_tested', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_repo_test_coverage_repo_1'),
    sa.PrimaryKeyConstraint('repo_id', name='repo_test_coverage_pkey')
    )
    op.create_table('library_version',
    sa.Column('library_version_id', sa.BIGINT(), server_default=sa.text("nextval('library_version_library_version_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('library_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('library_platform', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('version_number', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('version_release_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('NULL::timestamp without time zone'), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['library_id'], ['libraries.library_id'], name='fk_library_version_libraries_1'),
    sa.PrimaryKeyConstraint('library_version_id', name='library_version_pkey')
    )
    op.create_table('lstm_anomaly_results',
    sa.Column('result_id', sa.BIGINT(), server_default=sa.text("nextval('lstm_anomaly_results_result_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('repo_category', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('model_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('metric', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('contamination_factor', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('mean_absolute_error', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('remarks', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('metric_field', sa.VARCHAR(), autoincrement=False, nullable=True, comment='This is a listing of all of the endpoint fields included in the generation of the metric. Sometimes there is one, sometimes there is more than one. This will list them all. '),
    sa.Column('mean_absolute_actual_value', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('mean_absolute_prediction_value', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=6), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['model_id'], ['lstm_anomaly_models.model_id'], name='fk_lstm_anomaly_results_lstm_anomaly_models_1'),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_lstm_anomaly_results_repo_1'),
    sa.PrimaryKeyConstraint('result_id', name='lstm_anomaly_results_pkey')
    )
    op.create_table('pull_request_events',
    sa.Column('pr_event_id', sa.BIGINT(), server_default=sa.text("nextval('pull_request_events_pr_event_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('pull_request_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('action', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('action_commit_hash', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=False),
    sa.Column('issue_event_src_id', sa.BIGINT(), autoincrement=False, nullable=True, comment='This ID comes from the source. In the case of GitHub, it is the id that is the first field returned from the issue events API'),
    sa.Column('node_id', sa.VARCHAR(), autoincrement=False, nullable=True, comment='This should be renamed to issue_event_src_node_id, as its the varchar identifier in GitHub and likely common in other sources as well. However, since it was created before we came to this naming standard and workers are built around it, we have it simply named as node_id. Anywhere you see node_id in the schema, it comes from GitHubs terminology.'),
    sa.Column('node_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('platform_id', sa.BIGINT(), server_default=sa.text('25150'), autoincrement=False, nullable=False),
    sa.Column('pr_platform_event_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('cntrb_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['cntrb_id'], ['contributors.cntrb_id'], name='pull_request_events_cntrb_id_fkey'),
    sa.ForeignKeyConstraint(['platform_id'], ['platform.pltfrm_id'], name='fkpr_platform', onupdate='RESTRICT', ondelete='RESTRICT', initially='DEFERRED', deferrable=True),
    sa.ForeignKeyConstraint(['pull_request_id'], ['pull_requests.pull_request_id'], name='fk_pull_request_events_pull_requests_1', onupdate='CASCADE', ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fkprevent_repo_id', onupdate='RESTRICT', ondelete='RESTRICT', initially='DEFERRED', deferrable=True),
    sa.PrimaryKeyConstraint('pr_event_id', name='pr_events_pkey'),
    sa.UniqueConstraint('node_id', name='pr-unqiue-event'),
    sa.UniqueConstraint('platform_id', 'node_id', name='unique-pr-event-id'),
    sa.UniqueConstraint('repo_id', 'issue_event_src_id', name='pr_events_repo_id_event_src_id_unique')
    )
    op.create_index('pr_events_ibfk_2', 'pull_request_events', ['cntrb_id'], unique=False)
    op.create_index('pr_events_ibfk_1', 'pull_request_events', ['pull_request_id'], unique=False)
    op.create_table('dm_repo_group_annual',
    sa.Column('repo_group_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('email', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('affiliation', sa.VARCHAR(), server_default=sa.text("'NULL'::character varying"), autoincrement=False, nullable=True),
    sa.Column('year', sa.SMALLINT(), autoincrement=False, nullable=False),
    sa.Column('added', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('removed', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('whitespace', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('files', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('patches', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True)
    )
    op.create_index('projects_id,email_copy_1', 'dm_repo_group_annual', ['repo_group_id', 'email'], unique=False)
    op.create_index('projects_id,affiliation_copy_1', 'dm_repo_group_annual', ['repo_group_id', 'affiliation'], unique=False)
    op.create_table('external_refs',
    sa.Column('external_ref_id', sa.INTEGER(), server_default=sa.text("nextval('external_refs_external_ref_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('document_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('document_namespace_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('id_string', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.Column('sha256', sa.VARCHAR(length=64), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['document_id'], ['documents.document_id'], name='external_refs_document_id_fkey'),
    sa.ForeignKeyConstraint(['document_namespace_id'], ['document_namespaces.document_namespace_id'], name='external_refs_document_namespace_id_fkey'),
    sa.PrimaryKeyConstraint('external_ref_id', name='external_refs_pkey'),
    sa.UniqueConstraint('document_id', 'id_string', name='uc_external_ref_document_id_string')
    )
    op.create_table('users',
    sa.Column('user_id', sa.INTEGER(), server_default=sa.text("nextval('users_user_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('login_name', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('login_hashword', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('email', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('text_phone', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('first_name', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('last_name', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('admin', sa.BOOLEAN(), autoincrement=False, nullable=False),
    sa.Column('email_verified', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('user_id', name='users_pkey'),
    sa.UniqueConstraint('email', name='user-unique-email'),
    sa.UniqueConstraint('login_name', name='user-unique-name'),
    sa.UniqueConstraint('text_phone', name='user-unique-phone'),
    postgresql_ignore_search_path=False
    )
    op.create_table('pull_request_commits',
    sa.Column('pr_cmt_id', sa.BIGINT(), server_default=sa.text("nextval('pull_request_commits_pr_cmt_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('pull_request_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_cmt_sha', sa.VARCHAR(), autoincrement=False, nullable=True, comment='This is the commit SHA for a pull request commit. If the PR is not to the master branch of the main repository (or, in rare cases, from it), then you will NOT find a corresponding commit SHA in the commit table. (see table comment for further explanation). '),
    sa.Column('pr_cmt_node_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_cmt_message', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_cmt_comments_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_cmt_timestamp', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.Column('pr_cmt_author_email', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('pr_cmt_author_cntrb_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['pr_cmt_author_cntrb_id'], ['contributors.cntrb_id'], name='pull_request_commits_pr_cmt_author_cntrb_id_fkey', onupdate='CASCADE', ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['pull_request_id'], ['pull_requests.pull_request_id'], name='fk_pull_request_commits_pull_requests_1', onupdate='CASCADE', ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_pull_request_commits_repo_id', onupdate='CASCADE', ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('pr_cmt_id', name='pull_request_commits_pkey'),
    sa.UniqueConstraint('pull_request_id', 'repo_id', 'pr_cmt_sha', name='pr_commit_nk'),
    comment='Pull request commits are an enumeration of each commit associated with a pull request. \nNot all pull requests are from a branch or fork into master. \nThe commits table intends to count only commits that end up in the master branch (i.e., part of the deployed code base for a project).\nTherefore, there will be commit “SHA”’s in this table that are no associated with a commit SHA in the commits table. \nIn cases where the PR is to the master branch of a project, you will find a match. In cases where the PR does not involve the master branch, you will not find a corresponding commit SHA in the commits table. This is expected. '
    )
    op.create_table('contributors_aliases',
    sa.Column('cntrb_alias_id', sa.BIGINT(), server_default=sa.text("nextval('contributors_aliases_cntrb_alias_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('canonical_email', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('alias_email', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('cntrb_active', sa.SMALLINT(), server_default=sa.text('1'), autoincrement=False, nullable=False),
    sa.Column('cntrb_last_modified', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('cntrb_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['cntrb_id'], ['contributors.cntrb_id'], name='contributors_aliases_cntrb_id_fkey', onupdate='CASCADE', ondelete='CASCADE', initially='DEFERRED', deferrable=True),
    sa.PrimaryKeyConstraint('cntrb_alias_id', name='contributors_aliases_pkey'),
    sa.UniqueConstraint('alias_email', name='contributor-alias-unique'),
    comment='Every open source user may have more than one email used to make contributions over time. Augur selects the first email it encounters for a user as its “canonical_email”. \n\nThe canonical_email is also added to the contributors_aliases table, with the canonical_email and alias_email being identical.  Using this strategy, an email search will only need to join the alias table for basic email information, and can then more easily map the canonical email from each alias row to the same, more detailed information in the contributors table for a user. '
    )
    op.create_table('repo_deps_libyear',
    sa.Column('repo_deps_libyear_id', sa.BIGINT(), server_default=sa.text("nextval('repo_deps_libyear_repo_deps_libyear_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('requirement', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('type', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('package_manager', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('current_verion', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('latest_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('current_release_date', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('latest_release_date', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('libyear', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='repo_id_copy_2'),
    sa.PrimaryKeyConstraint('repo_deps_libyear_id', name='repo_deps_libyear_pkey'),
    sa.UniqueConstraint('repo_id', 'name', 'data_collection_date', name='deps-libyear-insert-unique')
    )
    op.create_table('discourse_insights',
    sa.Column('msg_discourse_id', sa.BIGINT(), server_default=sa.text("nextval('discourse_insights_msg_discourse_id_seq1'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('msg_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('discourse_act', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(timezone=True, precision=6), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['msg_id'], ['message.msg_id'], name='fk_discourse_insights_message_1'),
    sa.PrimaryKeyConstraint('msg_discourse_id', name='discourse_insights_pkey'),
    comment='This table is populated by the “Discourse_Analysis_Worker”. It examines sequential discourse, using computational linguistic methods, to draw statistical inferences regarding the discourse in a particular comment thread. '
    )
    op.create_table('augur_settings',
    sa.Column('id', sa.BIGINT(), server_default=sa.text("nextval('augur_settings_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('setting', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('value', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('last_modified', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_DATE'), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('id', name='augur_settings_pkey'),
    comment='Augur settings include the schema version, and the Augur API Key as of 10/25/2020. Future augur settings may be stored in this table, which has the basic structure of a name-value pair. '
    )
    op.create_table('lstm_anomaly_models',
    sa.Column('model_id', sa.BIGINT(), server_default=sa.text("nextval('lstm_anomaly_models_model_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('model_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('model_description', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('look_back_days', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('training_days', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('batch_size', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('metric', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=6), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('model_id', name='lstm_anomaly_models_pkey')
    )
    op.create_table('creators',
    sa.Column('creator_id', sa.INTEGER(), server_default=sa.text("nextval('creators_creator_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('creator_type_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('name', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.Column('email', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['creator_type_id'], ['creator_types.creator_type_id'], name='creators_creator_type_id_fkey'),
    sa.PrimaryKeyConstraint('creator_id', name='creators_pkey'),
    postgresql_ignore_search_path=False
    )
    op.create_table('message_analysis',
    sa.Column('msg_analysis_id', sa.BIGINT(), server_default=sa.text("nextval('message_analysis_msg_analysis_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('msg_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('worker_run_id', sa.BIGINT(), autoincrement=False, nullable=True, comment='This column is used to indicate analyses run by a worker during the same execution period, and is useful for grouping, and time series analysis.  '),
    sa.Column('sentiment_score', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True, comment='A sentiment analysis score. Zero is neutral, negative numbers are negative sentiment, and positive numbers are positive sentiment. '),
    sa.Column('reconstruction_error', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True, comment='Each message is converted to a 250 dimensin doc2vec vector, so the reconstruction error is the difference between what the predicted vector and the actual vector.'),
    sa.Column('novelty_flag', sa.BOOLEAN(), autoincrement=False, nullable=True, comment='This is an analysis of the degree to which the message is novel when compared to other messages in a repository.  For example when bots are producing numerous identical messages, the novelty score is low. It would also be a low novelty score when several people are making the same coment. '),
    sa.Column('feedback_flag', sa.BOOLEAN(), autoincrement=False, nullable=True, comment='This exists to provide the user with an opportunity provide feedback on the resulting the sentiment scores. '),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['msg_id'], ['message.msg_id'], name='fk_message_analysis_message_1'),
    sa.PrimaryKeyConstraint('msg_analysis_id', name='message_analysis_pkey')
    )
    op.create_table('repo',
    sa.Column('repo_id', sa.BIGINT(), server_default=sa.text("nextval('repo_repo_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_group_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('repo_git', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('repo_path', sa.VARCHAR(), server_default=sa.text("'NULL'::character varying"), autoincrement=False, nullable=True),
    sa.Column('repo_name', sa.VARCHAR(), server_default=sa.text("'NULL'::character varying"), autoincrement=False, nullable=True),
    sa.Column('repo_added', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=False),
    sa.Column('repo_type', sa.VARCHAR(), server_default=sa.text("''::character varying"), autoincrement=False, nullable=True, comment='This field is intended to indicate if the repository is the "main instance" of a repository in cases where implementations choose to add the same repository to more than one repository group. In cases where the repository group is of rg_type Github Organization then this repo_type should be "primary". In other cases the repo_type should probably be "user created". We made this a varchar in order to hold open the possibility that there are additional repo_types we have not thought about. '),
    sa.Column('url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('owner_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('description', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('primary_language', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('created_at', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('forked_from', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.Column('repo_archived_date_collected', postgresql.TIMESTAMP(timezone=True, precision=0), autoincrement=False, nullable=True),
    sa.Column('repo_archived', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('repo_src_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_group_id'], ['repo_groups.repo_group_id'], name='fk_repo_repo_groups_1'),
    sa.PrimaryKeyConstraint('repo_id', name='repounique'),
    sa.UniqueConstraint('repo_git', name='repo_git-unique'),
    sa.UniqueConstraint('repo_src_id', name='repo_src_id_unique'),
    comment='This table is a combination of the columns in Facade’s repo table and GHTorrent’s projects table. ',
    postgresql_ignore_search_path=False
    )
    op.create_index('therepo', 'repo', ['repo_id'], unique=True)
    op.create_index('rggrouponrepoindex', 'repo', ['repo_group_id'], unique=False)
    op.create_index('reponameindexbtree', 'repo', ['repo_name'], unique=False)
    op.create_index('reponameindex', 'repo', ['repo_name'], unique=False, postgresql_using='hash')
    op.create_index('repogitindexrep', 'repo', ['repo_git'], unique=False)
    op.create_index('repo_idx_repo_id_repo_namex', 'repo', ['repo_id', 'repo_name'], unique=False)
    op.create_index('forked', 'repo', ['forked_from'], unique=False)
    op.create_table('creator_types',
    sa.Column('creator_type_id', sa.INTEGER(), server_default=sa.text("nextval('creator_types_creator_type_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('name', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('creator_type_id', name='creator_types_pkey'),
    postgresql_ignore_search_path=False
    )
    op.create_table('refresh_tokens',
    sa.Column('id', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('user_session_token', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['user_session_token'], ['user_session_tokens.token'], name='refresh_token_session_token_id_fkey'),
    sa.PrimaryKeyConstraint('id', name='refresh_tokens_pkey'),
    sa.UniqueConstraint('user_session_token', name='refresh_token_user_session_token_id_unique')
    )
    op.create_table('user_session_tokens',
    sa.Column('token', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('user_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('created_at', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('expiration', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('application_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['application_id'], ['client_applications.id'], name='user_session_token_application_id_fkey'),
    sa.ForeignKeyConstraint(['user_id'], ['users.user_id'], name='user_session_token_user_fk'),
    sa.PrimaryKeyConstraint('token', name='user_session_tokens_pkey')
    )
    op.create_table('document_namespaces',
    sa.Column('document_namespace_id', sa.INTEGER(), server_default=sa.text("nextval('document_namespaces_document_namespace_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('uri', sa.VARCHAR(length=500), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('document_namespace_id', name='document_namespaces_pkey'),
    sa.UniqueConstraint('uri', name='uc_document_namespace_uri'),
    postgresql_ignore_search_path=False
    )
    op.create_table('documents',
    sa.Column('document_id', sa.INTEGER(), server_default=sa.text("nextval('documents_document_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('document_namespace_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('data_license_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('spdx_version', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.Column('name', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.Column('license_list_version', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.Column('created_ts', postgresql.TIMESTAMP(timezone=True, precision=6), autoincrement=False, nullable=False),
    sa.Column('creator_comment', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('document_comment', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('package_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['data_license_id'], ['licenses.license_id'], name='documents_data_license_id_fkey'),
    sa.ForeignKeyConstraint(['document_namespace_id'], ['document_namespaces.document_namespace_id'], name='documents_document_namespace_id_fkey'),
    sa.ForeignKeyConstraint(['package_id'], ['packages.package_id'], name='documents_package_id_fkey'),
    sa.PrimaryKeyConstraint('document_id', name='documents_pkey'),
    sa.UniqueConstraint('document_namespace_id', name='uc_document_document_namespace_id'),
    postgresql_ignore_search_path=False
    )
    op.create_table('repos_fetch_log',
    sa.Column('repos_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('status', sa.VARCHAR(length=128), autoincrement=False, nullable=False),
    sa.Column('date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=False)
    )
    op.create_index('repos_id,statusops', 'repos_fetch_log', ['repos_id', 'status'], unique=False)
    op.create_index('repos_id,status', 'repos_fetch_log', ['repos_id', 'status'], unique=False)
    op.create_table('message_analysis_summary',
    sa.Column('msg_summary_id', sa.BIGINT(), server_default=sa.text("nextval('message_analysis_summary_msg_summary_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('worker_run_id', sa.BIGINT(), autoincrement=False, nullable=True, comment='This value should reflect the worker_run_id for the messages summarized in the table. There is not a relation between these two tables for that purpose because its not *really*, relationaly a concept unless we create a third table for "worker_run_id", which we determined was unnecessarily complex. '),
    sa.Column('positive_ratio', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('negative_ratio', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('novel_count', sa.BIGINT(), autoincrement=False, nullable=True, comment='The number of messages identified as novel during the analyzed period'),
    sa.Column('period', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True, comment='The whole timeline is divided into periods based on the definition of time period for analysis, which is user specified. Timestamp of the first period to look at, until the end of messages at the data of execution. '),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_message_analysis_summary_repo_1'),
    sa.PrimaryKeyConstraint('msg_summary_id', name='message_analysis_summary_pkey'),
    comment='In a relationally perfect world, we would have a table called “message_analysis_run” the incremented the “worker_run_id” for both message_analysis and message_analysis_summary. For now, we decided this was overkill. '
    )
    op.create_table('annotations',
    sa.Column('annotation_id', sa.INTEGER(), server_default=sa.text("nextval('annotations_annotation_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('document_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('annotation_type_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('identifier_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('creator_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('created_ts', postgresql.TIMESTAMP(timezone=True, precision=6), autoincrement=False, nullable=True),
    sa.Column('comment', sa.TEXT(), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['annotation_type_id'], ['annotation_types.annotation_type_id'], name='annotations_annotation_type_id_fkey'),
    sa.ForeignKeyConstraint(['creator_id'], ['creators.creator_id'], name='annotations_creator_id_fkey'),
    sa.ForeignKeyConstraint(['document_id'], ['documents.document_id'], name='annotations_document_id_fkey'),
    sa.ForeignKeyConstraint(['identifier_id'], ['identifiers.identifier_id'], name='annotations_identifier_id_fkey'),
    sa.PrimaryKeyConstraint('annotation_id', name='annotations_pkey')
    )
    op.create_table('pull_request_repo',
    sa.Column('pr_repo_id', sa.BIGINT(), server_default=sa.text("nextval('pull_request_repo_pr_repo_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('pr_repo_meta_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_repo_head_or_base', sa.VARCHAR(), autoincrement=False, nullable=True, comment='For ease of validation checking, we should determine if the repository referenced is the head or base of the pull request. Each pull request should have one and only one of these, which is not enforcable easily in the database.'),
    sa.Column('pr_src_repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_src_node_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_repo_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_repo_full_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_repo_private_bool', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('pr_cntrb_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['pr_cntrb_id'], ['contributors.cntrb_id'], name='pull_request_repo_pr_cntrb_id_fkey'),
    sa.ForeignKeyConstraint(['pr_repo_meta_id'], ['pull_request_meta.pr_repo_meta_id'], name='fk_pull_request_repo_pull_request_meta_1', onupdate='CASCADE', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('pr_repo_id', name='pull_request_repo_pkey'),
    comment='This table is for storing information about forks that exist as part of a pull request. Generally we do not want to track these like ordinary repositories. '
    )
    op.create_index('pr-cntrb-idx-repo', 'pull_request_repo', ['pr_cntrb_id'], unique=False)
    op.create_table('message_sentiment_summary',
    sa.Column('msg_summary_id', sa.BIGINT(), server_default=sa.text("nextval('message_sentiment_summary_msg_summary_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('worker_run_id', sa.BIGINT(), autoincrement=False, nullable=True, comment='This value should reflect the worker_run_id for the messages summarized in the table. There is not a relation between these two tables for that purpose because its not *really*, relationaly a concept unless we create a third table for "worker_run_id", which we determined was unnecessarily complex. '),
    sa.Column('positive_ratio', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('negative_ratio', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('novel_count', sa.BIGINT(), autoincrement=False, nullable=True, comment='The number of messages identified as novel during the analyzed period'),
    sa.Column('period', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True, comment='The whole timeline is divided into periods based on the definition of time period for analysis, which is user specified. Timestamp of the first period to look at, until the end of messages at the data of execution. '),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_message_sentiment_summary_repo_1'),
    sa.PrimaryKeyConstraint('msg_summary_id', name='message_sentiment_summary_pkey'),
    comment='In a relationally perfect world, we would have a table called “message_sentiment_run” the incremented the “worker_run_id” for both message_sentiment and message_sentiment_summary. For now, we decided this was overkill. '
    )
    op.create_table('collection_status',
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('core_data_last_collected', postgresql.TIMESTAMP(), autoincrement=False, nullable=True),
    sa.Column('core_status', sa.VARCHAR(), server_default=sa.text("'Pending'::character varying"), autoincrement=False, nullable=False),
    sa.Column('core_task_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('secondary_data_last_collected', postgresql.TIMESTAMP(), autoincrement=False, nullable=True),
    sa.Column('secondary_status', sa.VARCHAR(), server_default=sa.text("'Pending'::character varying"), autoincrement=False, nullable=False),
    sa.Column('secondary_task_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('event_last_collected', postgresql.TIMESTAMP(), autoincrement=False, nullable=True),
    sa.Column('facade_status', sa.VARCHAR(), server_default=sa.text("'Pending'::character varying"), autoincrement=False, nullable=False),
    sa.Column('facade_data_last_collected', postgresql.TIMESTAMP(), autoincrement=False, nullable=True),
    sa.Column('facade_task_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('core_weight', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('facade_weight', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('secondary_weight', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('issue_pr_sum', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('commit_sum', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('ml_status', sa.VARCHAR(), server_default=sa.text("'Pending'::character varying"), autoincrement=False, nullable=False),
    sa.Column('ml_data_last_collected', postgresql.TIMESTAMP(), autoincrement=False, nullable=True),
    sa.Column('ml_task_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('ml_weight', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.CheckConstraint("NOT (core_data_last_collected IS NULL AND core_status::text = 'Success'::text) AND NOT (core_data_last_collected IS NOT NULL AND core_status::text = 'Pending'::text)", name='core_data_last_collected_check'),
    sa.CheckConstraint("NOT (core_status::text = 'Pending'::text AND secondary_status::text = 'Collecting'::text)", name='core_secondary_dependency_check'),
    sa.CheckConstraint("NOT (core_task_id IS NOT NULL AND (core_status::text = ANY (ARRAY['Pending'::character varying, 'Success'::character varying, 'Error'::character varying]::text[]))) AND NOT (core_task_id IS NULL AND core_status::text = 'Collecting'::text)", name='core_task_id_check'),
    sa.CheckConstraint("NOT (facade_data_last_collected IS NULL AND facade_status::text = 'Success'::text) AND NOT (facade_data_last_collected IS NOT NULL AND (facade_status::text = ANY (ARRAY['Pending'::character varying, 'Initializing'::character varying, 'Update'::character varying]::text[])))", name='facade_data_last_collected_check'),
    sa.CheckConstraint("NOT (facade_task_id IS NOT NULL AND (facade_status::text = ANY (ARRAY['Pending'::character varying, 'Success'::character varying, 'Error'::character varying, 'Failed Clone'::character varying, 'Initializing'::character varying]::text[]))) AND NOT (facade_task_id IS NULL AND facade_status::text = 'Collecting'::text)", name='facade_task_id_check'),
    sa.CheckConstraint("NOT (secondary_data_last_collected IS NULL AND secondary_status::text = 'Success'::text) AND NOT (secondary_data_last_collected IS NOT NULL AND secondary_status::text = 'Pending'::text)", name='secondary_data_last_collected_check'),
    sa.CheckConstraint("NOT (secondary_task_id IS NOT NULL AND (secondary_status::text = ANY (ARRAY['Pending'::character varying, 'Success'::character varying, 'Error'::character varying]::text[]))) AND NOT (secondary_task_id IS NULL AND secondary_status::text = 'Collecting'::text)", name='secondary_task_id_check'),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='collection_status_repo_id_fk'),
    sa.PrimaryKeyConstraint('repo_id', name='collection_status_pkey')
    )
    op.create_table('pull_request_analysis',
    sa.Column('pull_request_analysis_id', sa.BIGINT(), server_default=sa.text("nextval('pull_request_analysis_pull_request_analysis_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('pull_request_id', sa.BIGINT(), autoincrement=False, nullable=True, comment='It would be better if the pull request worker is run first to fetch the latest PRs before analyzing'),
    sa.Column('merge_probability', sa.NUMERIC(precision=256, scale=250), autoincrement=False, nullable=True, comment='Indicates the probability of the PR being merged'),
    sa.Column('mechanism', sa.VARCHAR(), autoincrement=False, nullable=True, comment='the ML model used for prediction (It is XGBoost Classifier at present)'),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(timezone=True, precision=6), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['pull_request_id'], ['pull_requests.pull_request_id'], name='fk_pull_request_analysis_pull_requests_1', onupdate='CASCADE', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('pull_request_analysis_id', name='pull_request_analysis_pkey')
    )
    op.create_index('probability_idx', 'pull_request_analysis', [sa.literal_column('merge_probability DESC NULLS LAST')], unique=False)
    op.create_index('pr_anal_idx', 'pull_request_analysis', ['pull_request_id'], unique=False)
    op.create_table('pull_request_review_message_ref',
    sa.Column('pr_review_msg_ref_id', sa.BIGINT(), server_default=sa.text("nextval('pull_request_review_message_ref_pr_review_msg_ref_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('pr_review_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('msg_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('pr_review_msg_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_review_src_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_review_msg_src_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_review_msg_node_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_review_msg_diff_hunk', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_review_msg_path', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_review_msg_position', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_review_msg_original_position', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_review_msg_commit_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_review_msg_original_commit_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_review_msg_updated_at', postgresql.TIMESTAMP(precision=6), autoincrement=False, nullable=True),
    sa.Column('pr_review_msg_html_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_review_msg_author_association', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_review_msg_start_line', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_review_msg_original_start_line', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_review_msg_start_side', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_review_msg_line', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_review_msg_original_line', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_review_msg_side', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['msg_id'], ['message.msg_id'], name='fk_pull_request_review_message_ref_message_1', onupdate='CASCADE', ondelete='RESTRICT', initially='DEFERRED', deferrable=True),
    sa.ForeignKeyConstraint(['pr_review_id'], ['pull_request_reviews.pr_review_id'], name='fk_pull_request_review_message_ref_pull_request_reviews_1', onupdate='CASCADE', ondelete='RESTRICT', initially='DEFERRED', deferrable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_review_repo', onupdate='CASCADE', ondelete='RESTRICT', initially='DEFERRED', deferrable=True),
    sa.PrimaryKeyConstraint('pr_review_msg_ref_id', name='pr_review_msg_ref_id'),
    sa.UniqueConstraint('pr_review_msg_src_id', name='pull-request-review-message-ref-insert-unique')
    )
    op.create_table('commit_messages',
    sa.Column('cmt_msg_id', sa.BIGINT(), server_default=sa.text("nextval('commits_cmt_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('cmt_msg', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('cmt_hash', sa.VARCHAR(length=80), autoincrement=False, nullable=False),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='commit_messages_repo_id_fkey', onupdate='CASCADE', ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('cmt_msg_id', name='commit_messages_pkey'),
    sa.UniqueConstraint('repo_id', 'cmt_hash', name='commit-message-insert-unique'),
    comment='This table holds commit messages'
    )
    op.create_table('pull_request_labels',
    sa.Column('pr_label_id', sa.BIGINT(), server_default=sa.text("nextval('pull_request_labels_pr_label_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('pull_request_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_src_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_src_node_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_src_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_src_description', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_src_color', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('pr_src_default_bool', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['pull_request_id'], ['pull_requests.pull_request_id'], name='fk_pull_request_labels_pull_requests_1', onupdate='CASCADE', ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_pull_request_labels_repo', onupdate='CASCADE', ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('pr_label_id', name='pull_request_labels_pkey'),
    sa.UniqueConstraint('pr_src_id', 'pull_request_id', name='unique-pr-src-label-id')
    )
    op.create_table('contributors',
    sa.Column('cntrb_login', sa.VARCHAR(), autoincrement=False, nullable=True, comment='Will be a double population with the same value as gh_login for github, but the local value for other systems. '),
    sa.Column('cntrb_email', sa.VARCHAR(), autoincrement=False, nullable=True, comment='This needs to be here for matching contributor ids, which are augur, to the commit information. '),
    sa.Column('cntrb_full_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('cntrb_company', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('cntrb_created_at', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.Column('cntrb_type', sa.VARCHAR(), autoincrement=False, nullable=True, comment='Present in another models. It is not currently used in Augur. '),
    sa.Column('cntrb_fake', sa.SMALLINT(), server_default=sa.text('0'), autoincrement=False, nullable=True),
    sa.Column('cntrb_deleted', sa.SMALLINT(), server_default=sa.text('0'), autoincrement=False, nullable=True),
    sa.Column('cntrb_long', sa.NUMERIC(precision=11, scale=8), server_default=sa.text('NULL::numeric'), autoincrement=False, nullable=True),
    sa.Column('cntrb_lat', sa.NUMERIC(precision=10, scale=8), server_default=sa.text('NULL::numeric'), autoincrement=False, nullable=True),
    sa.Column('cntrb_country_code', sa.CHAR(length=3), server_default=sa.text('NULL::bpchar'), autoincrement=False, nullable=True),
    sa.Column('cntrb_state', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('cntrb_city', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('cntrb_location', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('cntrb_canonical', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('cntrb_last_used', postgresql.TIMESTAMP(timezone=True, precision=0), server_default=sa.text('NULL::timestamp with time zone'), autoincrement=False, nullable=True),
    sa.Column('gh_user_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('gh_login', sa.VARCHAR(), autoincrement=False, nullable=True, comment='populated with the github user name for github originated data. '),
    sa.Column('gh_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('gh_html_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('gh_node_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('gh_avatar_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('gh_gravatar_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('gh_followers_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('gh_following_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('gh_gists_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('gh_starred_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('gh_subscriptions_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('gh_organizations_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('gh_repos_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('gh_events_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('gh_received_events_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('gh_type', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('gh_site_admin', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('gl_web_url', sa.VARCHAR(), autoincrement=False, nullable=True, comment='“web_url” value from these API calls to GitLab, all for the same user\n\nhttps://gitlab.com/api/v4/users?username=computationalmystic\nhttps://gitlab.com/api/v4/users?search=s@goggins.com\nhttps://gitlab.com/api/v4/users?search=outdoors@acm.org\n\n[\n  {\n    "id": 5481034,\n    "name": "sean goggins",\n    "username": "computationalmystic",\n    "state": "active",\n    "avatar_url": "https://secure.gravatar.com/avatar/fb1fb43953a6059df2fe8d94b21d575c?s=80&d=identicon",\n    "web_url": "https://gitlab.com/computationalmystic"\n  }\n]'),
    sa.Column('gl_avatar_url', sa.VARCHAR(), autoincrement=False, nullable=True, comment='“avatar_url” value from these API calls to GitLab, all for the same user\n\nhttps://gitlab.com/api/v4/users?username=computationalmystic\nhttps://gitlab.com/api/v4/users?search=s@goggins.com\nhttps://gitlab.com/api/v4/users?search=outdoors@acm.org\n\n[\n  {\n    "id": 5481034,\n    "name": "sean goggins",\n    "username": "computationalmystic",\n    "state": "active",\n    "avatar_url": "https://secure.gravatar.com/avatar/fb1fb43953a6059df2fe8d94b21d575c?s=80&d=identicon",\n    "web_url": "https://gitlab.com/computationalmystic"\n  }\n]'),
    sa.Column('gl_state', sa.VARCHAR(), autoincrement=False, nullable=True, comment='“state” value from these API calls to GitLab, all for the same user\n\nhttps://gitlab.com/api/v4/users?username=computationalmystic\nhttps://gitlab.com/api/v4/users?search=s@goggins.com\nhttps://gitlab.com/api/v4/users?search=outdoors@acm.org\n\n[\n  {\n    "id": 5481034,\n    "name": "sean goggins",\n    "username": "computationalmystic",\n    "state": "active",\n    "avatar_url": "https://secure.gravatar.com/avatar/fb1fb43953a6059df2fe8d94b21d575c?s=80&d=identicon",\n    "web_url": "https://gitlab.com/computationalmystic"\n  }\n]'),
    sa.Column('gl_username', sa.VARCHAR(), autoincrement=False, nullable=True, comment='“username” value from these API calls to GitLab, all for the same user\n\nhttps://gitlab.com/api/v4/users?username=computationalmystic\nhttps://gitlab.com/api/v4/users?search=s@goggins.com\nhttps://gitlab.com/api/v4/users?search=outdoors@acm.org\n\n[\n  {\n    "id": 5481034,\n    "name": "sean goggins",\n    "username": "computationalmystic",\n    "state": "active",\n    "avatar_url": "https://secure.gravatar.com/avatar/fb1fb43953a6059df2fe8d94b21d575c?s=80&d=identicon",\n    "web_url": "https://gitlab.com/computationalmystic"\n  }\n]'),
    sa.Column('gl_full_name', sa.VARCHAR(), autoincrement=False, nullable=True, comment='“name” value from these API calls to GitLab, all for the same user\n\nhttps://gitlab.com/api/v4/users?username=computationalmystic\nhttps://gitlab.com/api/v4/users?search=s@goggins.com\nhttps://gitlab.com/api/v4/users?search=outdoors@acm.org\n\n[\n  {\n    "id": 5481034,\n    "name": "sean goggins",\n    "username": "computationalmystic",\n    "state": "active",\n    "avatar_url": "https://secure.gravatar.com/avatar/fb1fb43953a6059df2fe8d94b21d575c?s=80&d=identicon",\n    "web_url": "https://gitlab.com/computationalmystic"\n  }\n]'),
    sa.Column('gl_id', sa.BIGINT(), autoincrement=False, nullable=True, comment='"id" value from these API calls to GitLab, all for the same user\n\nhttps://gitlab.com/api/v4/users?username=computationalmystic\nhttps://gitlab.com/api/v4/users?search=s@goggins.com\nhttps://gitlab.com/api/v4/users?search=outdoors@acm.org\n\n[\n  {\n    "id": 5481034,\n    "name": "sean goggins",\n    "username": "computationalmystic",\n    "state": "active",\n    "avatar_url": "https://secure.gravatar.com/avatar/fb1fb43953a6059df2fe8d94b21d575c?s=80&d=identicon",\n    "web_url": "https://gitlab.com/computationalmystic"\n  }\n]'),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('cntrb_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('cntrb_id', name='contributors-pk'),
    sa.UniqueConstraint('gl_id', name='GL-UNIQUE-B'),
    sa.UniqueConstraint('gl_username', name='GL-UNIQUE-C'),
    comment='For GitHub, this should be repeated from gh_login. for other systems, it should be that systems login. \nGithub now allows a user to change their login name, but their user id remains the same in this case. So, the natural key is the combination of id and login, but there should never be repeated logins. ',
    postgresql_ignore_search_path=False
    )
    op.create_index('login-contributor-idx', 'contributors', ['cntrb_login'], unique=False)
    op.create_index('login', 'contributors', ['cntrb_login'], unique=False)
    op.create_index('gh_login', 'contributors', [sa.literal_column('gh_login NULLS FIRST')], unique=False)
    op.create_index('contributors_idx_cntrb_email3', 'contributors', ['cntrb_email'], unique=False)
    op.create_index('contributor_worker_fullname_finder', 'contributors', ['cntrb_full_name'], unique=False, postgresql_using='brin')
    op.create_index('contributor_worker_email_finder', 'contributors', ['cntrb_email'], unique=False, postgresql_using='brin')
    op.create_index('cntrb_login_platform_index', 'contributors', ['cntrb_login'], unique=False)
    op.create_index('cntrb_canonica-idx11', 'contributors', ['cntrb_canonical'], unique=False)
    op.create_index('cntrb-theemail', 'contributors', ['cntrb_email'], unique=False, postgresql_using='hash')
    op.create_index('cnt-fullname', 'contributors', ['cntrb_full_name'], unique=False, postgresql_using='hash')
    op.create_table('commits',
    sa.Column('cmt_id', sa.BIGINT(), server_default=sa.text("nextval('commits_cmt_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('cmt_commit_hash', sa.VARCHAR(length=80), autoincrement=False, nullable=False),
    sa.Column('cmt_author_name', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('cmt_author_raw_email', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('cmt_author_email', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('cmt_author_date', sa.VARCHAR(length=10), autoincrement=False, nullable=False),
    sa.Column('cmt_author_affiliation', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('cmt_committer_name', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('cmt_committer_raw_email', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('cmt_committer_email', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('cmt_committer_date', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('cmt_committer_affiliation', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('cmt_added', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('cmt_removed', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('cmt_whitespace', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('cmt_filename', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('cmt_date_attempted', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=False),
    sa.Column('cmt_ght_committer_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('cmt_ght_committed_at', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.Column('cmt_committer_timestamp', postgresql.TIMESTAMP(timezone=True, precision=0), autoincrement=False, nullable=True),
    sa.Column('cmt_author_timestamp', postgresql.TIMESTAMP(timezone=True, precision=0), autoincrement=False, nullable=True),
    sa.Column('cmt_author_platform_username', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('cmt_ght_author_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['cmt_ght_author_id'], ['contributors.cntrb_id'], name='cmt_ght_author_cntrb_id_fk', onupdate='CASCADE', ondelete='RESTRICT', initially='DEFERRED', deferrable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_commits_repo_2', onupdate='CASCADE', ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('cmt_id', name='commits_pkey'),
    comment='Commits.\nEach row represents changes to one FILE within a single commit. So you will encounter multiple rows per commit hash in many cases. ',
    postgresql_ignore_search_path=False
    )
    op.create_index('repo_id,commit', 'commits', ['repo_id', 'cmt_commit_hash'], unique=False)
    op.create_index('committer_raw_email', 'commits', ['cmt_committer_raw_email'], unique=False)
    op.create_index('committer_affiliation', 'commits', ['cmt_committer_affiliation'], unique=False)
    op.create_index('commits_idx_cmt_email_cmt_date_cmt_name', 'commits', ['cmt_author_email', 'cmt_author_date', 'cmt_author_name'], unique=False)
    op.create_index('commited', 'commits', ['cmt_id'], unique=False)
    op.create_index('author_raw_email', 'commits', ['cmt_author_raw_email'], unique=False)
    op.create_index('author_email,author_affiliation,author_date', 'commits', ['cmt_author_email', 'cmt_author_affiliation', 'cmt_author_date'], unique=False)
    op.create_index('author_cntrb_id', 'commits', ['cmt_ght_author_id'], unique=False)
    op.create_index('author_affiliation', 'commits', ['cmt_author_affiliation'], unique=False)
    op.create_table('repo_groups',
    sa.Column('repo_group_id', sa.BIGINT(), server_default=sa.text("nextval('repo_groups_repo_group_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('rg_name', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('rg_description', sa.VARCHAR(), server_default=sa.text("'NULL'::character varying"), autoincrement=False, nullable=True),
    sa.Column('rg_website', sa.VARCHAR(length=128), server_default=sa.text("'NULL'::character varying"), autoincrement=False, nullable=True),
    sa.Column('rg_recache', sa.SMALLINT(), server_default=sa.text('1'), autoincrement=False, nullable=True),
    sa.Column('rg_last_modified', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=False),
    sa.Column('rg_type', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('repo_group_id', name='rgid'),
    comment='rg_type is intended to be either a GitHub Organization or a User Created Repo Group. ',
    postgresql_ignore_search_path=False
    )
    op.create_index('rgnameindex', 'repo_groups', ['rg_name'], unique=False)
    op.create_index('rgidm', 'repo_groups', ['repo_group_id'], unique=True)
    op.create_table('files',
    sa.Column('file_id', sa.INTEGER(), server_default=sa.text("nextval('files_file_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('file_type_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('sha256', sa.VARCHAR(length=64), autoincrement=False, nullable=False),
    sa.Column('copyright_text', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('package_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('comment', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('notice', sa.TEXT(), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('file_id', name='files_pkey'),
    sa.UniqueConstraint('sha256', name='uc_file_sha256'),
    postgresql_ignore_search_path=False
    )
    op.create_table('repo_insights',
    sa.Column('ri_id', sa.BIGINT(), server_default=sa.text("nextval('repo_insights_ri_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('ri_metric', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('ri_value', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('ri_date', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.Column('ri_fresh', sa.BOOLEAN(), autoincrement=False, nullable=True, comment='false if the date is before the statistic that triggered the insight, true if after. This allows us to automatically display only "fresh insights" and avoid displaying "stale insights". The insight worker will populate this table. '),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('ri_score', sa.NUMERIC(), autoincrement=False, nullable=True),
    sa.Column('ri_field', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('ri_detection_method', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_repo_insights_repo_1'),
    sa.PrimaryKeyConstraint('ri_id', name='repo_insights_pkey'),
    comment='This table is output from an analytical worker inside of Augur. It runs through the different metrics on a repository and identifies the five to ten most “interesting” metrics as defined by some kind of delta or other factor. The algorithm is going to evolve. \n\nWorker Design Notes: The idea is that the "insight worker" will scan through a bunch of active metrics or "synthetic metrics" to list the most important insights. '
    )
    op.create_table('commit_comment_ref',
    sa.Column('cmt_comment_id', sa.BIGINT(), server_default=sa.text("nextval('commit_comment_ref_cmt_comment_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('cmt_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('msg_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('user_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('body', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('line', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('position', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('commit_comment_src_node_id', sa.VARCHAR(), autoincrement=False, nullable=True, comment='For data provenance, we store the source node ID if it exists. '),
    sa.Column('cmt_comment_src_id', sa.BIGINT(), autoincrement=False, nullable=False, comment='For data provenance, we store the source ID if it exists. '),
    sa.Column('created_at', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=False),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['cmt_id'], ['commits.cmt_id'], name='fk_commit_comment_ref_commits_1', onupdate='CASCADE', ondelete='RESTRICT'),
    sa.ForeignKeyConstraint(['msg_id'], ['message.msg_id'], name='fk_commit_comment_ref_message_1', onupdate='CASCADE', ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('cmt_comment_id', name='commit_comment_ref_pkey'),
    sa.UniqueConstraint('cmt_comment_src_id', name='commitcomment')
    )
    op.create_index('comment_id', 'commit_comment_ref', ['cmt_comment_src_id', 'cmt_comment_id', 'msg_id'], unique=False)
    op.create_table('annotation_types',
    sa.Column('annotation_type_id', sa.INTEGER(), server_default=sa.text("nextval('annotation_types_annotation_type_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('name', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('annotation_type_id', name='annotation_types_pkey'),
    sa.UniqueConstraint('name', name='uc_annotation_type_name')
    )
    op.create_table('dm_repo_annual',
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('email', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('affiliation', sa.VARCHAR(), server_default=sa.text("'NULL'::character varying"), autoincrement=False, nullable=True),
    sa.Column('year', sa.SMALLINT(), autoincrement=False, nullable=False),
    sa.Column('added', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('removed', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('whitespace', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('files', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('patches', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True)
    )
    op.create_index('repo_id,email_copy_1', 'dm_repo_annual', ['repo_id', 'email'], unique=False)
    op.create_index('repo_id,affiliation_copy_1', 'dm_repo_annual', ['repo_id', 'affiliation'], unique=False)
    op.create_table('issue_labels',
    sa.Column('issue_label_id', sa.BIGINT(), server_default=sa.text("nextval('issue_labels_issue_label_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('issue_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('label_text', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('label_description', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('label_color', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('label_src_id', sa.BIGINT(), autoincrement=False, nullable=True, comment='This character based identifier (node) comes from the source. In the case of GitHub, it is the id that is the second field returned from the issue events API JSON subsection for issues.'),
    sa.Column('label_src_node_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['issue_id'], ['issues.issue_id'], name='fk_issue_labels_issues_1', onupdate='CASCADE', ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_issue_labels_repo_id', onupdate='CASCADE', ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('issue_label_id', name='issue_labels_pkey'),
    sa.UniqueConstraint('label_src_id', 'issue_id', name='unique_issue_label')
    )
    op.create_table('commit_parents',
    sa.Column('cmt_id', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('parent_id', sa.BIGINT(), server_default=sa.text("nextval('commit_parents_parent_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['cmt_id'], ['commits.cmt_id'], name='fk_commit_parents_commits_1'),
    sa.ForeignKeyConstraint(['parent_id'], ['commits.cmt_id'], name='fk_commit_parents_commits_2'),
    sa.PrimaryKeyConstraint('cmt_id', 'parent_id', name='commit_parents_pkey')
    )
    op.create_index('commit_parents_ibfk_2', 'commit_parents', ['parent_id'], unique=False)
    op.create_index('commit_parents_ibfk_1', 'commit_parents', ['cmt_id'], unique=False)
    op.create_table('files_licenses',
    sa.Column('file_license_id', sa.INTEGER(), server_default=sa.text("nextval('files_licenses_file_license_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('file_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('license_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('extracted_text', sa.TEXT(), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['file_id'], ['files.file_id'], name='files_licenses_file_id_fkey'),
    sa.ForeignKeyConstraint(['license_id'], ['licenses.license_id'], name='files_licenses_license_id_fkey'),
    sa.PrimaryKeyConstraint('file_license_id', name='files_licenses_pkey'),
    sa.UniqueConstraint('file_id', 'license_id', name='uc_file_license')
    )
    op.create_table('pull_request_assignees',
    sa.Column('pr_assignee_map_id', sa.BIGINT(), server_default=sa.text("nextval('pull_request_assignees_pr_assignee_map_id_seq'::regclass)"), autoincrement=True, nullable=False),
    sa.Column('pull_request_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('repo_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('pr_assignee_src_id', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('tool_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('tool_version', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_source', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('data_collection_date', postgresql.TIMESTAMP(precision=0), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.Column('contrib_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['contrib_id'], ['contributors.cntrb_id'], name='pull_request_assignees_contrib_id_fkey'),
    sa.ForeignKeyConstraint(['pull_request_id'], ['pull_requests.pull_request_id'], name='fk_pull_request_assignees_pull_requests_1', onupdate='CASCADE', ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['repo_id'], ['repo.repo_id'], name='fk_pull_request_assignees_repo_id', onupdate='CASCADE', ondelete='RESTRICT', initially='DEFERRED', deferrable=True),
    sa.PrimaryKeyConstraint('pr_assignee_map_id', name='pull_request_assignees_pkey'),
    sa.UniqueConstraint('pull_request_id', 'pr_assignee_src_id', name='assigniees-unique')
    )
    op.create_index('pr_meta_cntrb-idx', 'pull_request_assignees', ['contrib_id'], unique=False)
    #op.drop_table('documents_creators', schema='spdx')
    #op.drop_table('repo_badging', schema='augur_data')
    #op.drop_index('projects_id,year,email_copy_1', table_name='dm_repo_group_monthly', schema='augur_data')
    #op.drop_index('projects_id,year,affiliation_copy_1', table_name='dm_repo_group_monthly', schema='augur_data')
    #op.drop_index('projects_id,email_copy_2', table_name='dm_repo_group_monthly', schema='augur_data')
    #op.drop_index('projects_id,affiliation_copy_2', table_name='dm_repo_group_monthly', schema='augur_data')
    #op.drop_table('dm_repo_group_monthly', schema='augur_data')
    #op.drop_index('repos_id', table_name='analysis_log', schema='augur_data')
    #op.drop_table('analysis_log', schema='augur_data')
    # ### end Alembic commands ###

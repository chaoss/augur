#!/usr/bin/env node

/*
  @license
	Rollup.js v2.10.9
	Sun, 24 May 2020 05:27:58 GMT - commit 462bff7b1a0c384ecc3e278b1ea877e637c70f41


	https://github.com/rollup/rollup

	Released under the MIT License.
*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var rollup_js = require('../shared/rollup.js');
var path = require('path');
var util = require('util');
var mergeOptions = require('../shared/mergeOptions.js');
var loadConfigFile_js = require('../shared/loadConfigFile.js');
require('crypto');
var fs = require('fs');
require('events');
var module$1 = require('module');
require('url');

var help = "rollup version __VERSION__\n=====================================\n\nUsage: rollup [options] <entry file>\n\nBasic options:\n\n-c, --config <filename>     Use this config file (if argument is used but value\n                              is unspecified, defaults to rollup.config.js)\n-d, --dir <dirname>         Directory for chunks (if absent, prints to stdout)\n-e, --external <ids>        Comma-separate list of module IDs to exclude\n-f, --format <format>       Type of output (amd, cjs, es, iife, umd, system)\n-g, --globals <pairs>       Comma-separate list of `moduleID:Global` pairs\n-h, --help                  Show this help message\n-i, --input <filename>      Input (alternative to <entry file>)\n-m, --sourcemap             Generate sourcemap (`-m inline` for inline map)\n-n, --name <name>           Name for UMD export\n-o, --file <output>         Single output file (if absent, prints to stdout)\n-p, --plugin <plugin>       Use the plugin specified (may be repeated)\n-v, --version               Show version number\n-w, --watch                 Watch files in bundle and rebuild on changes\n--amd.id <id>               ID for AMD module (default is anonymous)\n--amd.define <name>         Function to use in place of `define`\n--assetFileNames <pattern>  Name pattern for emitted assets\n--banner <text>             Code to insert at top of bundle (outside wrapper)\n--chunkFileNames <pattern>  Name pattern for emitted secondary chunks\n--compact                   Minify wrapper code\n--context <variable>        Specify top-level `this` value\n--entryFileNames <pattern>  Name pattern for emitted entry chunks\n--environment <values>      Settings passed to config file (see example)\n--no-esModule               Do not add __esModule property\n--exports <mode>            Specify export mode (auto, default, named, none)\n--extend                    Extend global variable defined by --name\n--no-externalLiveBindings   Do not generate code to support live bindings\n--footer <text>             Code to insert at end of bundle (outside wrapper)\n--no-freeze                 Do not freeze namespace objects\n--no-hoistTransitiveImports Do not hoist transitive imports into entry chunks\n--no-indent                 Don't indent result\n--no-interop                Do not include interop block\n--inlineDynamicImports      Create single bundle when using dynamic imports\n--intro <text>              Code to insert at top of bundle (inside wrapper)\n--minifyInternalExports     Force or disable minification of internal exports\n--namespaceToStringTag      Create proper `.toString` methods for namespaces\n--noConflict                Generate a noConflict method for UMD globals\n--outro <text>              Code to insert at end of bundle (inside wrapper)\n--preferConst               Use `const` instead of `var` for exports\n--no-preserveEntrySignatures Avoid facade chunks for entry points\n--preserveModules           Preserve module structure\n--preserveSymlinks          Do not follow symlinks when resolving files\n--shimMissingExports        Create shim variables for missing exports\n--silent                    Don't print warnings\n--sourcemapExcludeSources   Do not include source code in source maps\n--sourcemapFile <file>      Specify bundle position for source maps\n--no-stdin                  do not read \"-\" from stdin\n--no-strict                 Don't emit `\"use strict\";` in the generated modules\n--strictDeprecations        Throw errors for deprecated features\n--no-treeshake              Disable tree-shaking optimisations\n--no-treeshake.annotations  Ignore pure call annotations\n--no-treeshake.no-moduleSideEffects Assume modules have no side-effects\n--no-treeshake.no-propertyReadSideEffects Ignore property access side-effects\n--no-treeshake.no-tryCatchDeoptimization Do not turn off try-catch-tree-shaking\n--no-treeshake.no-unknownGlobalSideEffects Assume unknown globals do not throw\n\nExamples:\n\n# use settings in config file\nrollup -c\n\n# in config file, process.env.INCLUDE_DEPS === 'true'\n# and process.env.BUILD === 'production'\nrollup -c --environment INCLUDE_DEPS,BUILD:production\n\n# create CommonJS bundle.js from src/main.js\nrollup --format=cjs --file=bundle.js -- src/main.js\n\n# create self-executing IIFE using `window.jQuery`\n# and `window._` as external globals\nrollup -f iife --globals jquery:jQuery,lodash:_ \\\n  -i src/app.js -o build/app.js -m build/app.js.map\n\nNotes:\n\n* When piping to stdout, only inline sourcemaps are permitted\n\nFor more information visit https://rollupjs.org\n";

const preserveCamelCase = string => {
	let isLastCharLower = false;
	let isLastCharUpper = false;
	let isLastLastCharUpper = false;

	for (let i = 0; i < string.length; i++) {
		const character = string[i];

		if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
			string = string.slice(0, i) + '-' + string.slice(i);
			isLastCharLower = false;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = true;
			i++;
		} else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
			string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = false;
			isLastCharLower = true;
		} else {
			isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
		}
	}

	return string;
};

const camelCase = (input, options) => {
	if (!(typeof input === 'string' || Array.isArray(input))) {
		throw new TypeError('Expected the input to be `string | string[]`');
	}

	options = Object.assign({
		pascalCase: false
	}, options);

	const postProcess = x => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;

	if (Array.isArray(input)) {
		input = input.map(x => x.trim())
			.filter(x => x.length)
			.join('-');
	} else {
		input = input.trim();
	}

	if (input.length === 0) {
		return '';
	}

	if (input.length === 1) {
		return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
	}

	const hasUpperCase = input !== input.toLowerCase();

	if (hasUpperCase) {
		input = preserveCamelCase(input);
	}

	input = input
		.replace(/^[_.\- ]+/, '')
		.toLowerCase()
		.replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase())
		.replace(/\d+(\w|$)/g, m => m.toUpperCase());

	return postProcess(input);
};

var camelcase = camelCase;
// TODO: Remove this for the next major release
var _default = camelCase;
camelcase.default = _default;

var decamelize = function (str, sep) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	sep = typeof sep === 'undefined' ? '_' : sep;

	return str
		.replace(/([a-z\d])([A-Z])/g, '$1' + sep + '$2')
		.replace(/([A-Z]+)([A-Z][a-z\d]+)/g, '$1' + sep + '$2')
		.toLowerCase();
};

// take an un-split argv string and tokenize it.
var tokenizeArgString = function (argString) {
  if (Array.isArray(argString)) {
    return argString.map(e => typeof e !== 'string' ? e + '' : e)
  }

  argString = argString.trim();

  let i = 0;
  let prevC = null;
  let c = null;
  let opening = null;
  const args = [];

  for (let ii = 0; ii < argString.length; ii++) {
    prevC = c;
    c = argString.charAt(ii);

    // split on spaces unless we're in quotes.
    if (c === ' ' && !opening) {
      if (!(prevC === ' ')) {
        i++;
      }
      continue
    }

    // don't split the string if we're in matching
    // opening or closing single and double quotes.
    if (c === opening) {
      opening = null;
    } else if ((c === "'" || c === '"') && !opening) {
      opening = c;
    }

    if (!args[i]) args[i] = '';
    args[i] += c;
  }

  return args
};

function parse (args, opts) {
  opts = Object.assign(Object.create(null), opts);
  // allow a string argument to be passed in rather
  // than an argv array.
  args = tokenizeArgString(args);

  // aliases might have transitive relationships, normalize this.
  const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
  const configuration = Object.assign({
    'boolean-negation': true,
    'camel-case-expansion': true,
    'combine-arrays': false,
    'dot-notation': true,
    'duplicate-arguments-array': true,
    'flatten-duplicate-arrays': true,
    'greedy-arrays': true,
    'halt-at-non-option': false,
    'nargs-eats-options': false,
    'negation-prefix': 'no-',
    'parse-numbers': true,
    'populate--': false,
    'set-placeholder-key': false,
    'short-option-groups': true,
    'strip-aliased': false,
    'strip-dashed': false,
    'unknown-options-as-args': false
  }, opts.configuration);
  const defaults = Object.assign(Object.create(null), opts.default);
  const configObjects = opts.configObjects || [];
  const envPrefix = opts.envPrefix;
  const notFlagsOption = configuration['populate--'];
  const notFlagsArgv = notFlagsOption ? '--' : '_';
  const newAliases = Object.create(null);
  const defaulted = Object.create(null);
  // allow a i18n handler to be passed in, default to a fake one (util.format).
  const __ = opts.__ || util.format;
  const flags = {
    aliases: Object.create(null),
    arrays: Object.create(null),
    bools: Object.create(null),
    strings: Object.create(null),
    numbers: Object.create(null),
    counts: Object.create(null),
    normalize: Object.create(null),
    configs: Object.create(null),
    nargs: Object.create(null),
    coercions: Object.create(null),
    keys: []
  };
  const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
  const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)')

  ;[].concat(opts.array).filter(Boolean).forEach(function (opt) {
    const key = opt.key || opt;

    // assign to flags[bools|strings|numbers]
    const assignment = Object.keys(opt).map(function (key) {
      return ({
        boolean: 'bools',
        string: 'strings',
        number: 'numbers'
      })[key]
    }).filter(Boolean).pop();

    // assign key to be coerced
    if (assignment) {
      flags[assignment][key] = true;
    }

    flags.arrays[key] = true;
    flags.keys.push(key);
  })

  ;[].concat(opts.boolean).filter(Boolean).forEach(function (key) {
    flags.bools[key] = true;
    flags.keys.push(key);
  })

  ;[].concat(opts.string).filter(Boolean).forEach(function (key) {
    flags.strings[key] = true;
    flags.keys.push(key);
  })

  ;[].concat(opts.number).filter(Boolean).forEach(function (key) {
    flags.numbers[key] = true;
    flags.keys.push(key);
  })

  ;[].concat(opts.count).filter(Boolean).forEach(function (key) {
    flags.counts[key] = true;
    flags.keys.push(key);
  })

  ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) {
    flags.normalize[key] = true;
    flags.keys.push(key);
  });

  Object.keys(opts.narg || {}).forEach(function (k) {
    flags.nargs[k] = opts.narg[k];
    flags.keys.push(k);
  });

  Object.keys(opts.coerce || {}).forEach(function (k) {
    flags.coercions[k] = opts.coerce[k];
    flags.keys.push(k);
  });

  if (Array.isArray(opts.config) || typeof opts.config === 'string') {
[].concat(opts.config).filter(Boolean).forEach(function (key) {
      flags.configs[key] = true;
    });
  } else {
    Object.keys(opts.config || {}).forEach(function (k) {
      flags.configs[k] = opts.config[k];
    });
  }

  // create a lookup table that takes into account all
  // combinations of aliases: {f: ['foo'], foo: ['f']}
  extendAliases(opts.key, aliases, opts.default, flags.arrays);

  // apply default values to all aliases.
  Object.keys(defaults).forEach(function (key) {
    (flags.aliases[key] || []).forEach(function (alias) {
      defaults[alias] = defaults[key];
    });
  });

  let error = null;
  checkConfiguration();

  let notFlags = [];

  const argv = Object.assign(Object.create(null), { _: [] });
  // TODO(bcoe): for the first pass at removing object prototype  we didn't
  // remove all prototypes from objects returned by this API, we might want
  // to gradually move towards doing so.
  const argvReturn = {};

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    let broken;
    let key;
    let letters;
    let m;
    let next;
    let value;

    // any unknown option (except for end-of-options, "--")
    if (arg !== '--' && isUnknownOptionAsArg(arg)) {
      argv._.push(arg);
    // -- separated by =
    } else if (arg.match(/^--.+=/) || (
      !configuration['short-option-groups'] && arg.match(/^-.+=/)
    )) {
      // Using [\s\S] instead of . because js doesn't support the
      // 'dotall' regex modifier. See:
      // http://stackoverflow.com/a/1068308/13216
      m = arg.match(/^--?([^=]+)=([\s\S]*)$/);

      // arrays format = '--f=a b c'
      if (checkAllAliases(m[1], flags.arrays)) {
        i = eatArray(i, m[1], args, m[2]);
      } else if (checkAllAliases(m[1], flags.nargs) !== false) {
        // nargs format = '--f=monkey washing cat'
        i = eatNargs(i, m[1], args, m[2]);
      } else {
        setArg(m[1], m[2]);
      }
    } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {
      key = arg.match(negatedBoolean)[1];
      setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);

    // -- separated by space.
    } else if (arg.match(/^--.+/) || (
      !configuration['short-option-groups'] && arg.match(/^-[^-]+/)
    )) {
      key = arg.match(/^--?(.+)/)[1];

      if (checkAllAliases(key, flags.arrays)) {
        // array format = '--foo a b c'
        i = eatArray(i, key, args);
      } else if (checkAllAliases(key, flags.nargs) !== false) {
        // nargs format = '--foo a b c'
        // should be truthy even if: flags.nargs[key] === 0
        i = eatNargs(i, key, args);
      } else {
        next = args[i + 1];

        if (next !== undefined && (!next.match(/^-/) ||
          next.match(negative)) &&
          !checkAllAliases(key, flags.bools) &&
          !checkAllAliases(key, flags.counts)) {
          setArg(key, next);
          i++;
        } else if (/^(true|false)$/.test(next)) {
          setArg(key, next);
          i++;
        } else {
          setArg(key, defaultValue(key));
        }
      }

    // dot-notation flag separated by '='.
    } else if (arg.match(/^-.\..+=/)) {
      m = arg.match(/^-([^=]+)=([\s\S]*)$/);
      setArg(m[1], m[2]);

    // dot-notation flag separated by space.
    } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
      next = args[i + 1];
      key = arg.match(/^-(.\..+)/)[1];

      if (next !== undefined && !next.match(/^-/) &&
        !checkAllAliases(key, flags.bools) &&
        !checkAllAliases(key, flags.counts)) {
        setArg(key, next);
        i++;
      } else {
        setArg(key, defaultValue(key));
      }
    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
      letters = arg.slice(1, -1).split('');
      broken = false;

      for (let j = 0; j < letters.length; j++) {
        next = arg.slice(j + 2);

        if (letters[j + 1] && letters[j + 1] === '=') {
          value = arg.slice(j + 3);
          key = letters[j];

          if (checkAllAliases(key, flags.arrays)) {
            // array format = '-f=a b c'
            i = eatArray(i, key, args, value);
          } else if (checkAllAliases(key, flags.nargs) !== false) {
            // nargs format = '-f=monkey washing cat'
            i = eatNargs(i, key, args, value);
          } else {
            setArg(key, value);
          }

          broken = true;
          break
        }

        if (next === '-') {
          setArg(letters[j], next);
          continue
        }

        // current letter is an alphabetic character and next value is a number
        if (/[A-Za-z]/.test(letters[j]) &&
          /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
          setArg(letters[j], next);
          broken = true;
          break
        }

        if (letters[j + 1] && letters[j + 1].match(/\W/)) {
          setArg(letters[j], next);
          broken = true;
          break
        } else {
          setArg(letters[j], defaultValue(letters[j]));
        }
      }

      key = arg.slice(-1)[0];

      if (!broken && key !== '-') {
        if (checkAllAliases(key, flags.arrays)) {
          // array format = '-f a b c'
          i = eatArray(i, key, args);
        } else if (checkAllAliases(key, flags.nargs) !== false) {
          // nargs format = '-f a b c'
          // should be truthy even if: flags.nargs[key] === 0
          i = eatNargs(i, key, args);
        } else {
          next = args[i + 1];

          if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||
            next.match(negative)) &&
            !checkAllAliases(key, flags.bools) &&
            !checkAllAliases(key, flags.counts)) {
            setArg(key, next);
            i++;
          } else if (/^(true|false)$/.test(next)) {
            setArg(key, next);
            i++;
          } else {
            setArg(key, defaultValue(key));
          }
        }
      }
    } else if (arg.match(/^-[0-9]$/) &&
      arg.match(negative) &&
      checkAllAliases(arg.slice(1), flags.bools)) {
      // single-digit boolean alias, e.g: xargs -0
      key = arg.slice(1);
      setArg(key, defaultValue(key));
    } else if (arg === '--') {
      notFlags = args.slice(i + 1);
      break
    } else if (configuration['halt-at-non-option']) {
      notFlags = args.slice(i);
      break
    } else {
      argv._.push(maybeCoerceNumber('_', arg));
    }
  }

  // order of precedence:
  // 1. command line arg
  // 2. value from env var
  // 3. value from config file
  // 4. value from config objects
  // 5. configured default value
  applyEnvVars(argv, true); // special case: check env vars that point to config file
  applyEnvVars(argv, false);
  setConfig(argv);
  setConfigObjects();
  applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
  applyCoercions(argv);
  if (configuration['set-placeholder-key']) setPlaceholderKeys(argv);

  // for any counts either not in args or without an explicit default, set to 0
  Object.keys(flags.counts).forEach(function (key) {
    if (!hasKey(argv, key.split('.'))) setArg(key, 0);
  });

  // '--' defaults to undefined.
  if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = [];
  notFlags.forEach(function (key) {
    argv[notFlagsArgv].push(key);
  });

  if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {
    Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {
      delete argv[key];
    });
  }

  if (configuration['strip-aliased']) {
[].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {
      if (configuration['camel-case-expansion']) {
        delete argv[alias.split('.').map(prop => camelcase(prop)).join('.')];
      }

      delete argv[alias];
    });
  }

  // how many arguments should we consume, based
  // on the nargs option?
  function eatNargs (i, key, args, argAfterEqualSign) {
    let ii;
    let toEat = checkAllAliases(key, flags.nargs);
    // NaN has a special meaning for the array type, indicating that one or
    // more values are expected.
    toEat = isNaN(toEat) ? 1 : toEat;

    if (toEat === 0) {
      if (!isUndefined(argAfterEqualSign)) {
        error = Error(__('Argument unexpected for: %s', key));
      }
      setArg(key, defaultValue(key));
      return i
    }

    let available = isUndefined(argAfterEqualSign) ? 0 : 1;
    if (configuration['nargs-eats-options']) {
      // classic behavior, yargs eats positional and dash arguments.
      if (args.length - (i + 1) + available < toEat) {
        error = Error(__('Not enough arguments following: %s', key));
      }
      available = toEat;
    } else {
      // nargs will not consume flag arguments, e.g., -abc, --foo,
      // and terminates when one is observed.
      for (ii = i + 1; ii < args.length; ii++) {
        if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii])) available++;
        else break
      }
      if (available < toEat) error = Error(__('Not enough arguments following: %s', key));
    }

    let consumed = Math.min(available, toEat);
    if (!isUndefined(argAfterEqualSign) && consumed > 0) {
      setArg(key, argAfterEqualSign);
      consumed--;
    }
    for (ii = i + 1; ii < (consumed + i + 1); ii++) {
      setArg(key, args[ii]);
    }

    return (i + consumed)
  }

  // if an option is an array, eat all non-hyphenated arguments
  // following it... YUM!
  // e.g., --foo apple banana cat becomes ["apple", "banana", "cat"]
  function eatArray (i, key, args, argAfterEqualSign) {
    let argsToSet = [];
    let next = argAfterEqualSign || args[i + 1];
    // If both array and nargs are configured, enforce the nargs count:
    const nargsCount = checkAllAliases(key, flags.nargs);

    if (checkAllAliases(key, flags.bools) && !(/^(true|false)$/.test(next))) {
      argsToSet.push(true);
    } else if (isUndefined(next) ||
        (isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))) {
      // for keys without value ==> argsToSet remains an empty []
      // set user default value, if available
      if (defaults[key] !== undefined) {
        const defVal = defaults[key];
        argsToSet = Array.isArray(defVal) ? defVal : [defVal];
      }
    } else {
      // value in --option=value is eaten as is
      if (!isUndefined(argAfterEqualSign)) {
        argsToSet.push(processValue(key, argAfterEqualSign));
      }
      for (let ii = i + 1; ii < args.length; ii++) {
        if ((!configuration['greedy-arrays'] && argsToSet.length > 0) ||
          (nargsCount && argsToSet.length >= nargsCount)) break
        next = args[ii];
        if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break
        i = ii;
        argsToSet.push(processValue(key, next));
      }
    }

    // If both array and nargs are configured, create an error if less than
    // nargs positionals were found. NaN has special meaning, indicating
    // that at least one value is required (more are okay).
    if ((nargsCount && argsToSet.length < nargsCount) ||
        (isNaN(nargsCount) && argsToSet.length === 0)) {
      error = Error(__('Not enough arguments following: %s', key));
    }

    setArg(key, argsToSet);
    return i
  }

  function setArg (key, val) {
    if (/-/.test(key) && configuration['camel-case-expansion']) {
      const alias = key.split('.').map(function (prop) {
        return camelcase(prop)
      }).join('.');
      addNewAlias(key, alias);
    }

    const value = processValue(key, val);
    const splitKey = key.split('.');
    setKey(argv, splitKey, value);

    // handle populating aliases of the full key
    if (flags.aliases[key]) {
      flags.aliases[key].forEach(function (x) {
        x = x.split('.');
        setKey(argv, x, value);
      });
    }

    // handle populating aliases of the first element of the dot-notation key
    if (splitKey.length > 1 && configuration['dot-notation']) {
(flags.aliases[splitKey[0]] || []).forEach(function (x) {
        x = x.split('.');

        // expand alias with nested objects in key
        const a = [].concat(splitKey);
        a.shift(); // nuke the old key.
        x = x.concat(a);

        // populate alias only if is not already an alias of the full key
        // (already populated above)
        if (!(flags.aliases[key] || []).includes(x.join('.'))) {
          setKey(argv, x, value);
        }
      });
    }

    // Set normalize getter and setter when key is in 'normalize' but isn't an array
    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
      const keys = [key].concat(flags.aliases[key] || []);
      keys.forEach(function (key) {
        Object.defineProperty(argvReturn, key, {
          enumerable: true,
          get () {
            return val
          },
          set (value) {
            val = typeof value === 'string' ? path.normalize(value) : value;
          }
        });
      });
    }
  }

  function addNewAlias (key, alias) {
    if (!(flags.aliases[key] && flags.aliases[key].length)) {
      flags.aliases[key] = [alias];
      newAliases[alias] = true;
    }
    if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
      addNewAlias(alias, key);
    }
  }

  function processValue (key, val) {
    // strings may be quoted, clean this up as we assign values.
    if (typeof val === 'string' &&
      (val[0] === "'" || val[0] === '"') &&
      val[val.length - 1] === val[0]
    ) {
      val = val.substring(1, val.length - 1);
    }

    // handle parsing boolean arguments --foo=true --bar false.
    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
      if (typeof val === 'string') val = val === 'true';
    }

    let value = Array.isArray(val)
      ? val.map(function (v) { return maybeCoerceNumber(key, v) })
      : maybeCoerceNumber(key, val);

    // increment a count given as arg (either no value or value parsed as boolean)
    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {
      value = increment;
    }

    // Set normalized value when key is in 'normalize' and in 'arrays'
    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
      if (Array.isArray(val)) value = val.map(path.normalize);
      else value = path.normalize(val);
    }
    return value
  }

  function maybeCoerceNumber (key, value) {
    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
      const shouldCoerceNumber = isNumber(value) && configuration['parse-numbers'] && (
        Number.isSafeInteger(Math.floor(value))
      );
      if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) value = Number(value);
    }
    return value
  }

  // set args from config.json file, this should be
  // applied last so that defaults can be applied.
  function setConfig (argv) {
    const configLookup = Object.create(null);

    // expand defaults/aliases, in-case any happen to reference
    // the config.json file.
    applyDefaultsAndAliases(configLookup, flags.aliases, defaults);

    Object.keys(flags.configs).forEach(function (configKey) {
      const configPath = argv[configKey] || configLookup[configKey];
      if (configPath) {
        try {
          let config = null;
          const resolvedConfigPath = path.resolve(process.cwd(), configPath);

          if (typeof flags.configs[configKey] === 'function') {
            try {
              config = flags.configs[configKey](resolvedConfigPath);
            } catch (e) {
              config = e;
            }
            if (config instanceof Error) {
              error = config;
              return
            }
          } else {
            config = rollup_js.commonjsRequire();
          }

          setConfigObject(config);
        } catch (ex) {
          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath));
        }
      }
    });
  }

  // set args from config object.
  // it recursively checks nested objects.
  function setConfigObject (config, prev) {
    Object.keys(config).forEach(function (key) {
      const value = config[key];
      const fullKey = prev ? prev + '.' + key : key;

      // if the value is an inner object and we have dot-notation
      // enabled, treat inner objects in config the same as
      // heavily nested dot notations (foo.bar.apple).
      if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {
        // if the value is an object but not an array, check nested object
        setConfigObject(value, fullKey);
      } else {
        // setting arguments via CLI takes precedence over
        // values within the config file.
        if (!hasKey(argv, fullKey.split('.')) || (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])) {
          setArg(fullKey, value);
        }
      }
    });
  }

  // set all config objects passed in opts
  function setConfigObjects () {
    if (typeof configObjects === 'undefined') return
    configObjects.forEach(function (configObject) {
      setConfigObject(configObject);
    });
  }

  function applyEnvVars (argv, configOnly) {
    if (typeof envPrefix === 'undefined') return

    const prefix = typeof envPrefix === 'string' ? envPrefix : '';
    Object.keys(process.env).forEach(function (envVar) {
      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {
        // get array of nested keys and convert them to camel case
        const keys = envVar.split('__').map(function (key, i) {
          if (i === 0) {
            key = key.substring(prefix.length);
          }
          return camelcase(key)
        });

        if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && !hasKey(argv, keys)) {
          setArg(keys.join('.'), process.env[envVar]);
        }
      }
    });
  }

  function applyCoercions (argv) {
    let coerce;
    const applied = new Set();
    Object.keys(argv).forEach(function (key) {
      if (!applied.has(key)) { // If we haven't already coerced this option via one of its aliases
        coerce = checkAllAliases(key, flags.coercions);
        if (typeof coerce === 'function') {
          try {
            const value = maybeCoerceNumber(key, coerce(argv[key]))
            ;([].concat(flags.aliases[key] || [], key)).forEach(ali => {
              applied.add(ali);
              argv[ali] = value;
            });
          } catch (err) {
            error = err;
          }
        }
      }
    });
  }

  function setPlaceholderKeys (argv) {
    flags.keys.forEach((key) => {
      // don't set placeholder keys for dot notation options 'foo.bar'.
      if (~key.indexOf('.')) return
      if (typeof argv[key] === 'undefined') argv[key] = undefined;
    });
    return argv
  }

  function applyDefaultsAndAliases (obj, aliases, defaults, canLog = false) {
    Object.keys(defaults).forEach(function (key) {
      if (!hasKey(obj, key.split('.'))) {
        setKey(obj, key.split('.'), defaults[key]);
        if (canLog) defaulted[key] = true

        ;(aliases[key] || []).forEach(function (x) {
          if (hasKey(obj, x.split('.'))) return
          setKey(obj, x.split('.'), defaults[key]);
        });
      }
    });
  }

  function hasKey (obj, keys) {
    let o = obj;

    if (!configuration['dot-notation']) keys = [keys.join('.')];

    keys.slice(0, -1).forEach(function (key) {
      o = (o[key] || {});
    });

    const key = keys[keys.length - 1];

    if (typeof o !== 'object') return false
    else return key in o
  }

  function setKey (obj, keys, value) {
    let o = obj;

    if (!configuration['dot-notation']) keys = [keys.join('.')];

    keys.slice(0, -1).forEach(function (key, index) {
      // TODO(bcoe): in the next major version of yargs, switch to
      // Object.create(null) for dot notation:
      key = sanitizeKey(key);

      if (typeof o === 'object' && o[key] === undefined) {
        o[key] = {};
      }

      if (typeof o[key] !== 'object' || Array.isArray(o[key])) {
        // ensure that o[key] is an array, and that the last item is an empty object.
        if (Array.isArray(o[key])) {
          o[key].push({});
        } else {
          o[key] = [o[key], {}];
        }

        // we want to update the empty object at the end of the o[key] array, so set o to that object
        o = o[key][o[key].length - 1];
      } else {
        o = o[key];
      }
    });

    // TODO(bcoe): in the next major version of yargs, switch to
    // Object.create(null) for dot notation:
    const key = sanitizeKey(keys[keys.length - 1]);

    const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);
    const isValueArray = Array.isArray(value);
    let duplicate = configuration['duplicate-arguments-array'];

    // nargs has higher priority than duplicate
    if (!duplicate && checkAllAliases(key, flags.nargs)) {
      duplicate = true;
      if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {
        o[key] = undefined;
      }
    }

    if (value === increment) {
      o[key] = increment(o[key]);
    } else if (Array.isArray(o[key])) {
      if (duplicate && isTypeArray && isValueArray) {
        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
      } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
        o[key] = value;
      } else {
        o[key] = o[key].concat([value]);
      }
    } else if (o[key] === undefined && isTypeArray) {
      o[key] = isValueArray ? value : [value];
    } else if (duplicate && !(
      o[key] === undefined ||
        checkAllAliases(key, flags.counts) ||
        checkAllAliases(key, flags.bools)
    )) {
      o[key] = [o[key], value];
    } else {
      o[key] = value;
    }
  }

  // extend the aliases list with inferred aliases.
  function extendAliases (...args) {
    args.forEach(function (obj) {
      Object.keys(obj || {}).forEach(function (key) {
        // short-circuit if we've already added a key
        // to the aliases array, for example it might
        // exist in both 'opts.default' and 'opts.key'.
        if (flags.aliases[key]) return

        flags.aliases[key] = [].concat(aliases[key] || []);
        // For "--option-name", also set argv.optionName
        flags.aliases[key].concat(key).forEach(function (x) {
          if (/-/.test(x) && configuration['camel-case-expansion']) {
            const c = camelcase(x);
            if (c !== key && flags.aliases[key].indexOf(c) === -1) {
              flags.aliases[key].push(c);
              newAliases[c] = true;
            }
          }
        });
        // For "--optionName", also set argv['option-name']
        flags.aliases[key].concat(key).forEach(function (x) {
          if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {
            const c = decamelize(x, '-');
            if (c !== key && flags.aliases[key].indexOf(c) === -1) {
              flags.aliases[key].push(c);
              newAliases[c] = true;
            }
          }
        });
        flags.aliases[key].forEach(function (x) {
          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {
            return x !== y
          }));
        });
      });
    });
  }

  // return the 1st set flag for any of a key's aliases (or false if no flag set)
  function checkAllAliases (key, flag) {
    const toCheck = [].concat(flags.aliases[key] || [], key);
    const keys = Object.keys(flag);
    const setAlias = toCheck.find(key => keys.includes(key));
    return setAlias ? flag[setAlias] : false
  }

  function hasAnyFlag (key) {
    const toCheck = [].concat(Object.keys(flags).map(k => flags[k]));
    return toCheck.some(function (flag) {
      return Array.isArray(flag) ? flag.includes(key) : flag[key]
    })
  }

  function hasFlagsMatching (arg, ...patterns) {
    const toCheck = [].concat(...patterns);
    return toCheck.some(function (pattern) {
      const match = arg.match(pattern);
      return match && hasAnyFlag(match[1])
    })
  }

  // based on a simplified version of the short flag group parsing logic
  function hasAllShortFlags (arg) {
    // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group
    if (arg.match(negative) || !arg.match(/^-[^-]+/)) { return false }
    let hasAllFlags = true;
    let next;
    const letters = arg.slice(1).split('');
    for (let j = 0; j < letters.length; j++) {
      next = arg.slice(j + 2);

      if (!hasAnyFlag(letters[j])) {
        hasAllFlags = false;
        break
      }

      if ((letters[j + 1] && letters[j + 1] === '=') ||
        next === '-' ||
        (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) ||
        (letters[j + 1] && letters[j + 1].match(/\W/))) {
        break
      }
    }
    return hasAllFlags
  }

  function isUnknownOptionAsArg (arg) {
    return configuration['unknown-options-as-args'] && isUnknownOption(arg)
  }

  function isUnknownOption (arg) {
    // ignore negative numbers
    if (arg.match(negative)) { return false }
    // if this is a short option group and all of them are configured, it isn't unknown
    if (hasAllShortFlags(arg)) { return false }
    // e.g. '--count=2'
    const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
    // e.g. '-a' or '--arg'
    const normalFlag = /^-+([^=]+?)$/;
    // e.g. '-a-'
    const flagEndingInHyphen = /^-+([^=]+?)-$/;
    // e.g. '-abc123'
    const flagEndingInDigits = /^-+([^=]+?\d+)$/;
    // e.g. '-a/usr/local'
    const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
    // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method
    return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters)
  }

  // make a best effor to pick a default value
  // for an option based on name and type.
  function defaultValue (key) {
    if (!checkAllAliases(key, flags.bools) &&
        !checkAllAliases(key, flags.counts) &&
        `${key}` in defaults) {
      return defaults[key]
    } else {
      return defaultForType(guessType(key))
    }
  }

  // return a default value, given the type of a flag.,
  // e.g., key of type 'string' will default to '', rather than 'true'.
  function defaultForType (type) {
    const def = {
      boolean: true,
      string: '',
      number: undefined,
      array: []
    };

    return def[type]
  }

  // given a flag, enforce a default type.
  function guessType (key) {
    let type = 'boolean';
    if (checkAllAliases(key, flags.strings)) type = 'string';
    else if (checkAllAliases(key, flags.numbers)) type = 'number';
    else if (checkAllAliases(key, flags.bools)) type = 'boolean';
    else if (checkAllAliases(key, flags.arrays)) type = 'array';
    return type
  }

  function isNumber (x) {
    if (x === null || x === undefined) return false
    // if loaded from config, may already be a number.
    if (typeof x === 'number') return true
    // hexadecimal.
    if (/^0x[0-9a-f]+$/i.test(x)) return true
    // don't treat 0123 as a number; as it drops the leading '0'.
    if (x.length > 1 && x[0] === '0') return false
    return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x)
  }

  function isUndefined (num) {
    return num === undefined
  }

  // check user configuration settings for inconsistencies
  function checkConfiguration () {
    // count keys should not be set as array/narg
    Object.keys(flags.counts).find(key => {
      if (checkAllAliases(key, flags.arrays)) {
        error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));
        return true
      } else if (checkAllAliases(key, flags.nargs)) {
        error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));
        return true
      }
    });
  }

  return {
    argv: Object.assign(argvReturn, argv),
    error: error,
    aliases: Object.assign({}, flags.aliases),
    newAliases: Object.assign({}, newAliases),
    defaulted: Object.assign({}, defaulted),
    configuration: configuration
  }
}

// if any aliases reference each other, we should
// merge them together.
function combineAliases (aliases) {
  const aliasArrays = [];
  const combined = Object.create(null);
  let change = true;

  // turn alias lookup hash {key: ['alias1', 'alias2']} into
  // a simple array ['key', 'alias1', 'alias2']
  Object.keys(aliases).forEach(function (key) {
    aliasArrays.push(
      [].concat(aliases[key], key)
    );
  });

  // combine arrays until zero changes are
  // made in an iteration.
  while (change) {
    change = false;
    for (let i = 0; i < aliasArrays.length; i++) {
      for (let ii = i + 1; ii < aliasArrays.length; ii++) {
        const intersect = aliasArrays[i].filter(function (v) {
          return aliasArrays[ii].indexOf(v) !== -1
        });

        if (intersect.length) {
          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
          aliasArrays.splice(ii, 1);
          change = true;
          break
        }
      }
    }
  }

  // map arrays back to the hash-lookup (de-dupe while
  // we're at it).
  aliasArrays.forEach(function (aliasArray) {
    aliasArray = aliasArray.filter(function (v, i, self) {
      return self.indexOf(v) === i
    });
    combined[aliasArray.pop()] = aliasArray;
  });

  return combined
}

// this function should only be called when a count is given as an arg
// it is NOT called to set a default value
// thus we can start the count at 1 instead of 0
function increment (orig) {
  return orig !== undefined ? orig + 1 : 1
}

function Parser (args, opts) {
  const result = parse(args.slice(), opts);
  return result.argv
}

// parse arguments and return detailed
// meta information, aliases, etc.
Parser.detailed = function (args, opts) {
  return parse(args.slice(), opts)
};

// TODO(bcoe): in the next major version of yargs, switch to
// Object.create(null) for dot notation:
function sanitizeKey (key) {
  if (key === '__proto__') return '___proto___'
  return key
}

var yargsParser = Parser;

var parseMs = milliseconds => {
	if (typeof milliseconds !== 'number') {
		throw new TypeError('Expected a number');
	}

	const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;

	return {
		days: roundTowardsZero(milliseconds / 86400000),
		hours: roundTowardsZero(milliseconds / 3600000) % 24,
		minutes: roundTowardsZero(milliseconds / 60000) % 60,
		seconds: roundTowardsZero(milliseconds / 1000) % 60,
		milliseconds: roundTowardsZero(milliseconds) % 1000,
		microseconds: roundTowardsZero(milliseconds * 1000) % 1000,
		nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1000
	};
};

const pluralize = (word, count) => count === 1 ? word : `${word}s`;

const SECOND_ROUNDING_EPSILON = 0.0000001;

var prettyMs = (milliseconds, options = {}) => {
	if (!Number.isFinite(milliseconds)) {
		throw new TypeError('Expected a finite number');
	}

	if (options.colonNotation) {
		options.compact = false;
		options.formatSubMilliseconds = false;
		options.separateMilliseconds = false;
		options.verbose = false;
	}

	if (options.compact) {
		options.secondsDecimalDigits = 0;
		options.millisecondsDecimalDigits = 0;
	}

	const result = [];

	const floorDecimals = (value, decimalDigits) => {
		const flooredInterimValue = Math.floor((value * (10 ** decimalDigits)) + SECOND_ROUNDING_EPSILON);
		const flooredValue = Math.round(flooredInterimValue) / (10 ** decimalDigits);
		return flooredValue.toFixed(decimalDigits);
	};

	const add = (value, long, short, valueString) => {
		if ((result.length === 0 || !options.colonNotation) && value === 0 && !(options.colonNotation && short === 'm')) {
			return;
		}

		valueString = (valueString || value || '0').toString();
		let prefix;
		let suffix;
		if (options.colonNotation) {
			prefix = result.length > 0 ? ':' : '';
			suffix = '';
			const wholeDigits = valueString.includes('.') ? valueString.split('.')[0].length : valueString.length;
			const minLength = result.length > 0 ? 2 : 1;
			valueString = '0'.repeat(Math.max(0, minLength - wholeDigits)) + valueString;
		} else {
			prefix = '';
			suffix = options.verbose ? ' ' + pluralize(long, value) : short;
		}

		result.push(prefix + valueString + suffix);
	};

	const parsed = parseMs(milliseconds);

	add(Math.trunc(parsed.days / 365), 'year', 'y');
	add(parsed.days % 365, 'day', 'd');
	add(parsed.hours, 'hour', 'h');
	add(parsed.minutes, 'minute', 'm');

	if (
		options.separateMilliseconds ||
		options.formatSubMilliseconds ||
		milliseconds < 1000
	) {
		add(parsed.seconds, 'second', 's');
		if (options.formatSubMilliseconds) {
			add(parsed.milliseconds, 'millisecond', 'ms');
			add(parsed.microseconds, 'microsecond', 'µs');
			add(parsed.nanoseconds, 'nanosecond', 'ns');
		} else {
			const millisecondsAndBelow =
				parsed.milliseconds +
				(parsed.microseconds / 1000) +
				(parsed.nanoseconds / 1e6);

			const millisecondsDecimalDigits =
				typeof options.millisecondsDecimalDigits === 'number' ?
					options.millisecondsDecimalDigits :
					0;

			const roundedMiliseconds = millisecondsAndBelow >= 1 ?
				Math.round(millisecondsAndBelow) :
				Math.ceil(millisecondsAndBelow);

			const millisecondsString = millisecondsDecimalDigits ?
				millisecondsAndBelow.toFixed(millisecondsDecimalDigits) :
				roundedMiliseconds;

			add(
				Number.parseFloat(millisecondsString, 10),
				'millisecond',
				'ms',
				millisecondsString
			);
		}
	} else {
		const seconds = (milliseconds / 1000) % 60;
		const secondsDecimalDigits =
			typeof options.secondsDecimalDigits === 'number' ?
				options.secondsDecimalDigits :
				1;
		const secondsFixed = floorDecimals(seconds, secondsDecimalDigits);
		const secondsString = options.keepDecimalsOnWholeSeconds ?
			secondsFixed :
			secondsFixed.replace(/\.0+$/, '');
		add(Number.parseFloat(secondsString, 10), 'second', 's', secondsString);
	}

	if (result.length === 0) {
		return '0' + (options.verbose ? ' milliseconds' : 'ms');
	}

	if (options.compact) {
		return result[0];
	}

	if (typeof options.unitCount === 'number') {
		const separator = options.colonNotation ? '' : ' ';
		return result.slice(0, Math.max(options.unitCount, 1)).join(separator);
	}

	return options.colonNotation ? result.join('') : result.join(' ');
};

let SOURCEMAPPING_URL = 'sourceMa';
SOURCEMAPPING_URL += 'ppingURL';
var SOURCEMAPPING_URL$1 = SOURCEMAPPING_URL;

const BYTE_UNITS = [
	'B',
	'kB',
	'MB',
	'GB',
	'TB',
	'PB',
	'EB',
	'ZB',
	'YB'
];

const BIT_UNITS = [
	'b',
	'kbit',
	'Mbit',
	'Gbit',
	'Tbit',
	'Pbit',
	'Ebit',
	'Zbit',
	'Ybit'
];

/*
Formats the given number using `Number#toLocaleString`.
- If locale is a string, the value is expected to be a locale-key (for example: `de`).
- If locale is true, the system default locale is used for translation.
- If no value for locale is specified, the number is returned unmodified.
*/
const toLocaleString = (number, locale) => {
	let result = number;
	if (typeof locale === 'string') {
		result = number.toLocaleString(locale);
	} else if (locale === true) {
		result = number.toLocaleString();
	}

	return result;
};

var prettyBytes = (number, options) => {
	if (!Number.isFinite(number)) {
		throw new TypeError(`Expected a finite number, got ${typeof number}: ${number}`);
	}

	options = Object.assign({bits: false}, options);
	const UNITS = options.bits ? BIT_UNITS : BYTE_UNITS;

	if (options.signed && number === 0) {
		return ' 0 ' + UNITS[0];
	}

	const isNegative = number < 0;
	const prefix = isNegative ? '-' : (options.signed ? '+' : '');

	if (isNegative) {
		number = -number;
	}

	if (number < 1) {
		const numberString = toLocaleString(number, options.locale);
		return prefix + numberString + ' ' + UNITS[0];
	}

	const exponent = Math.min(Math.floor(Math.log10(number) / 3), UNITS.length - 1);
	// eslint-disable-next-line unicorn/prefer-exponentiation-operator
	number = Number((number / Math.pow(1000, exponent)).toPrecision(3));
	const numberString = toLocaleString(number, options.locale);

	const unit = UNITS[exponent];

	return prefix + numberString + ' ' + unit;
};

function printTimings(timings) {
    Object.keys(timings).forEach(label => {
        const appliedColor = label[0] === '#' ? (label[1] !== '#' ? loadConfigFile_js.colorette.underline : loadConfigFile_js.colorette.bold) : (text) => text;
        const [time, memory, total] = timings[label];
        const row = `${label}: ${time.toFixed(0)}ms, ${prettyBytes(memory)} / ${prettyBytes(total)}`;
        console.info(appliedColor(row));
    });
}

async function build(inputOptions, warnings, silent = false) {
    const outputOptions = inputOptions.output;
    const useStdout = !outputOptions[0].file && !outputOptions[0].dir;
    const start = Date.now();
    const files = useStdout ? ['stdout'] : outputOptions.map((t) => rollup_js.relativeId(t.file || t.dir));
    if (!silent) {
        let inputFiles;
        if (typeof inputOptions.input === 'string') {
            inputFiles = inputOptions.input;
        }
        else if (inputOptions.input instanceof Array) {
            inputFiles = inputOptions.input.join(', ');
        }
        else if (typeof inputOptions.input === 'object' && inputOptions.input !== null) {
            inputFiles = Object.keys(inputOptions.input)
                .map((name) => inputOptions.input[name])
                .join(', ');
        }
        loadConfigFile_js.stderr(loadConfigFile_js.colorette.cyan(`\n${loadConfigFile_js.colorette.bold(inputFiles)} → ${loadConfigFile_js.colorette.bold(files.join(', '))}...`));
    }
    const bundle = await rollup_js.rollup(inputOptions);
    if (useStdout) {
        const output = outputOptions[0];
        if (output.sourcemap && output.sourcemap !== 'inline') {
            loadConfigFile_js.handleError({
                code: 'ONLY_INLINE_SOURCEMAPS',
                message: 'Only inline sourcemaps are supported when bundling to stdout.',
            });
        }
        const { output: outputs } = await bundle.generate(output);
        for (const file of outputs) {
            let source;
            if (file.type === 'asset') {
                source = file.source;
            }
            else {
                source = file.code;
                if (output.sourcemap === 'inline') {
                    source += `\n//# ${SOURCEMAPPING_URL$1}=${file.map.toUrl()}\n`;
                }
            }
            if (outputs.length > 1)
                process.stdout.write(`\n${loadConfigFile_js.colorette.cyan(loadConfigFile_js.colorette.bold(`//→ ${file.fileName}:`))}\n`);
            process.stdout.write(source);
        }
        if (!silent) {
            warnings.flush();
        }
        return;
    }
    await Promise.all(outputOptions.map(bundle.write));
    if (!silent) {
        warnings.flush();
        loadConfigFile_js.stderr(loadConfigFile_js.colorette.green(`created ${loadConfigFile_js.colorette.bold(files.join(', '))} in ${loadConfigFile_js.colorette.bold(prettyMs(Date.now() - start))}`));
        if (bundle && bundle.getTimings) {
            printTimings(bundle.getTimings());
        }
    }
}

var modules = {};

var getModule = function(dir) {
  var rootPath = dir ? path.resolve(dir) : process.cwd();
  var rootName = path.join(rootPath, '@root');
  var root = modules[rootName];
  if (!root) {
    root = new module$1(rootName);
    root.filename = rootName;
    root.paths = module$1._nodeModulePaths(rootPath);
    modules[rootName] = root;
  }
  return root;
};

var requireRelative = function(requested, relativeTo) {
  var root = getModule(relativeTo);
  return root.require(requested);
};

requireRelative.resolve = function(requested, relativeTo) {
  var root = getModule(relativeTo);
  return module$1._resolveFilename(requested, root);
};

var requireRelative_1 = requireRelative;

const DEFAULT_CONFIG_BASE = 'rollup.config';
function getConfigPath(commandConfig) {
    const cwd = process.cwd();
    if (commandConfig === true) {
        return path.join(cwd, findConfigFileNameInCwd());
    }
    if (commandConfig.slice(0, 5) === 'node:') {
        const pkgName = commandConfig.slice(5);
        try {
            return requireRelative_1.resolve(`rollup-config-${pkgName}`, cwd);
        }
        catch (err) {
            try {
                return requireRelative_1.resolve(pkgName, cwd);
            }
            catch (err) {
                if (err.code === 'MODULE_NOT_FOUND') {
                    loadConfigFile_js.handleError({
                        code: 'MISSING_EXTERNAL_CONFIG',
                        message: `Could not resolve config file "${commandConfig}"`
                    });
                }
                throw err;
            }
        }
    }
    return fs.realpathSync(commandConfig);
}
function findConfigFileNameInCwd() {
    const filesInWorkingDir = new Set(fs.readdirSync(process.cwd()));
    for (const extension of ['mjs', 'cjs']) {
        const fileName = `${DEFAULT_CONFIG_BASE}.${extension}`;
        if (filesInWorkingDir.has(fileName))
            return fileName;
    }
    return `${DEFAULT_CONFIG_BASE}.js`;
}

function loadConfigFromCommand(command) {
    const warnings = loadConfigFile_js.batchWarnings();
    if (!command.input && (command.stdin || !process.stdin.isTTY)) {
        command.input = loadConfigFile_js.stdinName;
    }
    const options = mergeOptions.mergeOptions({ input: [] }, command, warnings.add);
    loadConfigFile_js.addCommandPluginsToInputOptions(options, command);
    return { options: [options], warnings };
}

async function runRollup(command) {
    let inputSource;
    if (command._.length > 0) {
        if (command.input) {
            loadConfigFile_js.handleError({
                code: 'DUPLICATE_IMPORT_OPTIONS',
                message: 'Either use --input, or pass input path as argument'
            });
        }
        inputSource = command._;
    }
    else if (typeof command.input === 'string') {
        inputSource = [command.input];
    }
    else {
        inputSource = command.input;
    }
    if (inputSource && inputSource.length > 0) {
        if (inputSource.some((input) => input.indexOf('=') !== -1)) {
            command.input = {};
            inputSource.forEach((input) => {
                const equalsIndex = input.indexOf('=');
                const value = input.substr(equalsIndex + 1);
                let key = input.substr(0, equalsIndex);
                if (!key)
                    key = rollup_js.getAliasName(input);
                command.input[key] = value;
            });
        }
        else {
            command.input = inputSource;
        }
    }
    if (command.environment) {
        const environment = Array.isArray(command.environment)
            ? command.environment
            : [command.environment];
        environment.forEach((arg) => {
            arg.split(',').forEach((pair) => {
                const [key, ...value] = pair.split(':');
                if (value.length) {
                    process.env[key] = value.join(':');
                }
                else {
                    process.env[key] = String(true);
                }
            });
        });
    }
    if (command.watch) {
        await rollup_js.loadFsEvents();
        const { watch } = await Promise.resolve().then(function () { return require('../shared/watch-cli.js'); });
        watch(command);
    }
    else {
        try {
            const { options, warnings } = await getConfigs(command);
            try {
                for (const inputOptions of options) {
                    await build(inputOptions, warnings, command.silent);
                }
            }
            catch (err) {
                warnings.flush();
                loadConfigFile_js.handleError(err);
            }
        }
        catch (err) {
            loadConfigFile_js.handleError(err);
        }
    }
}
async function getConfigs(command) {
    if (command.config) {
        const configFile = getConfigPath(command.config);
        const { options, warnings } = await loadConfigFile_js.loadAndParseConfigFile(configFile, command);
        return { options, warnings };
    }
    return loadConfigFromCommand(command);
}

const command = yargsParser(process.argv.slice(2), {
    alias: mergeOptions.commandAliases,
    configuration: { 'camel-case-expansion': false }
});
if (command.help || (process.argv.length <= 2 && process.stdin.isTTY)) {
    console.log(`\n${help.replace('__VERSION__', rollup_js.version)}\n`);
}
else if (command.version) {
    console.log(`rollup v${rollup_js.version}`);
}
else {
    try {
        require('source-map-support').install();
    }
    catch (err) {
        // do nothing
    }
    runRollup(command);
}

exports.getConfigPath = getConfigPath;
exports.loadConfigFromCommand = loadConfigFromCommand;
exports.prettyMs = prettyMs;
exports.printTimings = printTimings;
//# sourceMappingURL=rollup.map

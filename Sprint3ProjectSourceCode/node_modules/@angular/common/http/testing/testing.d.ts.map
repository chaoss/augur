{"version":3,"file":"testing.d.ts","sources":["testing.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA","sourcesContent":["/**\n * @license Angular v10.0.4\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { HttpBackend } from '@angular/common/http';\r\nimport { HttpEvent } from '@angular/common/http';\r\nimport { HttpHeaders } from '@angular/common/http';\r\nimport { HttpRequest } from '@angular/common/http';\r\nimport { Observable } from 'rxjs';\r\nimport { Observer } from 'rxjs';\r\n\r\n\r\n/**\r\n * Configures `HttpClientTestingBackend` as the `HttpBackend` used by `HttpClient`.\r\n *\r\n * Inject `HttpTestingController` to expect and flush requests in your tests.\r\n *\r\n * @publicApi\r\n */\r\nexport declare class HttpClientTestingModule {\r\n}\r\n\r\n/**\r\n * Controller to be injected into tests, that allows for mocking and flushing\r\n * of requests.\r\n *\r\n * @publicApi\r\n */\r\nexport declare abstract class HttpTestingController {\r\n    /**\r\n     * Search for requests that match the given parameter, without any expectations.\r\n     */\r\n    abstract match(match: string | RequestMatch | ((req: HttpRequest<any>) => boolean)): TestRequest[];\r\n    /**\r\n     * Expect that a single request has been made which matches the given URL, and return its\r\n     * mock.\r\n     *\r\n     * If no such request has been made, or more than one such request has been made, fail with an\r\n     * error message including the given request description, if any.\r\n     */\r\n    abstract expectOne(url: string, description?: string): TestRequest;\r\n    /**\r\n     * Expect that a single request has been made which matches the given parameters, and return\r\n     * its mock.\r\n     *\r\n     * If no such request has been made, or more than one such request has been made, fail with an\r\n     * error message including the given request description, if any.\r\n     */\r\n    abstract expectOne(params: RequestMatch, description?: string): TestRequest;\r\n    /**\r\n     * Expect that a single request has been made which matches the given predicate function, and\r\n     * return its mock.\r\n     *\r\n     * If no such request has been made, or more than one such request has been made, fail with an\r\n     * error message including the given request description, if any.\r\n     */\r\n    abstract expectOne(matchFn: ((req: HttpRequest<any>) => boolean), description?: string): TestRequest;\r\n    /**\r\n     * Expect that a single request has been made which matches the given condition, and return\r\n     * its mock.\r\n     *\r\n     * If no such request has been made, or more than one such request has been made, fail with an\r\n     * error message including the given request description, if any.\r\n     */\r\n    abstract expectOne(match: string | RequestMatch | ((req: HttpRequest<any>) => boolean), description?: string): TestRequest;\r\n    /**\r\n     * Expect that no requests have been made which match the given URL.\r\n     *\r\n     * If a matching request has been made, fail with an error message including the given request\r\n     * description, if any.\r\n     */\r\n    abstract expectNone(url: string, description?: string): void;\r\n    /**\r\n     * Expect that no requests have been made which match the given parameters.\r\n     *\r\n     * If a matching request has been made, fail with an error message including the given request\r\n     * description, if any.\r\n     */\r\n    abstract expectNone(params: RequestMatch, description?: string): void;\r\n    /**\r\n     * Expect that no requests have been made which match the given predicate function.\r\n     *\r\n     * If a matching request has been made, fail with an error message including the given request\r\n     * description, if any.\r\n     */\r\n    abstract expectNone(matchFn: ((req: HttpRequest<any>) => boolean), description?: string): void;\r\n    /**\r\n     * Expect that no requests have been made which match the given condition.\r\n     *\r\n     * If a matching request has been made, fail with an error message including the given request\r\n     * description, if any.\r\n     */\r\n    abstract expectNone(match: string | RequestMatch | ((req: HttpRequest<any>) => boolean), description?: string): void;\r\n    /**\r\n     * Verify that no unmatched requests are outstanding.\r\n     *\r\n     * If any requests are outstanding, fail with an error message indicating which requests were not\r\n     * handled.\r\n     *\r\n     * If `ignoreCancelled` is not set (the default), `verify()` will also fail if cancelled requests\r\n     * were not explicitly matched.\r\n     */\r\n    abstract verify(opts?: {\r\n        ignoreCancelled?: boolean;\r\n    }): void;\r\n}\r\n\r\n/**\r\n * Defines a matcher for requests based on URL, method, or both.\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface RequestMatch {\r\n    method?: string;\r\n    url?: string;\r\n}\r\n\r\n/**\r\n * A mock requests that was received and is ready to be answered.\r\n *\r\n * This interface allows access to the underlying `HttpRequest`, and allows\r\n * responding with `HttpEvent`s or `HttpErrorResponse`s.\r\n *\r\n * @publicApi\r\n */\r\nexport declare class TestRequest {\r\n    request: HttpRequest<any>;\r\n    private observer;\r\n    /**\r\n     * Whether the request was cancelled after it was sent.\r\n     */\r\n    get cancelled(): boolean;\r\n    constructor(request: HttpRequest<any>, observer: Observer<HttpEvent<any>>);\r\n    /**\r\n     * Resolve the request by returning a body plus additional HTTP information (such as response\r\n     * headers) if provided.\r\n     * If the request specifies an expected body type, the body is converted into the requested type.\r\n     * Otherwise, the body is converted to `JSON` by default.\r\n     *\r\n     * Both successful and unsuccessful responses can be delivered via `flush()`.\r\n     */\r\n    flush(body: ArrayBuffer | Blob | string | number | Object | (string | number | Object | null)[] | null, opts?: {\r\n        headers?: HttpHeaders | {\r\n            [name: string]: string | string[];\r\n        };\r\n        status?: number;\r\n        statusText?: string;\r\n    }): void;\r\n    /**\r\n     * Resolve the request by returning an `ErrorEvent` (e.g. simulating a network failure).\r\n     */\r\n    error(error: ErrorEvent, opts?: {\r\n        headers?: HttpHeaders | {\r\n            [name: string]: string | string[];\r\n        };\r\n        status?: number;\r\n        statusText?: string;\r\n    }): void;\r\n    /**\r\n     * Deliver an arbitrary `HttpEvent` (such as a progress event) on the response stream for this\r\n     * request.\r\n     */\r\n    event(event: HttpEvent<any>): void;\r\n}\r\n\r\n/**\r\n * A testing backend for `HttpClient` which both acts as an `HttpBackend`\r\n * and as the `HttpTestingController`.\r\n *\r\n * `HttpClientTestingBackend` works by keeping a list of all open requests.\r\n * As requests come in, they're added to the list. Users can assert that specific\r\n * requests were made and then flush them. In the end, a verify() method asserts\r\n * that no unexpected requests were made.\r\n *\r\n *\r\n */\r\nexport declare class Éµangular_packages_common_http_testing_testing_a implements HttpBackend, HttpTestingController {\r\n    /**\r\n     * List of pending requests which have not yet been expected.\r\n     */\r\n    private open;\r\n    /**\r\n     * Handle an incoming request by queueing it in the list of open requests.\r\n     */\r\n    handle(req: HttpRequest<any>): Observable<HttpEvent<any>>;\r\n    /**\r\n     * Helper function to search for requests in the list of open requests.\r\n     */\r\n    private _match;\r\n    /**\r\n     * Search for requests in the list of open requests, and return all that match\r\n     * without asserting anything about the number of matches.\r\n     */\r\n    match(match: string | RequestMatch | ((req: HttpRequest<any>) => boolean)): TestRequest[];\r\n    /**\r\n     * Expect that a single outstanding request matches the given matcher, and return\r\n     * it.\r\n     *\r\n     * Requests returned through this API will no longer be in the list of open requests,\r\n     * and thus will not match twice.\r\n     */\r\n    expectOne(match: string | RequestMatch | ((req: HttpRequest<any>) => boolean), description?: string): TestRequest;\r\n    /**\r\n     * Expect that no outstanding requests match the given matcher, and throw an error\r\n     * if any do.\r\n     */\r\n    expectNone(match: string | RequestMatch | ((req: HttpRequest<any>) => boolean), description?: string): void;\r\n    /**\r\n     * Validate that there are no outstanding requests.\r\n     */\r\n    verify(opts?: {\r\n        ignoreCancelled?: boolean;\r\n    }): void;\r\n    private descriptionFromMatcher;\r\n}\r\n\r\nexport { }\r\n"]}
{"version":3,"file":"forms.d.ts","sources":["forms.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Angular v10.0.4\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { AfterViewInit } from '@angular/core';\r\nimport { ElementRef } from '@angular/core';\r\nimport { EventEmitter } from '@angular/core';\r\nimport { InjectionToken } from '@angular/core';\r\nimport { Injector } from '@angular/core';\r\nimport { ModuleWithProviders } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { OnChanges } from '@angular/core';\r\nimport { OnDestroy } from '@angular/core';\r\nimport { OnInit } from '@angular/core';\r\nimport { Renderer2 } from '@angular/core';\r\nimport { SimpleChanges } from '@angular/core';\r\nimport { StaticProvider } from '@angular/core';\r\nimport { Type } from '@angular/core';\r\nimport { Version } from '@angular/core';\r\n\r\n/**\r\n * This is the base class for `FormControl`, `FormGroup`, and `FormArray`.\r\n *\r\n * It provides some of the shared behavior that all controls and groups of controls have, like\r\n * running validators, calculating status, and resetting state. It also defines the properties\r\n * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be\r\n * instantiated directly.\r\n *\r\n * @see [Forms Guide](/guide/forms)\r\n * @see [Reactive Forms Guide](/guide/reactive-forms)\r\n * @see [Dynamic Forms Guide](/guide/dynamic-form)\r\n *\r\n * @publicApi\r\n */\r\nexport declare abstract class AbstractControl {\r\n    validator: ValidatorFn | null;\r\n    asyncValidator: AsyncValidatorFn | null;\r\n    private _parent;\r\n    private _asyncValidationSubscription;\r\n    /**\r\n     * The current value of the control.\r\n     *\r\n     * * For a `FormControl`, the current value.\r\n     * * For an enabled `FormGroup`, the values of enabled controls as an object\r\n     * with a key-value pair for each member of the group.\r\n     * * For a disabled `FormGroup`, the values of all controls as an object\r\n     * with a key-value pair for each member of the group.\r\n     * * For a `FormArray`, the values of enabled controls as an array.\r\n     *\r\n     */\r\n    readonly value: any;\r\n    /**\r\n     * Initialize the AbstractControl instance.\r\n     *\r\n     * @param validator The function that determines the synchronous validity of this control.\r\n     * @param asyncValidator The function that determines the asynchronous validity of this\r\n     * control.\r\n     */\r\n    constructor(validator: ValidatorFn | null, asyncValidator: AsyncValidatorFn | null);\r\n    /**\r\n     * The parent control.\r\n     */\r\n    get parent(): FormGroup | FormArray;\r\n    /**\r\n     * The validation status of the control. There are four possible\r\n     * validation status values:\r\n     *\r\n     * * **VALID**: This control has passed all validation checks.\r\n     * * **INVALID**: This control has failed at least one validation check.\r\n     * * **PENDING**: This control is in the midst of conducting a validation check.\r\n     * * **DISABLED**: This control is exempt from validation checks.\r\n     *\r\n     * These status values are mutually exclusive, so a control cannot be\r\n     * both valid AND invalid or invalid AND disabled.\r\n     */\r\n    readonly status: string;\r\n    /**\r\n     * A control is `valid` when its `status` is `VALID`.\r\n     *\r\n     * @see {@link AbstractControl.status}\r\n     *\r\n     * @returns True if the control has passed all of its validation tests,\r\n     * false otherwise.\r\n     */\r\n    get valid(): boolean;\r\n    /**\r\n     * A control is `invalid` when its `status` is `INVALID`.\r\n     *\r\n     * @see {@link AbstractControl.status}\r\n     *\r\n     * @returns True if this control has failed one or more of its validation checks,\r\n     * false otherwise.\r\n     */\r\n    get invalid(): boolean;\r\n    /**\r\n     * A control is `pending` when its `status` is `PENDING`.\r\n     *\r\n     * @see {@link AbstractControl.status}\r\n     *\r\n     * @returns True if this control is in the process of conducting a validation check,\r\n     * false otherwise.\r\n     */\r\n    get pending(): boolean;\r\n    /**\r\n     * A control is `disabled` when its `status` is `DISABLED`.\r\n     *\r\n     * Disabled controls are exempt from validation checks and\r\n     * are not included in the aggregate value of their ancestor\r\n     * controls.\r\n     *\r\n     * @see {@link AbstractControl.status}\r\n     *\r\n     * @returns True if the control is disabled, false otherwise.\r\n     */\r\n    get disabled(): boolean;\r\n    /**\r\n     * A control is `enabled` as long as its `status` is not `DISABLED`.\r\n     *\r\n     * @returns True if the control has any status other than 'DISABLED',\r\n     * false if the status is 'DISABLED'.\r\n     *\r\n     * @see {@link AbstractControl.status}\r\n     *\r\n     */\r\n    get enabled(): boolean;\r\n    /**\r\n     * An object containing any errors generated by failing validation,\r\n     * or null if there are no errors.\r\n     */\r\n    readonly errors: ValidationErrors | null;\r\n    /**\r\n     * A control is `pristine` if the user has not yet changed\r\n     * the value in the UI.\r\n     *\r\n     * @returns True if the user has not yet changed the value in the UI; compare `dirty`.\r\n     * Programmatic changes to a control's value do not mark it dirty.\r\n     */\r\n    readonly pristine: boolean;\r\n    /**\r\n     * A control is `dirty` if the user has changed the value\r\n     * in the UI.\r\n     *\r\n     * @returns True if the user has changed the value of this control in the UI; compare `pristine`.\r\n     * Programmatic changes to a control's value do not mark it dirty.\r\n     */\r\n    get dirty(): boolean;\r\n    /**\r\n     * True if the control is marked as `touched`.\r\n     *\r\n     * A control is marked `touched` once the user has triggered\r\n     * a `blur` event on it.\r\n     */\r\n    readonly touched: boolean;\r\n    /**\r\n     * True if the control has not been marked as touched\r\n     *\r\n     * A control is `untouched` if the user has not yet triggered\r\n     * a `blur` event on it.\r\n     */\r\n    get untouched(): boolean;\r\n    /**\r\n     * A multicasting observable that emits an event every time the value of the control changes, in\r\n     * the UI or programmatically. It also emits an event each time you call enable() or disable()\r\n     * without passing along {emitEvent: false} as a function argument.\r\n     */\r\n    readonly valueChanges: Observable<any>;\r\n    /**\r\n     * A multicasting observable that emits an event every time the validation `status` of the control\r\n     * recalculates.\r\n     *\r\n     * @see {@link AbstractControl.status}\r\n     *\r\n     */\r\n    readonly statusChanges: Observable<any>;\r\n    /**\r\n     * Reports the update strategy of the `AbstractControl` (meaning\r\n     * the event on which the control updates itself).\r\n     * Possible values: `'change'` | `'blur'` | `'submit'`\r\n     * Default value: `'change'`\r\n     */\r\n    get updateOn(): FormHooks;\r\n    /**\r\n     * Sets the synchronous validators that are active on this control.  Calling\r\n     * this overwrites any existing sync validators.\r\n     *\r\n     * When you add or remove a validator at run time, you must call\r\n     * `updateValueAndValidity()` for the new validation to take effect.\r\n     *\r\n     */\r\n    setValidators(newValidator: ValidatorFn | ValidatorFn[] | null): void;\r\n    /**\r\n     * Sets the async validators that are active on this control. Calling this\r\n     * overwrites any existing async validators.\r\n     *\r\n     * When you add or remove a validator at run time, you must call\r\n     * `updateValueAndValidity()` for the new validation to take effect.\r\n     *\r\n     */\r\n    setAsyncValidators(newValidator: AsyncValidatorFn | AsyncValidatorFn[] | null): void;\r\n    /**\r\n     * Empties out the sync validator list.\r\n     *\r\n     * When you add or remove a validator at run time, you must call\r\n     * `updateValueAndValidity()` for the new validation to take effect.\r\n     *\r\n     */\r\n    clearValidators(): void;\r\n    /**\r\n     * Empties out the async validator list.\r\n     *\r\n     * When you add or remove a validator at run time, you must call\r\n     * `updateValueAndValidity()` for the new validation to take effect.\r\n     *\r\n     */\r\n    clearAsyncValidators(): void;\r\n    /**\r\n     * Marks the control as `touched`. A control is touched by focus and\r\n     * blur events that do not change the value.\r\n     *\r\n     * @see `markAsUntouched()`\r\n     * @see `markAsDirty()`\r\n     * @see `markAsPristine()`\r\n     *\r\n     * @param opts Configuration options that determine how the control propagates changes\r\n     * and emits events after marking is applied.\r\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\r\n     * marks all direct ancestors. Default is false.\r\n     */\r\n    markAsTouched(opts?: {\r\n        onlySelf?: boolean;\r\n    }): void;\r\n    /**\r\n     * Marks the control and all its descendant controls as `touched`.\r\n     * @see `markAsTouched()`\r\n     */\r\n    markAllAsTouched(): void;\r\n    /**\r\n     * Marks the control as `untouched`.\r\n     *\r\n     * If the control has any children, also marks all children as `untouched`\r\n     * and recalculates the `touched` status of all parent controls.\r\n     *\r\n     * @see `markAsTouched()`\r\n     * @see `markAsDirty()`\r\n     * @see `markAsPristine()`\r\n     *\r\n     * @param opts Configuration options that determine how the control propagates changes\r\n     * and emits events after the marking is applied.\r\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\r\n     * marks all direct ancestors. Default is false.\r\n     */\r\n    markAsUntouched(opts?: {\r\n        onlySelf?: boolean;\r\n    }): void;\r\n    /**\r\n     * Marks the control as `dirty`. A control becomes dirty when\r\n     * the control's value is changed through the UI; compare `markAsTouched`.\r\n     *\r\n     * @see `markAsTouched()`\r\n     * @see `markAsUntouched()`\r\n     * @see `markAsPristine()`\r\n     *\r\n     * @param opts Configuration options that determine how the control propagates changes\r\n     * and emits events after marking is applied.\r\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\r\n     * marks all direct ancestors. Default is false.\r\n     */\r\n    markAsDirty(opts?: {\r\n        onlySelf?: boolean;\r\n    }): void;\r\n    /**\r\n     * Marks the control as `pristine`.\r\n     *\r\n     * If the control has any children, marks all children as `pristine`,\r\n     * and recalculates the `pristine` status of all parent\r\n     * controls.\r\n     *\r\n     * @see `markAsTouched()`\r\n     * @see `markAsUntouched()`\r\n     * @see `markAsDirty()`\r\n     *\r\n     * @param opts Configuration options that determine how the control emits events after\r\n     * marking is applied.\r\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\r\n     * marks all direct ancestors. Default is false.\r\n     */\r\n    markAsPristine(opts?: {\r\n        onlySelf?: boolean;\r\n    }): void;\r\n    /**\r\n     * Marks the control as `pending`.\r\n     *\r\n     * A control is pending while the control performs async validation.\r\n     *\r\n     * @see {@link AbstractControl.status}\r\n     *\r\n     * @param opts Configuration options that determine how the control propagates changes and\r\n     * emits events after marking is applied.\r\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\r\n     * marks all direct ancestors. Default is false.\r\n     * * `emitEvent`: When true or not supplied (the default), the `statusChanges`\r\n     * observable emits an event with the latest status the control is marked pending.\r\n     * When false, no events are emitted.\r\n     *\r\n     */\r\n    markAsPending(opts?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Disables the control. This means the control is exempt from validation checks and\r\n     * excluded from the aggregate value of any parent. Its status is `DISABLED`.\r\n     *\r\n     * If the control has children, all children are also disabled.\r\n     *\r\n     * @see {@link AbstractControl.status}\r\n     *\r\n     * @param opts Configuration options that determine how the control propagates\r\n     * changes and emits events after the control is disabled.\r\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\r\n     * marks all direct ancestors. Default is false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control is disabled.\r\n     * When false, no events are emitted.\r\n     */\r\n    disable(opts?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Enables the control. This means the control is included in validation checks and\r\n     * the aggregate value of its parent. Its status recalculates based on its value and\r\n     * its validators.\r\n     *\r\n     * By default, if the control has children, all children are enabled.\r\n     *\r\n     * @see {@link AbstractControl.status}\r\n     *\r\n     * @param opts Configure options that control how the control propagates changes and\r\n     * emits events when marked as untouched\r\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\r\n     * marks all direct ancestors. Default is false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control is enabled.\r\n     * When false, no events are emitted.\r\n     */\r\n    enable(opts?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    private _updateAncestors;\r\n    /**\r\n     * @param parent Sets the parent of the control\r\n     */\r\n    setParent(parent: FormGroup | FormArray): void;\r\n    /**\r\n     * Sets the value of the control. Abstract method (implemented in sub-classes).\r\n     */\r\n    abstract setValue(value: any, options?: Object): void;\r\n    /**\r\n     * Patches the value of the control. Abstract method (implemented in sub-classes).\r\n     */\r\n    abstract patchValue(value: any, options?: Object): void;\r\n    /**\r\n     * Resets the control. Abstract method (implemented in sub-classes).\r\n     */\r\n    abstract reset(value?: any, options?: Object): void;\r\n    /**\r\n     * Recalculates the value and validation status of the control.\r\n     *\r\n     * By default, it also updates the value and validity of its ancestors.\r\n     *\r\n     * @param opts Configuration options determine how the control propagates changes and emits events\r\n     * after updates and validity checks are applied.\r\n     * * `onlySelf`: When true, only update this control. When false or not supplied,\r\n     * update all direct ancestors. Default is false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control is updated.\r\n     * When false, no events are emitted.\r\n     */\r\n    updateValueAndValidity(opts?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    private _setInitialStatus;\r\n    private _runValidator;\r\n    private _runAsyncValidator;\r\n    private _cancelExistingSubscription;\r\n    /**\r\n     * Sets errors on a form control when running validations manually, rather than automatically.\r\n     *\r\n     * Calling `setErrors` also updates the validity of the parent control.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Manually set the errors for a control\r\n     *\r\n     * ```\r\n     * const login = new FormControl('someLogin');\r\n     * login.setErrors({\r\n     *   notUnique: true\r\n     * });\r\n     *\r\n     * expect(login.valid).toEqual(false);\r\n     * expect(login.errors).toEqual({ notUnique: true });\r\n     *\r\n     * login.setValue('someOtherLogin');\r\n     *\r\n     * expect(login.valid).toEqual(true);\r\n     * ```\r\n     */\r\n    setErrors(errors: ValidationErrors | null, opts?: {\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Retrieves a child control given the control's name or path.\r\n     *\r\n     * @param path A dot-delimited string or array of string/number values that define the path to the\r\n     * control.\r\n     *\r\n     * @usageNotes\r\n     * ### Retrieve a nested control\r\n     *\r\n     * For example, to get a `name` control nested within a `person` sub-group:\r\n     *\r\n     * * `this.form.get('person.name');`\r\n     *\r\n     * -OR-\r\n     *\r\n     * * `this.form.get(['person', 'name']);`\r\n     */\r\n    get(path: Array<string | number> | string): AbstractControl | null;\r\n    /**\r\n     * @description\r\n     * Reports error data for the control with the given path.\r\n     *\r\n     * @param errorCode The code of the error to check\r\n     * @param path A list of control names that designates how to move from the current control\r\n     * to the control that should be queried for errors.\r\n     *\r\n     * @usageNotes\r\n     * For example, for the following `FormGroup`:\r\n     *\r\n     * ```\r\n     * form = new FormGroup({\r\n     *   address: new FormGroup({ street: new FormControl() })\r\n     * });\r\n     * ```\r\n     *\r\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\r\n     *\r\n     * It can be provided to this method in one of two formats:\r\n     *\r\n     * 1. An array of string control names, e.g. `['address', 'street']`\r\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\r\n     *\r\n     * @returns error data for that particular error. If the control or error is not present,\r\n     * null is returned.\r\n     */\r\n    getError(errorCode: string, path?: Array<string | number> | string): any;\r\n    /**\r\n     * @description\r\n     * Reports whether the control with the given path has the error specified.\r\n     *\r\n     * @param errorCode The code of the error to check\r\n     * @param path A list of control names that designates how to move from the current control\r\n     * to the control that should be queried for errors.\r\n     *\r\n     * @usageNotes\r\n     * For example, for the following `FormGroup`:\r\n     *\r\n     * ```\r\n     * form = new FormGroup({\r\n     *   address: new FormGroup({ street: new FormControl() })\r\n     * });\r\n     * ```\r\n     *\r\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\r\n     *\r\n     * It can be provided to this method in one of two formats:\r\n     *\r\n     * 1. An array of string control names, e.g. `['address', 'street']`\r\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\r\n     *\r\n     * If no path is given, this method checks for the error on the current control.\r\n     *\r\n     * @returns whether the given error is present in the control at the given path.\r\n     *\r\n     * If the control is not present, false is returned.\r\n     */\r\n    hasError(errorCode: string, path?: Array<string | number> | string): boolean;\r\n    /**\r\n     * Retrieves the top-level ancestor of this control.\r\n     */\r\n    get root(): AbstractControl;\r\n    private _calculateStatus;\r\n}\r\n\r\n/**\r\n * @description\r\n * Base class for control directives.\r\n *\r\n * This class is only used internally in the `ReactiveFormsModule` and the `FormsModule`.\r\n *\r\n * @publicApi\r\n */\r\nexport declare abstract class AbstractControlDirective {\r\n    /**\r\n     * @description\r\n     * A reference to the underlying control.\r\n     *\r\n     * @returns the control that backs this directive. Most properties fall through to that instance.\r\n     */\r\n    abstract get control(): AbstractControl | null;\r\n    /**\r\n     * @description\r\n     * Reports the value of the control if it is present, otherwise null.\r\n     */\r\n    get value(): any;\r\n    /**\r\n     * @description\r\n     * Reports whether the control is valid. A control is considered valid if no\r\n     * validation errors exist with the current value.\r\n     * If the control is not present, null is returned.\r\n     */\r\n    get valid(): boolean | null;\r\n    /**\r\n     * @description\r\n     * Reports whether the control is invalid, meaning that an error exists in the input value.\r\n     * If the control is not present, null is returned.\r\n     */\r\n    get invalid(): boolean | null;\r\n    /**\r\n     * @description\r\n     * Reports whether a control is pending, meaning that that async validation is occurring and\r\n     * errors are not yet available for the input value. If the control is not present, null is\r\n     * returned.\r\n     */\r\n    get pending(): boolean | null;\r\n    /**\r\n     * @description\r\n     * Reports whether the control is disabled, meaning that the control is disabled\r\n     * in the UI and is exempt from validation checks and excluded from aggregate\r\n     * values of ancestor controls. If the control is not present, null is returned.\r\n     */\r\n    get disabled(): boolean | null;\r\n    /**\r\n     * @description\r\n     * Reports whether the control is enabled, meaning that the control is included in ancestor\r\n     * calculations of validity or value. If the control is not present, null is returned.\r\n     */\r\n    get enabled(): boolean | null;\r\n    /**\r\n     * @description\r\n     * Reports the control's validation errors. If the control is not present, null is returned.\r\n     */\r\n    get errors(): ValidationErrors | null;\r\n    /**\r\n     * @description\r\n     * Reports whether the control is pristine, meaning that the user has not yet changed\r\n     * the value in the UI. If the control is not present, null is returned.\r\n     */\r\n    get pristine(): boolean | null;\r\n    /**\r\n     * @description\r\n     * Reports whether the control is dirty, meaning that the user has changed\r\n     * the value in the UI. If the control is not present, null is returned.\r\n     */\r\n    get dirty(): boolean | null;\r\n    /**\r\n     * @description\r\n     * Reports whether the control is touched, meaning that the user has triggered\r\n     * a `blur` event on it. If the control is not present, null is returned.\r\n     */\r\n    get touched(): boolean | null;\r\n    /**\r\n     * @description\r\n     * Reports the validation status of the control. Possible values include:\r\n     * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.\r\n     * If the control is not present, null is returned.\r\n     */\r\n    get status(): string | null;\r\n    /**\r\n     * @description\r\n     * Reports whether the control is untouched, meaning that the user has not yet triggered\r\n     * a `blur` event on it. If the control is not present, null is returned.\r\n     */\r\n    get untouched(): boolean | null;\r\n    /**\r\n     * @description\r\n     * Returns a multicasting observable that emits a validation status whenever it is\r\n     * calculated for the control. If the control is not present, null is returned.\r\n     */\r\n    get statusChanges(): Observable<any> | null;\r\n    /**\r\n     * @description\r\n     * Returns a multicasting observable of value changes for the control that emits every time the\r\n     * value of the control changes in the UI or programmatically.\r\n     * If the control is not present, null is returned.\r\n     */\r\n    get valueChanges(): Observable<any> | null;\r\n    /**\r\n     * @description\r\n     * Returns an array that represents the path from the top-level form to this control.\r\n     * Each index is the string name of the control on that level.\r\n     */\r\n    get path(): string[] | null;\r\n    /**\r\n     * @description\r\n     * Resets the control with the provided value if the control is present.\r\n     */\r\n    reset(value?: any): void;\r\n    /**\r\n     * @description\r\n     * Reports whether the control with the given path has the error specified.\r\n     *\r\n     * @param errorCode The code of the error to check\r\n     * @param path A list of control names that designates how to move from the current control\r\n     * to the control that should be queried for errors.\r\n     *\r\n     * @usageNotes\r\n     * For example, for the following `FormGroup`:\r\n     *\r\n     * ```\r\n     * form = new FormGroup({\r\n     *   address: new FormGroup({ street: new FormControl() })\r\n     * });\r\n     * ```\r\n     *\r\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\r\n     *\r\n     * It can be provided to this method in one of two formats:\r\n     *\r\n     * 1. An array of string control names, e.g. `['address', 'street']`\r\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\r\n     *\r\n     * If no path is given, this method checks for the error on the current control.\r\n     *\r\n     * @returns whether the given error is present in the control at the given path.\r\n     *\r\n     * If the control is not present, false is returned.\r\n     */\r\n    hasError(errorCode: string, path?: Array<string | number> | string): boolean;\r\n    /**\r\n     * @description\r\n     * Reports error data for the control with the given path.\r\n     *\r\n     * @param errorCode The code of the error to check\r\n     * @param path A list of control names that designates how to move from the current control\r\n     * to the control that should be queried for errors.\r\n     *\r\n     * @usageNotes\r\n     * For example, for the following `FormGroup`:\r\n     *\r\n     * ```\r\n     * form = new FormGroup({\r\n     *   address: new FormGroup({ street: new FormControl() })\r\n     * });\r\n     * ```\r\n     *\r\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\r\n     *\r\n     * It can be provided to this method in one of two formats:\r\n     *\r\n     * 1. An array of string control names, e.g. `['address', 'street']`\r\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\r\n     *\r\n     * @returns error data for that particular error. If the control or error is not present,\r\n     * null is returned.\r\n     */\r\n    getError(errorCode: string, path?: Array<string | number> | string): any;\r\n}\r\n\r\n/**\r\n * Interface for options provided to an `AbstractControl`.\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface AbstractControlOptions {\r\n    /**\r\n     * @description\r\n     * The list of validators applied to a control.\r\n     */\r\n    validators?: ValidatorFn | ValidatorFn[] | null;\r\n    /**\r\n     * @description\r\n     * The list of async validators applied to control.\r\n     */\r\n    asyncValidators?: AsyncValidatorFn | AsyncValidatorFn[] | null;\r\n    /**\r\n     * @description\r\n     * The event name for control to update upon.\r\n     */\r\n    updateOn?: 'change' | 'blur' | 'submit';\r\n}\r\n\r\n/**\r\n * @description\r\n * A base class for code shared between the `NgModelGroup` and `FormGroupName` directives.\r\n *\r\n * @publicApi\r\n */\r\nexport declare class AbstractFormGroupDirective extends ControlContainer implements OnInit, OnDestroy {\r\n    /**\r\n     * @description\r\n     * An internal callback method triggered on the instance after the inputs are set.\r\n     * Registers the group with its parent group.\r\n     */\r\n    ngOnInit(): void;\r\n    /**\r\n     * @description\r\n     * An internal callback method triggered before the instance is destroyed.\r\n     * Removes the group from its parent group.\r\n     */\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * @description\r\n     * The `FormGroup` bound to this directive.\r\n     */\r\n    get control(): FormGroup;\r\n    /**\r\n     * @description\r\n     * The path to this group from the top-level directive.\r\n     */\r\n    get path(): string[];\r\n    /**\r\n     * @description\r\n     * The top-level directive for this group if present, otherwise null.\r\n     */\r\n    get formDirective(): Form | null;\r\n    /**\r\n     * @description\r\n     * The synchronous validators registered with this group.\r\n     */\r\n    get validator(): ValidatorFn | null;\r\n    /**\r\n     * @description\r\n     * The async validators registered with this group.\r\n     */\r\n    get asyncValidator(): AsyncValidatorFn | null;\r\n}\r\n\r\n/**\r\n * @description\r\n * An interface implemented by classes that perform asynchronous validation.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Provide a custom async validator directive\r\n *\r\n * The following example implements the `AsyncValidator` interface to create an\r\n * async validator directive with a custom error key.\r\n *\r\n * ```typescript\r\n * import { of } from 'rxjs';\r\n *\r\n * @Directive({\r\n *   selector: '[customAsyncValidator]',\r\n *   providers: [{provide: NG_ASYNC_VALIDATORS, useExisting: CustomAsyncValidatorDirective, multi:\r\n * true}]\r\n * })\r\n * class CustomAsyncValidatorDirective implements AsyncValidator {\r\n *   validate(control: AbstractControl): Observable<ValidationErrors|null> {\r\n *     return of({'custom': true});\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface AsyncValidator extends Validator {\r\n    /**\r\n     * @description\r\n     * Method that performs async validation against the provided control.\r\n     *\r\n     * @param control The control to validate against.\r\n     *\r\n     * @returns A promise or observable that resolves a map of validation errors\r\n     * if validation fails, otherwise null.\r\n     */\r\n    validate(control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null>;\r\n}\r\n\r\n/**\r\n * @description\r\n * A function that receives a control and returns a Promise or observable\r\n * that emits validation errors if present, otherwise null.\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface AsyncValidatorFn {\r\n    (control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null>;\r\n}\r\n\r\n/**\r\n * @description\r\n * A `ControlValueAccessor` for writing a value and listening to changes on a checkbox input\r\n * element.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Using a checkbox with a reactive form.\r\n *\r\n * The following example shows how to use a checkbox with a reactive form.\r\n *\r\n * ```ts\r\n * const rememberLoginControl = new FormControl();\r\n * ```\r\n *\r\n * ```\r\n * <input type=\"checkbox\" [formControl]=\"rememberLoginControl\">\r\n * ```\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class CheckboxControlValueAccessor implements ControlValueAccessor {\r\n    private _renderer;\r\n    private _elementRef;\r\n    /**\r\n     * @description\r\n     * The registered callback function called when a change event occurs on the input element.\r\n     */\r\n    onChange: (_: any) => void;\r\n    /**\r\n     * @description\r\n     * The registered callback function called when a blur event occurs on the input element.\r\n     */\r\n    onTouched: () => void;\r\n    constructor(_renderer: Renderer2, _elementRef: ElementRef);\r\n    /**\r\n     * Sets the \"checked\" property on the input element.\r\n     *\r\n     * @param value The checked value\r\n     */\r\n    writeValue(value: any): void;\r\n    /**\r\n     * @description\r\n     * Registers a function called when the control value changes.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnChange(fn: (_: any) => {}): void;\r\n    /**\r\n     * @description\r\n     * Registers a function called when the control is touched.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnTouched(fn: () => {}): void;\r\n    /**\r\n     * Sets the \"disabled\" property on the input element.\r\n     *\r\n     * @param isDisabled The disabled value\r\n     */\r\n    setDisabledState(isDisabled: boolean): void;\r\n}\r\n\r\n/**\r\n * A Directive that adds the `required` validator to checkbox controls marked with the\r\n * `required` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\r\n *\r\n * @see [Form Validation](guide/form-validation)\r\n *\r\n * @usageNotes\r\n *\r\n * ### Adding a required checkbox validator using template-driven forms\r\n *\r\n * The following example shows how to add a checkbox required validator to an input attached to an\r\n * ngModel binding.\r\n *\r\n * ```\r\n * <input type=\"checkbox\" name=\"active\" ngModel required>\r\n * ```\r\n *\r\n * @publicApi\r\n * @ngModule FormsModule\r\n * @ngModule ReactiveFormsModule\r\n */\r\nexport declare class CheckboxRequiredValidator extends RequiredValidator {\r\n    /**\r\n     * @description\r\n     * Method that validates whether or not the checkbox has been checked.\r\n     * Returns the validation result if enabled, otherwise null.\r\n     */\r\n    validate(control: AbstractControl): ValidationErrors | null;\r\n}\r\n\r\n/**\r\n * @description\r\n * Provide this token to control if form directives buffer IME input until\r\n * the \"compositionend\" event occurs.\r\n * @publicApi\r\n */\r\nexport declare const COMPOSITION_BUFFER_MODE: InjectionToken<boolean>;\r\n\r\n/**\r\n * @description\r\n * A base class for directives that contain multiple registered instances of `NgControl`.\r\n * Only used by the forms module.\r\n *\r\n * @publicApi\r\n */\r\nexport declare abstract class ControlContainer extends AbstractControlDirective {\r\n    /**\r\n     * @description\r\n     * The name for the control\r\n     */\r\n    name: string | number | null;\r\n    /**\r\n     * @description\r\n     * The top-level form directive for the control.\r\n     */\r\n    get formDirective(): Form | null;\r\n    /**\r\n     * @description\r\n     * The path to this group.\r\n     */\r\n    get path(): string[] | null;\r\n}\r\n\r\n/**\r\n * @description\r\n * Defines an interface that acts as a bridge between the Angular forms API and a\r\n * native element in the DOM.\r\n *\r\n * Implement this interface to create a custom form control directive\r\n * that integrates with Angular forms.\r\n *\r\n * @see DefaultValueAccessor\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface ControlValueAccessor {\r\n    /**\r\n     * @description\r\n     * Writes a new value to the element.\r\n     *\r\n     * This method is called by the forms API to write to the view when programmatic\r\n     * changes from model to view are requested.\r\n     *\r\n     * @usageNotes\r\n     * ### Write a value to the element\r\n     *\r\n     * The following example writes a value to the native DOM element.\r\n     *\r\n     * ```ts\r\n     * writeValue(value: any): void {\r\n     *   this._renderer.setProperty(this._elementRef.nativeElement, 'value', value);\r\n     * }\r\n     * ```\r\n     *\r\n     * @param obj The new value for the element\r\n     */\r\n    writeValue(obj: any): void;\r\n    /**\r\n     * @description\r\n     * Registers a callback function that is called when the control's value\r\n     * changes in the UI.\r\n     *\r\n     * This method is called by the forms API on initialization to update the form\r\n     * model when values propagate from the view to the model.\r\n     *\r\n     * When implementing the `registerOnChange` method in your own value accessor,\r\n     * save the given function so your class calls it at the appropriate time.\r\n     *\r\n     * @usageNotes\r\n     * ### Store the change function\r\n     *\r\n     * The following example stores the provided function as an internal method.\r\n     *\r\n     * ```ts\r\n     * registerOnChange(fn: (_: any) => void): void {\r\n     *   this._onChange = fn;\r\n     * }\r\n     * ```\r\n     *\r\n     * When the value changes in the UI, call the registered\r\n     * function to allow the forms API to update itself:\r\n     *\r\n     * ```ts\r\n     * host: {\r\n     *    '(change)': '_onChange($event.target.value)'\r\n     * }\r\n     * ```\r\n     *\r\n     * @param fn The callback function to register\r\n     */\r\n    registerOnChange(fn: any): void;\r\n    /**\r\n     * @description\r\n     * Registers a callback function that is called by the forms API on initialization\r\n     * to update the form model on blur.\r\n     *\r\n     * When implementing `registerOnTouched` in your own value accessor, save the given\r\n     * function so your class calls it when the control should be considered\r\n     * blurred or \"touched\".\r\n     *\r\n     * @usageNotes\r\n     * ### Store the callback function\r\n     *\r\n     * The following example stores the provided function as an internal method.\r\n     *\r\n     * ```ts\r\n     * registerOnTouched(fn: any): void {\r\n     *   this._onTouched = fn;\r\n     * }\r\n     * ```\r\n     *\r\n     * On blur (or equivalent), your class should call the registered function to allow\r\n     * the forms API to update itself:\r\n     *\r\n     * ```ts\r\n     * host: {\r\n     *    '(blur)': '_onTouched()'\r\n     * }\r\n     * ```\r\n     *\r\n     * @param fn The callback function to register\r\n     */\r\n    registerOnTouched(fn: any): void;\r\n    /**\r\n     * @description\r\n     * Function that is called by the forms API when the control status changes to\r\n     * or from 'DISABLED'. Depending on the status, it enables or disables the\r\n     * appropriate DOM element.\r\n     *\r\n     * @usageNotes\r\n     * The following is an example of writing the disabled property to a native DOM element:\r\n     *\r\n     * ```ts\r\n     * setDisabledState(isDisabled: boolean): void {\r\n     *   this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\r\n     * }\r\n     * ```\r\n     *\r\n     * @param isDisabled The disabled status to set on the element\r\n     */\r\n    setDisabledState?(isDisabled: boolean): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * The default `ControlValueAccessor` for writing a value and listening to changes on input\r\n * elements. The accessor is used by the `FormControlDirective`, `FormControlName`, and\r\n * `NgModel` directives.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Using the default value accessor\r\n *\r\n * The following example shows how to use an input element that activates the default value accessor\r\n * (in this case, a text field).\r\n *\r\n * ```ts\r\n * const firstNameControl = new FormControl();\r\n * ```\r\n *\r\n * ```\r\n * <input type=\"text\" [formControl]=\"firstNameControl\">\r\n * ```\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class DefaultValueAccessor implements ControlValueAccessor {\r\n    private _renderer;\r\n    private _elementRef;\r\n    private _compositionMode;\r\n    /**\r\n     * @description\r\n     * The registered callback function called when an input event occurs on the input element.\r\n     */\r\n    onChange: (_: any) => void;\r\n    /**\r\n     * @description\r\n     * The registered callback function called when a blur event occurs on the input element.\r\n     */\r\n    onTouched: () => void;\r\n    /** Whether the user is creating a composition string (IME events). */\r\n    private _composing;\r\n    constructor(_renderer: Renderer2, _elementRef: ElementRef, _compositionMode: boolean);\r\n    /**\r\n     * Sets the \"value\" property on the input element.\r\n     *\r\n     * @param value The checked value\r\n     */\r\n    writeValue(value: any): void;\r\n    /**\r\n     * @description\r\n     * Registers a function called when the control value changes.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnChange(fn: (_: any) => void): void;\r\n    /**\r\n     * @description\r\n     * Registers a function called when the control is touched.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnTouched(fn: () => void): void;\r\n    /**\r\n     * Sets the \"disabled\" property on the input element.\r\n     *\r\n     * @param isDisabled The disabled value\r\n     */\r\n    setDisabledState(isDisabled: boolean): void;\r\n}\r\n\r\n/**\r\n * A directive that adds the `email` validator to controls marked with the\r\n * `email` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\r\n *\r\n * @see [Form Validation](guide/form-validation)\r\n *\r\n * @usageNotes\r\n *\r\n * ### Adding an email validator\r\n *\r\n * The following example shows how to add an email validator to an input attached to an ngModel\r\n * binding.\r\n *\r\n * ```\r\n * <input type=\"email\" name=\"email\" ngModel email>\r\n * <input type=\"email\" name=\"email\" ngModel email=\"true\">\r\n * <input type=\"email\" name=\"email\" ngModel [email]=\"true\">\r\n * ```\r\n *\r\n * @publicApi\r\n * @ngModule FormsModule\r\n * @ngModule ReactiveFormsModule\r\n */\r\nexport declare class EmailValidator implements Validator {\r\n    private _enabled;\r\n    private _onChange?;\r\n    /**\r\n     * @description\r\n     * Tracks changes to the email attribute bound to this directive.\r\n     */\r\n    set email(value: boolean | string);\r\n    /**\r\n     * @description\r\n     * Method that validates whether an email address is valid.\r\n     * Returns the validation result if enabled, otherwise null.\r\n     */\r\n    validate(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * @description\r\n     * Registers a callback function to call when the validator inputs change.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnValidatorChange(fn: () => void): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * An interface implemented by `FormGroupDirective` and `NgForm` directives.\r\n *\r\n * Only used by the `ReactiveFormsModule` and `FormsModule`.\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface Form {\r\n    /**\r\n     * @description\r\n     * Add a control to this form.\r\n     *\r\n     * @param dir The control directive to add to the form.\r\n     */\r\n    addControl(dir: NgControl): void;\r\n    /**\r\n     * @description\r\n     * Remove a control from this form.\r\n     *\r\n     * @param dir: The control directive to remove from the form.\r\n     */\r\n    removeControl(dir: NgControl): void;\r\n    /**\r\n     * @description\r\n     * The control directive from which to get the `FormControl`.\r\n     *\r\n     * @param dir: The control directive.\r\n     */\r\n    getControl(dir: NgControl): FormControl;\r\n    /**\r\n     * @description\r\n     * Add a group of controls to this form.\r\n     *\r\n     * @param dir: The control group directive to add.\r\n     */\r\n    addFormGroup(dir: AbstractFormGroupDirective): void;\r\n    /**\r\n     * @description\r\n     * Remove a group of controls to this form.\r\n     *\r\n     * @param dir: The control group directive to remove.\r\n     */\r\n    removeFormGroup(dir: AbstractFormGroupDirective): void;\r\n    /**\r\n     * @description\r\n     * The `FormGroup` associated with a particular `AbstractFormGroupDirective`.\r\n     *\r\n     * @param dir: The form group directive from which to get the `FormGroup`.\r\n     */\r\n    getFormGroup(dir: AbstractFormGroupDirective): FormGroup;\r\n    /**\r\n     * @description\r\n     * Update the model for a particular control with a new value.\r\n     *\r\n     * @param dir: The control directive to update.\r\n     * @param value: The new value for the control.\r\n     */\r\n    updateModel(dir: NgControl, value: any): void;\r\n}\r\n\r\n/**\r\n * Tracks the value and validity state of an array of `FormControl`,\r\n * `FormGroup` or `FormArray` instances.\r\n *\r\n * A `FormArray` aggregates the values of each child `FormControl` into an array.\r\n * It calculates its status by reducing the status values of its children. For example, if one of\r\n * the controls in a `FormArray` is invalid, the entire array becomes invalid.\r\n *\r\n * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,\r\n * along with `FormControl` and `FormGroup`.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Create an array of form controls\r\n *\r\n * ```\r\n * const arr = new FormArray([\r\n *   new FormControl('Nancy', Validators.minLength(2)),\r\n *   new FormControl('Drew'),\r\n * ]);\r\n *\r\n * console.log(arr.value);   // ['Nancy', 'Drew']\r\n * console.log(arr.status);  // 'VALID'\r\n * ```\r\n *\r\n * ### Create a form array with array-level validators\r\n *\r\n * You include array-level validators and async validators. These come in handy\r\n * when you want to perform validation that considers the value of more than one child\r\n * control.\r\n *\r\n * The two types of validators are passed in separately as the second and third arg\r\n * respectively, or together as part of an options object.\r\n *\r\n * ```\r\n * const arr = new FormArray([\r\n *   new FormControl('Nancy'),\r\n *   new FormControl('Drew')\r\n * ], {validators: myValidator, asyncValidators: myAsyncValidator});\r\n * ```\r\n *\r\n * ### Set the updateOn property for all controls in a form array\r\n *\r\n * The options object is used to set a default value for each child\r\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\r\n * array level, all child controls default to 'blur', unless the child\r\n * has explicitly specified a different `updateOn` value.\r\n *\r\n * ```ts\r\n * const arr = new FormArray([\r\n *    new FormControl()\r\n * ], {updateOn: 'blur'});\r\n * ```\r\n *\r\n * ### Adding or removing controls from a form array\r\n *\r\n * To change the controls in the array, use the `push`, `insert`, `removeAt` or `clear` methods\r\n * in `FormArray` itself. These methods ensure the controls are properly tracked in the\r\n * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate\r\n * the `FormArray` directly, as that result in strange and unexpected behavior such\r\n * as broken change detection.\r\n *\r\n * @publicApi\r\n */\r\nexport declare class FormArray extends AbstractControl {\r\n    controls: AbstractControl[];\r\n    /**\r\n     * Creates a new `FormArray` instance.\r\n     *\r\n     * @param controls An array of child controls. Each child control is given an index\r\n     * where it is registered.\r\n     *\r\n     * @param validatorOrOpts A synchronous validator function, or an array of\r\n     * such functions, or an `AbstractControlOptions` object that contains validation functions\r\n     * and a validation trigger.\r\n     *\r\n     * @param asyncValidator A single async validator or array of async validator functions\r\n     *\r\n     */\r\n    constructor(controls: AbstractControl[], validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null);\r\n    /**\r\n     * Get the `AbstractControl` at the given `index` in the array.\r\n     *\r\n     * @param index Index in the array to retrieve the control\r\n     */\r\n    at(index: number): AbstractControl;\r\n    /**\r\n     * Insert a new `AbstractControl` at the end of the array.\r\n     *\r\n     * @param control Form control to be inserted\r\n     */\r\n    push(control: AbstractControl): void;\r\n    /**\r\n     * Insert a new `AbstractControl` at the given `index` in the array.\r\n     *\r\n     * @param index Index in the array to insert the control\r\n     * @param control Form control to be inserted\r\n     */\r\n    insert(index: number, control: AbstractControl): void;\r\n    /**\r\n     * Remove the control at the given `index` in the array.\r\n     *\r\n     * @param index Index in the array to remove the control\r\n     */\r\n    removeAt(index: number): void;\r\n    /**\r\n     * Replace an existing control.\r\n     *\r\n     * @param index Index in the array to replace the control\r\n     * @param control The `AbstractControl` control to replace the existing control\r\n     */\r\n    setControl(index: number, control: AbstractControl): void;\r\n    /**\r\n     * Length of the control array.\r\n     */\r\n    get length(): number;\r\n    /**\r\n     * Sets the value of the `FormArray`. It accepts an array that matches\r\n     * the structure of the control.\r\n     *\r\n     * This method performs strict checks, and throws an error if you try\r\n     * to set the value of a control that doesn't exist or if you exclude the\r\n     * value of a control.\r\n     *\r\n     * @usageNotes\r\n     * ### Set the values for the controls in the form array\r\n     *\r\n     * ```\r\n     * const arr = new FormArray([\r\n     *   new FormControl(),\r\n     *   new FormControl()\r\n     * ]);\r\n     * console.log(arr.value);   // [null, null]\r\n     *\r\n     * arr.setValue(['Nancy', 'Drew']);\r\n     * console.log(arr.value);   // ['Nancy', 'Drew']\r\n     * ```\r\n     *\r\n     * @param value Array of values for the controls\r\n     * @param options Configure options that determine how the control propagates changes and\r\n     * emits events after the value changes\r\n     *\r\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\r\n     * is false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control value is updated.\r\n     * When false, no events are emitted.\r\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\r\n     * updateValueAndValidity} method.\r\n     */\r\n    setValue(value: any[], options?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Patches the value of the `FormArray`. It accepts an array that matches the\r\n     * structure of the control, and does its best to match the values to the correct\r\n     * controls in the group.\r\n     *\r\n     * It accepts both super-sets and sub-sets of the array without throwing an error.\r\n     *\r\n     * @usageNotes\r\n     * ### Patch the values for controls in a form array\r\n     *\r\n     * ```\r\n     * const arr = new FormArray([\r\n     *    new FormControl(),\r\n     *    new FormControl()\r\n     * ]);\r\n     * console.log(arr.value);   // [null, null]\r\n     *\r\n     * arr.patchValue(['Nancy']);\r\n     * console.log(arr.value);   // ['Nancy', null]\r\n     * ```\r\n     *\r\n     * @param value Array of latest values for the controls\r\n     * @param options Configure options that determine how the control propagates changes and\r\n     * emits events after the value changes\r\n     *\r\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\r\n     * is false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control value is updated.\r\n     * When false, no events are emitted.\r\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\r\n     * updateValueAndValidity} method.\r\n     */\r\n    patchValue(value: any[], options?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the\r\n     * value of all descendants to null or null maps.\r\n     *\r\n     * You reset to a specific form state by passing in an array of states\r\n     * that matches the structure of the control. The state is a standalone value\r\n     * or a form state object with both a value and a disabled status.\r\n     *\r\n     * @usageNotes\r\n     * ### Reset the values in a form array\r\n     *\r\n     * ```ts\r\n     * const arr = new FormArray([\r\n     *    new FormControl(),\r\n     *    new FormControl()\r\n     * ]);\r\n     * arr.reset(['name', 'last name']);\r\n     *\r\n     * console.log(this.arr.value);  // ['name', 'last name']\r\n     * ```\r\n     *\r\n     * ### Reset the values in a form array and the disabled status for the first control\r\n     *\r\n     * ```\r\n     * this.arr.reset([\r\n     *   {value: 'name', disabled: true},\r\n     *   'last'\r\n     * ]);\r\n     *\r\n     * console.log(this.arr.value);  // ['name', 'last name']\r\n     * console.log(this.arr.get(0).status);  // 'DISABLED'\r\n     * ```\r\n     *\r\n     * @param value Array of values for the controls\r\n     * @param options Configure options that determine how the control propagates changes and\r\n     * emits events after the value changes\r\n     *\r\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\r\n     * is false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control is reset.\r\n     * When false, no events are emitted.\r\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\r\n     * updateValueAndValidity} method.\r\n     */\r\n    reset(value?: any, options?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * The aggregate value of the array, including any disabled controls.\r\n     *\r\n     * Reports all values regardless of disabled status.\r\n     * For enabled controls only, the `value` property is the best way to get the value of the array.\r\n     */\r\n    getRawValue(): any[];\r\n    /**\r\n     * Remove all controls in the `FormArray`.\r\n     *\r\n     * @usageNotes\r\n     * ### Remove all elements from a FormArray\r\n     *\r\n     * ```ts\r\n     * const arr = new FormArray([\r\n     *    new FormControl(),\r\n     *    new FormControl()\r\n     * ]);\r\n     * console.log(arr.length);  // 2\r\n     *\r\n     * arr.clear();\r\n     * console.log(arr.length);  // 0\r\n     * ```\r\n     *\r\n     * It's a simpler and more efficient alternative to removing all elements one by one:\r\n     *\r\n     * ```ts\r\n     * const arr = new FormArray([\r\n     *    new FormControl(),\r\n     *    new FormControl()\r\n     * ]);\r\n     *\r\n     * while (arr.length) {\r\n     *    arr.removeAt(0);\r\n     * }\r\n     * ```\r\n     */\r\n    clear(): void;\r\n    private _registerControl;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Syncs a nested `FormArray` to a DOM element.\r\n *\r\n * This directive is designed to be used with a parent `FormGroupDirective` (selector:\r\n * `[formGroup]`).\r\n *\r\n * It accepts the string name of the nested `FormArray` you want to link, and\r\n * will look for a `FormArray` registered with that name in the parent\r\n * `FormGroup` instance you passed into `FormGroupDirective`.\r\n *\r\n * @see [Reactive Forms Guide](guide/reactive-forms)\r\n * @see `AbstractControl`\r\n *\r\n * @usageNotes\r\n *\r\n * ### Example\r\n *\r\n * {@example forms/ts/nestedFormArray/nested_form_array_example.ts region='Component'}\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @publicApi\r\n */\r\nexport declare class FormArrayName extends ControlContainer implements OnInit, OnDestroy {\r\n    /**\r\n     * @description\r\n     * Tracks the name of the `FormArray` bound to the directive. The name corresponds\r\n     * to a key in the parent `FormGroup` or `FormArray`.\r\n     * Accepts a name as a string or a number.\r\n     * The name in the form of a string is useful for individual forms,\r\n     * while the numerical form allows for form arrays to be bound\r\n     * to indices when iterating over arrays in a `FormArray`.\r\n     */\r\n    name: string | number | null;\r\n    constructor(parent: ControlContainer, validators: any[], asyncValidators: any[]);\r\n    /**\r\n     * @description\r\n     * A lifecycle method called when the directive's inputs are initialized. For internal use only.\r\n     *\r\n     * @throws If the directive does not have a valid parent.\r\n     */\r\n    ngOnInit(): void;\r\n    /**\r\n     * @description\r\n     * A lifecycle method called before the directive's instance is destroyed. For internal use only.\r\n     */\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * @description\r\n     * The `FormArray` bound to this directive.\r\n     */\r\n    get control(): FormArray;\r\n    /**\r\n     * @description\r\n     * The top-level directive for this group if present, otherwise null.\r\n     */\r\n    get formDirective(): FormGroupDirective | null;\r\n    /**\r\n     * @description\r\n     * Returns an array that represents the path from the top-level form to this control.\r\n     * Each index is the string name of the control on that level.\r\n     */\r\n    get path(): string[];\r\n    /**\r\n     * @description\r\n     * Synchronous validator function composed of all the synchronous validators registered with this\r\n     * directive.\r\n     */\r\n    get validator(): ValidatorFn | null;\r\n    /**\r\n     * @description\r\n     * Async validator function composed of all the async validators registered with this directive.\r\n     */\r\n    get asyncValidator(): AsyncValidatorFn | null;\r\n    private _checkParentType;\r\n}\r\n\r\n/**\r\n * @description\r\n * Creates an `AbstractControl` from a user-specified configuration.\r\n *\r\n * The `FormBuilder` provides syntactic sugar that shortens creating instances of a `FormControl`,\r\n * `FormGroup`, or `FormArray`. It reduces the amount of boilerplate needed to build complex\r\n * forms.\r\n *\r\n * @see [Reactive Forms Guide](/guide/reactive-forms)\r\n *\r\n * @publicApi\r\n */\r\nexport declare class FormBuilder {\r\n    /**\r\n     * @description\r\n     * Construct a new `FormGroup` instance.\r\n     *\r\n     * @param controlsConfig A collection of child controls. The key for each child is the name\r\n     * under which it is registered.\r\n     *\r\n     * @param options Configuration options object for the `FormGroup`. The object can\r\n     * have two shapes:\r\n     *\r\n     * 1) `AbstractControlOptions` object (preferred), which consists of:\r\n     * * `validators`: A synchronous validator function, or an array of validator functions\r\n     * * `asyncValidators`: A single async validator or array of async validator functions\r\n     * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur' |\r\n     * submit')\r\n     *\r\n     * 2) Legacy configuration object, which consists of:\r\n     * * `validator`: A synchronous validator function, or an array of validator functions\r\n     * * `asyncValidator`: A single async validator or array of async validator functions\r\n     *\r\n     */\r\n    group(controlsConfig: {\r\n        [key: string]: any;\r\n    }, options?: AbstractControlOptions | {\r\n        [key: string]: any;\r\n    } | null): FormGroup;\r\n    /**\r\n     * @description\r\n     * Construct a new `FormControl` with the given state, validators and options.\r\n     *\r\n     * @param formState Initializes the control with an initial state value, or\r\n     * with an object that contains both a value and a disabled status.\r\n     *\r\n     * @param validatorOrOpts A synchronous validator function, or an array of\r\n     * such functions, or an `AbstractControlOptions` object that contains\r\n     * validation functions and a validation trigger.\r\n     *\r\n     * @param asyncValidator A single async validator or array of async validator\r\n     * functions.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Initialize a control as disabled\r\n     *\r\n     * The following example returns a control with an initial value in a disabled state.\r\n     *\r\n     * <code-example path=\"forms/ts/formBuilder/form_builder_example.ts\" region=\"disabled-control\">\r\n     * </code-example>\r\n     */\r\n    control(formState: any, validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null): FormControl;\r\n    /**\r\n     * Constructs a new `FormArray` from the given array of configurations,\r\n     * validators and options.\r\n     *\r\n     * @param controlsConfig An array of child controls or control configs. Each\r\n     * child control is given an index when it is registered.\r\n     *\r\n     * @param validatorOrOpts A synchronous validator function, or an array of\r\n     * such functions, or an `AbstractControlOptions` object that contains\r\n     * validation functions and a validation trigger.\r\n     *\r\n     * @param asyncValidator A single async validator or array of async validator\r\n     * functions.\r\n     */\r\n    array(controlsConfig: any[], validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null): FormArray;\r\n}\r\n\r\n/**\r\n * Tracks the value and validation status of an individual form control.\r\n *\r\n * This is one of the three fundamental building blocks of Angular forms, along with\r\n * `FormGroup` and `FormArray`. It extends the `AbstractControl` class that\r\n * implements most of the base functionality for accessing the value, validation status,\r\n * user interactions and events. See [usage examples below](#usage-notes).\r\n *\r\n * @see `AbstractControl`\r\n * @see [Reactive Forms Guide](guide/reactive-forms)\r\n * @see [Usage Notes](#usage-notes)\r\n *\r\n * @usageNotes\r\n *\r\n * ### Initializing Form Controls\r\n *\r\n * Instantiate a `FormControl`, with an initial value.\r\n *\r\n * ```ts\r\n * const control = new FormControl('some value');\r\n * console.log(control.value);     // 'some value'\r\n *```\r\n *\r\n * The following example initializes the control with a form state object. The `value`\r\n * and `disabled` keys are required in this case.\r\n *\r\n * ```ts\r\n * const control = new FormControl({ value: 'n/a', disabled: true });\r\n * console.log(control.value);     // 'n/a'\r\n * console.log(control.status);    // 'DISABLED'\r\n * ```\r\n *\r\n * The following example initializes the control with a sync validator.\r\n *\r\n * ```ts\r\n * const control = new FormControl('', Validators.required);\r\n * console.log(control.value);      // ''\r\n * console.log(control.status);     // 'INVALID'\r\n * ```\r\n *\r\n * The following example initializes the control using an options object.\r\n *\r\n * ```ts\r\n * const control = new FormControl('', {\r\n *    validators: Validators.required,\r\n *    asyncValidators: myAsyncValidator\r\n * });\r\n * ```\r\n *\r\n * ### Configure the control to update on a blur event\r\n *\r\n * Set the `updateOn` option to `'blur'` to update on the blur `event`.\r\n *\r\n * ```ts\r\n * const control = new FormControl('', { updateOn: 'blur' });\r\n * ```\r\n *\r\n * ### Configure the control to update on a submit event\r\n *\r\n * Set the `updateOn` option to `'submit'` to update on a submit `event`.\r\n *\r\n * ```ts\r\n * const control = new FormControl('', { updateOn: 'submit' });\r\n * ```\r\n *\r\n * ### Reset the control back to an initial value\r\n *\r\n * You reset to a specific form state by passing through a standalone\r\n * value or a form state object that contains both a value and a disabled state\r\n * (these are the only two properties that cannot be calculated).\r\n *\r\n * ```ts\r\n * const control = new FormControl('Nancy');\r\n *\r\n * console.log(control.value); // 'Nancy'\r\n *\r\n * control.reset('Drew');\r\n *\r\n * console.log(control.value); // 'Drew'\r\n * ```\r\n *\r\n * ### Reset the control back to an initial value and disabled\r\n *\r\n * ```\r\n * const control = new FormControl('Nancy');\r\n *\r\n * console.log(control.value); // 'Nancy'\r\n * console.log(control.status); // 'VALID'\r\n *\r\n * control.reset({ value: 'Drew', disabled: true });\r\n *\r\n * console.log(control.value); // 'Drew'\r\n * console.log(control.status); // 'DISABLED'\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare class FormControl extends AbstractControl {\r\n    /**\r\n     * Creates a new `FormControl` instance.\r\n     *\r\n     * @param formState Initializes the control with an initial value,\r\n     * or an object that defines the initial value and disabled state.\r\n     *\r\n     * @param validatorOrOpts A synchronous validator function, or an array of\r\n     * such functions, or an `AbstractControlOptions` object that contains validation functions\r\n     * and a validation trigger.\r\n     *\r\n     * @param asyncValidator A single async validator or array of async validator functions\r\n     *\r\n     */\r\n    constructor(formState?: any, validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null);\r\n    /**\r\n     * Sets a new value for the form control.\r\n     *\r\n     * @param value The new value for the control.\r\n     * @param options Configuration options that determine how the control propagates changes\r\n     * and emits events when the value changes.\r\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\r\n     * updateValueAndValidity} method.\r\n     *\r\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\r\n     * false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control value is updated.\r\n     * When false, no events are emitted.\r\n     * * `emitModelToViewChange`: When true or not supplied  (the default), each change triggers an\r\n     * `onChange` event to\r\n     * update the view.\r\n     * * `emitViewToModelChange`: When true or not supplied (the default), each change triggers an\r\n     * `ngModelChange`\r\n     * event to update the model.\r\n     *\r\n     */\r\n    setValue(value: any, options?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n        emitModelToViewChange?: boolean;\r\n        emitViewToModelChange?: boolean;\r\n    }): void;\r\n    /**\r\n     * Patches the value of a control.\r\n     *\r\n     * This function is functionally the same as {@link FormControl#setValue setValue} at this level.\r\n     * It exists for symmetry with {@link FormGroup#patchValue patchValue} on `FormGroups` and\r\n     * `FormArrays`, where it does behave differently.\r\n     *\r\n     * @see `setValue` for options\r\n     */\r\n    patchValue(value: any, options?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n        emitModelToViewChange?: boolean;\r\n        emitViewToModelChange?: boolean;\r\n    }): void;\r\n    /**\r\n     * Resets the form control, marking it `pristine` and `untouched`, and setting\r\n     * the value to null.\r\n     *\r\n     * @param formState Resets the control with an initial value,\r\n     * or an object that defines the initial value and disabled state.\r\n     *\r\n     * @param options Configuration options that determine how the control propagates changes\r\n     * and emits events after the value changes.\r\n     *\r\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\r\n     * false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control is reset.\r\n     * When false, no events are emitted.\r\n     *\r\n     */\r\n    reset(formState?: any, options?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Register a listener for change events.\r\n     *\r\n     * @param fn The method that is called when the value changes\r\n     */\r\n    registerOnChange(fn: Function): void;\r\n    /**\r\n     * Register a listener for disabled events.\r\n     *\r\n     * @param fn The method that is called when the disabled status changes.\r\n     */\r\n    registerOnDisabledChange(fn: (isDisabled: boolean) => void): void;\r\n    private _applyFormState;\r\n}\r\n\r\n/**\r\n * @description\r\n * Synchronizes a standalone `FormControl` instance to a form control element.\r\n *\r\n * Note that support for using the `ngModel` input property and `ngModelChange` event with reactive\r\n * form directives was deprecated in Angular v6 and is scheduled for removal in\r\n * a future version of Angular.\r\n * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).\r\n *\r\n * @see [Reactive Forms Guide](guide/reactive-forms)\r\n * @see `FormControl`\r\n * @see `AbstractControl`\r\n *\r\n * @usageNotes\r\n *\r\n * The following example shows how to register a standalone control and set its value.\r\n *\r\n * {@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @publicApi\r\n */\r\nexport declare class FormControlDirective extends NgControl implements OnChanges {\r\n    private _ngModelWarningConfig;\r\n    /**\r\n     * @description\r\n     * Internal reference to the view model value.\r\n     */\r\n    viewModel: any;\r\n    /**\r\n     * @description\r\n     * Tracks the `FormControl` instance bound to the directive.\r\n     */\r\n    form: FormControl;\r\n    /**\r\n     * @description\r\n     * Triggers a warning that this input should not be used with reactive forms.\r\n     */\r\n    set isDisabled(isDisabled: boolean);\r\n    /** @deprecated as of v6 */\r\n    model: any;\r\n    /** @deprecated as of v6 */\r\n    update: EventEmitter<any>;\r\n    constructor(validators: Array<Validator | ValidatorFn>, asyncValidators: Array<AsyncValidator | AsyncValidatorFn>, valueAccessors: ControlValueAccessor[], _ngModelWarningConfig: string | null);\r\n    /**\r\n     * @description\r\n     * A lifecycle method called when the directive's inputs change. For internal use\r\n     * only.\r\n     *\r\n     * @param changes A object of key/value pairs for the set of changed inputs.\r\n     */\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n    /**\r\n     * @description\r\n     * Returns an array that represents the path from the top-level form to this control.\r\n     * Each index is the string name of the control on that level.\r\n     */\r\n    get path(): string[];\r\n    /**\r\n     * @description\r\n     * Synchronous validator function composed of all the synchronous validators\r\n     * registered with this directive.\r\n     */\r\n    get validator(): ValidatorFn | null;\r\n    /**\r\n     * @description\r\n     * Async validator function composed of all the async validators registered with this\r\n     * directive.\r\n     */\r\n    get asyncValidator(): AsyncValidatorFn | null;\r\n    /**\r\n     * @description\r\n     * The `FormControl` bound to this directive.\r\n     */\r\n    get control(): FormControl;\r\n    /**\r\n     * @description\r\n     * Sets the new value for the view model and emits an `ngModelChange` event.\r\n     *\r\n     * @param newValue The new value for the view model.\r\n     */\r\n    viewToModelUpdate(newValue: any): void;\r\n    private _isControlChanged;\r\n}\r\n\r\n/**\r\n * @description\r\n * Syncs a `FormControl` in an existing `FormGroup` to a form control\r\n * element by name.\r\n *\r\n * @see [Reactive Forms Guide](guide/reactive-forms)\r\n * @see `FormControl`\r\n * @see `AbstractControl`\r\n *\r\n * @usageNotes\r\n *\r\n * ### Register `FormControl` within a group\r\n *\r\n * The following example shows how to register multiple form controls within a form group\r\n * and set their value.\r\n *\r\n * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}\r\n *\r\n * To see `formControlName` examples with different form control types, see:\r\n *\r\n * * Radio buttons: `RadioControlValueAccessor`\r\n * * Selects: `SelectControlValueAccessor`\r\n *\r\n * ### Use with ngModel is deprecated\r\n *\r\n * Support for using the `ngModel` input property and `ngModelChange` event with reactive\r\n * form directives has been deprecated in Angular v6 and is scheduled for removal in\r\n * a future version of Angular.\r\n *\r\n * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @publicApi\r\n */\r\nexport declare class FormControlName extends NgControl implements OnChanges, OnDestroy {\r\n    private _ngModelWarningConfig;\r\n    private _added;\r\n    /**\r\n     * @description\r\n     * Tracks the `FormControl` instance bound to the directive.\r\n     */\r\n    readonly control: FormControl;\r\n    /**\r\n     * @description\r\n     * Tracks the name of the `FormControl` bound to the directive. The name corresponds\r\n     * to a key in the parent `FormGroup` or `FormArray`.\r\n     * Accepts a name as a string or a number.\r\n     * The name in the form of a string is useful for individual forms,\r\n     * while the numerical form allows for form controls to be bound\r\n     * to indices when iterating over controls in a `FormArray`.\r\n     */\r\n    name: string | number | null;\r\n    /**\r\n     * @description\r\n     * Triggers a warning that this input should not be used with reactive forms.\r\n     */\r\n    set isDisabled(isDisabled: boolean);\r\n    /** @deprecated as of v6 */\r\n    model: any;\r\n    /** @deprecated as of v6 */\r\n    update: EventEmitter<any>;\r\n    constructor(parent: ControlContainer, validators: Array<Validator | ValidatorFn>, asyncValidators: Array<AsyncValidator | AsyncValidatorFn>, valueAccessors: ControlValueAccessor[], _ngModelWarningConfig: string | null);\r\n    /**\r\n     * @description\r\n     * A lifecycle method called when the directive's inputs change. For internal use only.\r\n     *\r\n     * @param changes A object of key/value pairs for the set of changed inputs.\r\n     */\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n    /**\r\n     * @description\r\n     * Lifecycle method called before the directive's instance is destroyed. For internal use only.\r\n     */\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * @description\r\n     * Sets the new value for the view model and emits an `ngModelChange` event.\r\n     *\r\n     * @param newValue The new value for the view model.\r\n     */\r\n    viewToModelUpdate(newValue: any): void;\r\n    /**\r\n     * @description\r\n     * Returns an array that represents the path from the top-level form to this control.\r\n     * Each index is the string name of the control on that level.\r\n     */\r\n    get path(): string[];\r\n    /**\r\n     * @description\r\n     * The top-level directive for this group if present, otherwise null.\r\n     */\r\n    get formDirective(): any;\r\n    /**\r\n     * @description\r\n     * Synchronous validator function composed of all the synchronous validators\r\n     * registered with this directive.\r\n     */\r\n    get validator(): ValidatorFn | null;\r\n    /**\r\n     * @description\r\n     * Async validator function composed of all the async validators registered with this\r\n     * directive.\r\n     */\r\n    get asyncValidator(): AsyncValidatorFn;\r\n    private _checkParentType;\r\n    private _setUpControl;\r\n}\r\n\r\n/**\r\n * Tracks the value and validity state of a group of `FormControl` instances.\r\n *\r\n * A `FormGroup` aggregates the values of each child `FormControl` into one object,\r\n * with each control name as the key.  It calculates its status by reducing the status values\r\n * of its children. For example, if one of the controls in a group is invalid, the entire\r\n * group becomes invalid.\r\n *\r\n * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,\r\n * along with `FormControl` and `FormArray`.\r\n *\r\n * When instantiating a `FormGroup`, pass in a collection of child controls as the first\r\n * argument. The key for each child registers the name for the control.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Create a form group with 2 controls\r\n *\r\n * ```\r\n * const form = new FormGroup({\r\n *   first: new FormControl('Nancy', Validators.minLength(2)),\r\n *   last: new FormControl('Drew'),\r\n * });\r\n *\r\n * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}\r\n * console.log(form.status);  // 'VALID'\r\n * ```\r\n *\r\n * ### Create a form group with a group-level validator\r\n *\r\n * You include group-level validators as the second arg, or group-level async\r\n * validators as the third arg. These come in handy when you want to perform validation\r\n * that considers the value of more than one child control.\r\n *\r\n * ```\r\n * const form = new FormGroup({\r\n *   password: new FormControl('', Validators.minLength(2)),\r\n *   passwordConfirm: new FormControl('', Validators.minLength(2)),\r\n * }, passwordMatchValidator);\r\n *\r\n *\r\n * function passwordMatchValidator(g: FormGroup) {\r\n *    return g.get('password').value === g.get('passwordConfirm').value\r\n *       ? null : {'mismatch': true};\r\n * }\r\n * ```\r\n *\r\n * Like `FormControl` instances, you choose to pass in\r\n * validators and async validators as part of an options object.\r\n *\r\n * ```\r\n * const form = new FormGroup({\r\n *   password: new FormControl('')\r\n *   passwordConfirm: new FormControl('')\r\n * }, { validators: passwordMatchValidator, asyncValidators: otherValidator });\r\n * ```\r\n *\r\n * ### Set the updateOn property for all controls in a form group\r\n *\r\n * The options object is used to set a default value for each child\r\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\r\n * group level, all child controls default to 'blur', unless the child\r\n * has explicitly specified a different `updateOn` value.\r\n *\r\n * ```ts\r\n * const c = new FormGroup({\r\n *   one: new FormControl()\r\n * }, { updateOn: 'blur' });\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare class FormGroup extends AbstractControl {\r\n    controls: {\r\n        [key: string]: AbstractControl;\r\n    };\r\n    /**\r\n     * Creates a new `FormGroup` instance.\r\n     *\r\n     * @param controls A collection of child controls. The key for each child is the name\r\n     * under which it is registered.\r\n     *\r\n     * @param validatorOrOpts A synchronous validator function, or an array of\r\n     * such functions, or an `AbstractControlOptions` object that contains validation functions\r\n     * and a validation trigger.\r\n     *\r\n     * @param asyncValidator A single async validator or array of async validator functions\r\n     *\r\n     */\r\n    constructor(controls: {\r\n        [key: string]: AbstractControl;\r\n    }, validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null);\r\n    /**\r\n     * Registers a control with the group's list of controls.\r\n     *\r\n     * This method does not update the value or validity of the control.\r\n     * Use {@link FormGroup#addControl addControl} instead.\r\n     *\r\n     * @param name The control name to register in the collection\r\n     * @param control Provides the control for the given name\r\n     */\r\n    registerControl(name: string, control: AbstractControl): AbstractControl;\r\n    /**\r\n     * Add a control to this group.\r\n     *\r\n     * This method also updates the value and validity of the control.\r\n     *\r\n     * @param name The control name to add to the collection\r\n     * @param control Provides the control for the given name\r\n     */\r\n    addControl(name: string, control: AbstractControl): void;\r\n    /**\r\n     * Remove a control from this group.\r\n     *\r\n     * @param name The control name to remove from the collection\r\n     */\r\n    removeControl(name: string): void;\r\n    /**\r\n     * Replace an existing control.\r\n     *\r\n     * @param name The control name to replace in the collection\r\n     * @param control Provides the control for the given name\r\n     */\r\n    setControl(name: string, control: AbstractControl): void;\r\n    /**\r\n     * Check whether there is an enabled control with the given name in the group.\r\n     *\r\n     * Reports false for disabled controls. If you'd like to check for existence in the group\r\n     * only, use {@link AbstractControl#get get} instead.\r\n     *\r\n     * @param controlName The control name to check for existence in the collection\r\n     *\r\n     * @returns false for disabled controls, true otherwise.\r\n     */\r\n    contains(controlName: string): boolean;\r\n    /**\r\n     * Sets the value of the `FormGroup`. It accepts an object that matches\r\n     * the structure of the group, with control names as keys.\r\n     *\r\n     * @usageNotes\r\n     * ### Set the complete value for the form group\r\n     *\r\n     * ```\r\n     * const form = new FormGroup({\r\n     *   first: new FormControl(),\r\n     *   last: new FormControl()\r\n     * });\r\n     *\r\n     * console.log(form.value);   // {first: null, last: null}\r\n     *\r\n     * form.setValue({first: 'Nancy', last: 'Drew'});\r\n     * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}\r\n     * ```\r\n     *\r\n     * @throws When strict checks fail, such as setting the value of a control\r\n     * that doesn't exist or if you exclude a value of a control that does exist.\r\n     *\r\n     * @param value The new value for the control that matches the structure of the group.\r\n     * @param options Configuration options that determine how the control propagates changes\r\n     * and emits events after the value changes.\r\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\r\n     * updateValueAndValidity} method.\r\n     *\r\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\r\n     * false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control value is updated.\r\n     * When false, no events are emitted.\r\n     */\r\n    setValue(value: {\r\n        [key: string]: any;\r\n    }, options?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Patches the value of the `FormGroup`. It accepts an object with control\r\n     * names as keys, and does its best to match the values to the correct controls\r\n     * in the group.\r\n     *\r\n     * It accepts both super-sets and sub-sets of the group without throwing an error.\r\n     *\r\n     * @usageNotes\r\n     * ### Patch the value for a form group\r\n     *\r\n     * ```\r\n     * const form = new FormGroup({\r\n     *    first: new FormControl(),\r\n     *    last: new FormControl()\r\n     * });\r\n     * console.log(form.value);   // {first: null, last: null}\r\n     *\r\n     * form.patchValue({first: 'Nancy'});\r\n     * console.log(form.value);   // {first: 'Nancy', last: null}\r\n     * ```\r\n     *\r\n     * @param value The object that matches the structure of the group.\r\n     * @param options Configuration options that determine how the control propagates changes and\r\n     * emits events after the value is patched.\r\n     * * `onlySelf`: When true, each change only affects this control and not its parent. Default is\r\n     * true.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control value is updated.\r\n     * When false, no events are emitted.\r\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\r\n     * updateValueAndValidity} method.\r\n     */\r\n    patchValue(value: {\r\n        [key: string]: any;\r\n    }, options?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * Resets the `FormGroup`, marks all descendants are marked `pristine` and `untouched`, and\r\n     * the value of all descendants to null.\r\n     *\r\n     * You reset to a specific form state by passing in a map of states\r\n     * that matches the structure of your form, with control names as keys. The state\r\n     * is a standalone value or a form state object with both a value and a disabled\r\n     * status.\r\n     *\r\n     * @param value Resets the control with an initial value,\r\n     * or an object that defines the initial value and disabled state.\r\n     *\r\n     * @param options Configuration options that determine how the control propagates changes\r\n     * and emits events when the group is reset.\r\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\r\n     * false.\r\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\r\n     * `valueChanges`\r\n     * observables emit events with the latest status and value when the control is reset.\r\n     * When false, no events are emitted.\r\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\r\n     * updateValueAndValidity} method.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Reset the form group values\r\n     *\r\n     * ```ts\r\n     * const form = new FormGroup({\r\n     *   first: new FormControl('first name'),\r\n     *   last: new FormControl('last name')\r\n     * });\r\n     *\r\n     * console.log(form.value);  // {first: 'first name', last: 'last name'}\r\n     *\r\n     * form.reset({ first: 'name', last: 'last name' });\r\n     *\r\n     * console.log(form.value);  // {first: 'name', last: 'last name'}\r\n     * ```\r\n     *\r\n     * ### Reset the form group values and disabled status\r\n     *\r\n     * ```\r\n     * const form = new FormGroup({\r\n     *   first: new FormControl('first name'),\r\n     *   last: new FormControl('last name')\r\n     * });\r\n     *\r\n     * form.reset({\r\n     *   first: {value: 'name', disabled: true},\r\n     *   last: 'last'\r\n     * });\r\n     *\r\n     * console.log(this.form.value);  // {first: 'name', last: 'last name'}\r\n     * console.log(this.form.get('first').status);  // 'DISABLED'\r\n     * ```\r\n     */\r\n    reset(value?: any, options?: {\r\n        onlySelf?: boolean;\r\n        emitEvent?: boolean;\r\n    }): void;\r\n    /**\r\n     * The aggregate value of the `FormGroup`, including any disabled controls.\r\n     *\r\n     * Retrieves all values regardless of disabled status.\r\n     * The `value` property is the best way to get the value of the group, because\r\n     * it excludes disabled controls in the `FormGroup`.\r\n     */\r\n    getRawValue(): any;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Binds an existing `FormGroup` to a DOM element.\r\n *\r\n * This directive accepts an existing `FormGroup` instance. It will then use this\r\n * `FormGroup` instance to match any child `FormControl`, `FormGroup`,\r\n * and `FormArray` instances to child `FormControlName`, `FormGroupName`,\r\n * and `FormArrayName` directives.\r\n *\r\n * @see [Reactive Forms Guide](guide/reactive-forms)\r\n * @see `AbstractControl`\r\n *\r\n * ### Register Form Group\r\n *\r\n * The following example registers a `FormGroup` with first name and last name controls,\r\n * and listens for the *ngSubmit* event when the button is clicked.\r\n *\r\n * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @publicApi\r\n */\r\nexport declare class FormGroupDirective extends ControlContainer implements Form, OnChanges {\r\n    private _validators;\r\n    private _asyncValidators;\r\n    /**\r\n     * @description\r\n     * Reports whether the form submission has been triggered.\r\n     */\r\n    readonly submitted: boolean;\r\n    private _oldForm;\r\n    /**\r\n     * @description\r\n     * Tracks the list of added `FormControlName` instances\r\n     */\r\n    directives: FormControlName[];\r\n    /**\r\n     * @description\r\n     * Tracks the `FormGroup` bound to this directive.\r\n     */\r\n    form: FormGroup;\r\n    /**\r\n     * @description\r\n     * Emits an event when the form submission has been triggered.\r\n     */\r\n    ngSubmit: EventEmitter<any>;\r\n    constructor(_validators: any[], _asyncValidators: any[]);\r\n    /**\r\n     * @description\r\n     * A lifecycle method called when the directive's inputs change. For internal use only.\r\n     *\r\n     * @param changes A object of key/value pairs for the set of changed inputs.\r\n     */\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n    /**\r\n     * @description\r\n     * Returns this directive's instance.\r\n     */\r\n    get formDirective(): Form;\r\n    /**\r\n     * @description\r\n     * Returns the `FormGroup` bound to this directive.\r\n     */\r\n    get control(): FormGroup;\r\n    /**\r\n     * @description\r\n     * Returns an array representing the path to this group. Because this directive\r\n     * always lives at the top level of a form, it always an empty array.\r\n     */\r\n    get path(): string[];\r\n    /**\r\n     * @description\r\n     * Method that sets up the control directive in this group, re-calculates its value\r\n     * and validity, and adds the instance to the internal list of directives.\r\n     *\r\n     * @param dir The `FormControlName` directive instance.\r\n     */\r\n    addControl(dir: FormControlName): FormControl;\r\n    /**\r\n     * @description\r\n     * Retrieves the `FormControl` instance from the provided `FormControlName` directive\r\n     *\r\n     * @param dir The `FormControlName` directive instance.\r\n     */\r\n    getControl(dir: FormControlName): FormControl;\r\n    /**\r\n     * @description\r\n     * Removes the `FormControlName` instance from the internal list of directives\r\n     *\r\n     * @param dir The `FormControlName` directive instance.\r\n     */\r\n    removeControl(dir: FormControlName): void;\r\n    /**\r\n     * Adds a new `FormGroupName` directive instance to the form.\r\n     *\r\n     * @param dir The `FormGroupName` directive instance.\r\n     */\r\n    addFormGroup(dir: FormGroupName): void;\r\n    /**\r\n     * No-op method to remove the form group.\r\n     *\r\n     * @param dir The `FormGroupName` directive instance.\r\n     */\r\n    removeFormGroup(dir: FormGroupName): void;\r\n    /**\r\n     * @description\r\n     * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance\r\n     *\r\n     * @param dir The `FormGroupName` directive instance.\r\n     */\r\n    getFormGroup(dir: FormGroupName): FormGroup;\r\n    /**\r\n     * Adds a new `FormArrayName` directive instance to the form.\r\n     *\r\n     * @param dir The `FormArrayName` directive instance.\r\n     */\r\n    addFormArray(dir: FormArrayName): void;\r\n    /**\r\n     * No-op method to remove the form array.\r\n     *\r\n     * @param dir The `FormArrayName` directive instance.\r\n     */\r\n    removeFormArray(dir: FormArrayName): void;\r\n    /**\r\n     * @description\r\n     * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.\r\n     *\r\n     * @param dir The `FormArrayName` directive instance.\r\n     */\r\n    getFormArray(dir: FormArrayName): FormArray;\r\n    /**\r\n     * Sets the new value for the provided `FormControlName` directive.\r\n     *\r\n     * @param dir The `FormControlName` directive instance.\r\n     * @param value The new value for the directive's control.\r\n     */\r\n    updateModel(dir: FormControlName, value: any): void;\r\n    /**\r\n     * @description\r\n     * Method called with the \"submit\" event is triggered on the form.\r\n     * Triggers the `ngSubmit` emitter to emit the \"submit\" event as its payload.\r\n     *\r\n     * @param $event The \"submit\" event object\r\n     */\r\n    onSubmit($event: Event): boolean;\r\n    /**\r\n     * @description\r\n     * Method called when the \"reset\" event is triggered on the form.\r\n     */\r\n    onReset(): void;\r\n    /**\r\n     * @description\r\n     * Resets the form to an initial value and resets its submitted status.\r\n     *\r\n     * @param value The new value for the form.\r\n     */\r\n    resetForm(value?: any): void;\r\n    private _updateRegistrations;\r\n    private _updateValidators;\r\n    private _checkFormPresent;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Syncs a nested `FormGroup` to a DOM element.\r\n *\r\n * This directive can only be used with a parent `FormGroupDirective`.\r\n *\r\n * It accepts the string name of the nested `FormGroup` to link, and\r\n * looks for a `FormGroup` registered with that name in the parent\r\n * `FormGroup` instance you passed into `FormGroupDirective`.\r\n *\r\n * Use nested form groups to validate a sub-group of a\r\n * form separately from the rest or to group the values of certain\r\n * controls into their own nested object.\r\n *\r\n * @see [Reactive Forms Guide](guide/reactive-forms)\r\n *\r\n * @usageNotes\r\n *\r\n * ### Access the group by name\r\n *\r\n * The following example uses the {@link AbstractControl#get get} method to access the\r\n * associated `FormGroup`\r\n *\r\n * ```ts\r\n *   this.form.get('name');\r\n * ```\r\n *\r\n * ### Access individual controls in the group\r\n *\r\n * The following example uses the {@link AbstractControl#get get} method to access\r\n * individual controls within the group using dot syntax.\r\n *\r\n * ```ts\r\n *   this.form.get('name.first');\r\n * ```\r\n *\r\n * ### Register a nested `FormGroup`.\r\n *\r\n * The following example registers a nested *name* `FormGroup` within an existing `FormGroup`,\r\n * and provides methods to retrieve the nested `FormGroup` and individual controls.\r\n *\r\n * {@example forms/ts/nestedFormGroup/nested_form_group_example.ts region='Component'}\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @publicApi\r\n */\r\nexport declare class FormGroupName extends AbstractFormGroupDirective implements OnInit, OnDestroy {\r\n    /**\r\n     * @description\r\n     * Tracks the name of the `FormGroup` bound to the directive. The name corresponds\r\n     * to a key in the parent `FormGroup` or `FormArray`.\r\n     * Accepts a name as a string or a number.\r\n     * The name in the form of a string is useful for individual forms,\r\n     * while the numerical form allows for form groups to be bound\r\n     * to indices when iterating over groups in a `FormArray`.\r\n     */\r\n    name: string | number | null;\r\n    constructor(parent: ControlContainer, validators: any[], asyncValidators: any[]);\r\n}\r\n\r\ndeclare type FormHooks = 'change' | 'blur' | 'submit';\r\n\r\n/**\r\n * Exports the required providers and directives for template-driven forms,\r\n * making them available for import by NgModules that import this module.\r\n *\r\n * @see [Forms Overview](/guide/forms-overview)\r\n * @see [Template-driven Forms Guide](/guide/forms)\r\n *\r\n * @publicApi\r\n */\r\nexport declare class FormsModule {\r\n}\r\n\r\n/**\r\n * A directive that adds max length validation to controls marked with the\r\n * `maxlength` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\r\n *\r\n * @see [Form Validation](guide/form-validation)\r\n *\r\n * @usageNotes\r\n *\r\n * ### Adding a maximum length validator\r\n *\r\n * The following example shows how to add a maximum length validator to an input attached to an\r\n * ngModel binding.\r\n *\r\n * ```html\r\n * <input name=\"firstName\" ngModel maxlength=\"25\">\r\n * ```\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class MaxLengthValidator implements Validator, OnChanges {\r\n    private _validator;\r\n    private _onChange?;\r\n    /**\r\n     * @description\r\n     * Tracks changes to the the maximum length bound to this directive.\r\n     */\r\n    maxlength: string | number;\r\n    /**\r\n     * @description\r\n     * A lifecycle method called when the directive's inputs change. For internal use\r\n     * only.\r\n     *\r\n     * @param changes A object of key/value pairs for the set of changed inputs.\r\n     */\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n    /**\r\n     * @description\r\n     * Method that validates whether the value exceeds\r\n     * the maximum length requirement.\r\n     */\r\n    validate(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * @description\r\n     * Registers a callback function to call when the validator inputs change.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnValidatorChange(fn: () => void): void;\r\n    private _createValidator;\r\n}\r\n\r\n/**\r\n * A directive that adds minimum length validation to controls marked with the\r\n * `minlength` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\r\n *\r\n * @see [Form Validation](guide/form-validation)\r\n *\r\n * @usageNotes\r\n *\r\n * ### Adding a minimum length validator\r\n *\r\n * The following example shows how to add a minimum length validator to an input attached to an\r\n * ngModel binding.\r\n *\r\n * ```html\r\n * <input name=\"firstName\" ngModel minlength=\"4\">\r\n * ```\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class MinLengthValidator implements Validator, OnChanges {\r\n    private _validator;\r\n    private _onChange?;\r\n    /**\r\n     * @description\r\n     * Tracks changes to the the minimum length bound to this directive.\r\n     */\r\n    minlength: string | number;\r\n    /**\r\n     * @description\r\n     * A lifecycle method called when the directive's inputs change. For internal use\r\n     * only.\r\n     *\r\n     * @param changes A object of key/value pairs for the set of changed inputs.\r\n     */\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n    /**\r\n     * @description\r\n     * Method that validates whether the value meets a minimum length\r\n     * requirement. Returns the validation result if enabled, otherwise null.\r\n     */\r\n    validate(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * @description\r\n     * Registers a callback function to call when the validator inputs change.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnValidatorChange(fn: () => void): void;\r\n    private _createValidator;\r\n}\r\n\r\n/**\r\n * @description\r\n * An `InjectionToken` for registering additional asynchronous validators used with\r\n * `AbstractControl`s.\r\n *\r\n * @see `NG_VALIDATORS`\r\n *\r\n * @publicApi\r\n */\r\nexport declare const NG_ASYNC_VALIDATORS: InjectionToken<(Function | Validator)[]>;\r\n\r\n/**\r\n * @description\r\n * An `InjectionToken` for registering additional synchronous validators used with\r\n * `AbstractControl`s.\r\n *\r\n * @see `NG_ASYNC_VALIDATORS`\r\n *\r\n * @usageNotes\r\n *\r\n * ### Providing a custom validator\r\n *\r\n * The following example registers a custom validator directive. Adding the validator to the\r\n * existing collection of validators requires the `multi: true` option.\r\n *\r\n * ```typescript\r\n * @Directive({\r\n *   selector: '[customValidator]',\r\n *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]\r\n * })\r\n * class CustomValidatorDirective implements Validator {\r\n *   validate(control: AbstractControl): ValidationErrors | null {\r\n *     return { 'custom': true };\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare const NG_VALIDATORS: InjectionToken<(Function | Validator)[]>;\r\n\r\n/**\r\n * Used to provide a `ControlValueAccessor` for form controls.\r\n *\r\n * See `DefaultValueAccessor` for how to implement one.\r\n *\r\n * @publicApi\r\n */\r\nexport declare const NG_VALUE_ACCESSOR: InjectionToken<ControlValueAccessor>;\r\n\r\n/**\r\n * @description\r\n * A base class that all control `FormControl`-based directives extend. It binds a `FormControl`\r\n * object to a DOM element.\r\n *\r\n * @publicApi\r\n */\r\nexport declare abstract class NgControl extends AbstractControlDirective {\r\n    /**\r\n     * @description\r\n     * The name for the control\r\n     */\r\n    name: string | number | null;\r\n    /**\r\n     * @description\r\n     * The value accessor for the control\r\n     */\r\n    valueAccessor: ControlValueAccessor | null;\r\n    /**\r\n     * @description\r\n     * The registered synchronous validator function for the control\r\n     *\r\n     * @throws An exception that this method is not implemented\r\n     */\r\n    get validator(): ValidatorFn | null;\r\n    /**\r\n     * @description\r\n     * The registered async validator function for the control\r\n     *\r\n     * @throws An exception that this method is not implemented\r\n     */\r\n    get asyncValidator(): AsyncValidatorFn | null;\r\n    /**\r\n     * @description\r\n     * The callback method to update the model from the view when requested\r\n     *\r\n     * @param newValue The new value for the view\r\n     */\r\n    abstract viewToModelUpdate(newValue: any): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * Directive automatically applied to Angular form controls that sets CSS classes\r\n * based on control status.\r\n *\r\n * @usageNotes\r\n *\r\n * ### CSS classes applied\r\n *\r\n * The following classes are applied as the properties become true:\r\n *\r\n * * ng-valid\r\n * * ng-invalid\r\n * * ng-pending\r\n * * ng-pristine\r\n * * ng-dirty\r\n * * ng-untouched\r\n * * ng-touched\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class NgControlStatus extends ɵangular_packages_forms_forms_g {\r\n    constructor(cd: NgControl);\r\n}\r\n\r\n/**\r\n * @description\r\n * Directive automatically applied to Angular form groups that sets CSS classes\r\n * based on control status (valid/invalid/dirty/etc).\r\n *\r\n * @see `NgControlStatus`\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class NgControlStatusGroup extends ɵangular_packages_forms_forms_g {\r\n    constructor(cd: ControlContainer);\r\n}\r\n\r\n/**\r\n * @description\r\n * Creates a top-level `FormGroup` instance and binds it to a form\r\n * to track aggregate form value and validation status.\r\n *\r\n * As soon as you import the `FormsModule`, this directive becomes active by default on\r\n * all `<form>` tags.  You don't need to add a special selector.\r\n *\r\n * You optionally export the directive into a local template variable using `ngForm` as the key\r\n * (ex: `#myForm=\"ngForm\"`). This is optional, but useful.  Many properties from the underlying\r\n * `FormGroup` instance are duplicated on the directive itself, so a reference to it\r\n * gives you access to the aggregate value and validity status of the form, as well as\r\n * user interaction properties like `dirty` and `touched`.\r\n *\r\n * To register child controls with the form, use `NgModel` with a `name`\r\n * attribute. You may use `NgModelGroup` to create sub-groups within the form.\r\n *\r\n * If necessary, listen to the directive's `ngSubmit` event to be notified when the user has\r\n * triggered a form submission. The `ngSubmit` event emits the original form\r\n * submission event.\r\n *\r\n * In template driven forms, all `<form>` tags are automatically tagged as `NgForm`.\r\n * To import the `FormsModule` but skip its usage in some forms,\r\n * for example, to use native HTML5 validation, add the `ngNoForm` and the `<form>`\r\n * tags won't create an `NgForm` directive. In reactive forms, using `ngNoForm` is\r\n * unnecessary because the `<form>` tags are inert. In that case, you would\r\n * refrain from using the `formGroup` directive.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Listening for form submission\r\n *\r\n * The following example shows how to capture the form values from the \"ngSubmit\" event.\r\n *\r\n * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}\r\n *\r\n * ### Setting the update options\r\n *\r\n * The following example shows you how to change the \"updateOn\" option from its default using\r\n * ngFormOptions.\r\n *\r\n * ```html\r\n * <form [ngFormOptions]=\"{updateOn: 'blur'}\">\r\n *    <input name=\"one\" ngModel>  <!-- this ngModel will update on blur -->\r\n * </form>\r\n * ```\r\n *\r\n * ### Native DOM validation UI\r\n *\r\n * In order to prevent the native DOM form validation UI from interfering with Angular's form\r\n * validation, Angular automatically adds the `novalidate` attribute on any `<form>` whenever\r\n * `FormModule` or `ReactiveFormModule` are imported into the application.\r\n * If you want to explicitly enable native DOM validation UI with Angular forms, you can add the\r\n * `ngNativeValidate` attribute to the `<form>` element:\r\n *\r\n * ```html\r\n * <form ngNativeValidate>\r\n *   ...\r\n * </form>\r\n * ```\r\n *\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class NgForm extends ControlContainer implements Form, AfterViewInit {\r\n    /**\r\n     * @description\r\n     * Returns whether the form submission has been triggered.\r\n     */\r\n    readonly submitted: boolean;\r\n    private _directives;\r\n    /**\r\n     * @description\r\n     * The `FormGroup` instance created for this form.\r\n     */\r\n    form: FormGroup;\r\n    /**\r\n     * @description\r\n     * Event emitter for the \"ngSubmit\" event\r\n     */\r\n    ngSubmit: EventEmitter<any>;\r\n    /**\r\n     * @description\r\n     * Tracks options for the `NgForm` instance.\r\n     *\r\n     * **updateOn**: Sets the default `updateOn` value for all child `NgModels` below it\r\n     * unless explicitly set by a child `NgModel` using `ngModelOptions`). Defaults to 'change'.\r\n     * Possible values: `'change'` | `'blur'` | `'submit'`.\r\n     *\r\n     */\r\n    options: {\r\n        updateOn?: FormHooks;\r\n    };\r\n    constructor(validators: any[], asyncValidators: any[]);\r\n    /**\r\n     * @description\r\n     * Lifecycle method called after the view is initialized. For internal use only.\r\n     */\r\n    ngAfterViewInit(): void;\r\n    /**\r\n     * @description\r\n     * The directive instance.\r\n     */\r\n    get formDirective(): Form;\r\n    /**\r\n     * @description\r\n     * The internal `FormGroup` instance.\r\n     */\r\n    get control(): FormGroup;\r\n    /**\r\n     * @description\r\n     * Returns an array representing the path to this group. Because this directive\r\n     * always lives at the top level of a form, it is always an empty array.\r\n     */\r\n    get path(): string[];\r\n    /**\r\n     * @description\r\n     * Returns a map of the controls in this group.\r\n     */\r\n    get controls(): {\r\n        [key: string]: AbstractControl;\r\n    };\r\n    /**\r\n     * @description\r\n     * Method that sets up the control directive in this group, re-calculates its value\r\n     * and validity, and adds the instance to the internal list of directives.\r\n     *\r\n     * @param dir The `NgModel` directive instance.\r\n     */\r\n    addControl(dir: NgModel): void;\r\n    /**\r\n     * @description\r\n     * Retrieves the `FormControl` instance from the provided `NgModel` directive.\r\n     *\r\n     * @param dir The `NgModel` directive instance.\r\n     */\r\n    getControl(dir: NgModel): FormControl;\r\n    /**\r\n     * @description\r\n     * Removes the `NgModel` instance from the internal list of directives\r\n     *\r\n     * @param dir The `NgModel` directive instance.\r\n     */\r\n    removeControl(dir: NgModel): void;\r\n    /**\r\n     * @description\r\n     * Adds a new `NgModelGroup` directive instance to the form.\r\n     *\r\n     * @param dir The `NgModelGroup` directive instance.\r\n     */\r\n    addFormGroup(dir: NgModelGroup): void;\r\n    /**\r\n     * @description\r\n     * Removes the `NgModelGroup` directive instance from the form.\r\n     *\r\n     * @param dir The `NgModelGroup` directive instance.\r\n     */\r\n    removeFormGroup(dir: NgModelGroup): void;\r\n    /**\r\n     * @description\r\n     * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance\r\n     *\r\n     * @param dir The `NgModelGroup` directive instance.\r\n     */\r\n    getFormGroup(dir: NgModelGroup): FormGroup;\r\n    /**\r\n     * Sets the new value for the provided `NgControl` directive.\r\n     *\r\n     * @param dir The `NgControl` directive instance.\r\n     * @param value The new value for the directive's control.\r\n     */\r\n    updateModel(dir: NgControl, value: any): void;\r\n    /**\r\n     * @description\r\n     * Sets the value for this `FormGroup`.\r\n     *\r\n     * @param value The new value\r\n     */\r\n    setValue(value: {\r\n        [key: string]: any;\r\n    }): void;\r\n    /**\r\n     * @description\r\n     * Method called when the \"submit\" event is triggered on the form.\r\n     * Triggers the `ngSubmit` emitter to emit the \"submit\" event as its payload.\r\n     *\r\n     * @param $event The \"submit\" event object\r\n     */\r\n    onSubmit($event: Event): boolean;\r\n    /**\r\n     * @description\r\n     * Method called when the \"reset\" event is triggered on the form.\r\n     */\r\n    onReset(): void;\r\n    /**\r\n     * @description\r\n     * Resets the form to an initial value and resets its submitted status.\r\n     *\r\n     * @param value The new value for the form.\r\n     */\r\n    resetForm(value?: any): void;\r\n    private _setUpdateStrategy;\r\n}\r\n\r\n/**\r\n * @description\r\n * Creates a `FormControl` instance from a domain model and binds it\r\n * to a form control element.\r\n *\r\n * The `FormControl` instance tracks the value, user interaction, and\r\n * validation status of the control and keeps the view synced with the model. If used\r\n * within a parent form, the directive also registers itself with the form as a child\r\n * control.\r\n *\r\n * This directive is used by itself or as part of a larger form. Use the\r\n * `ngModel` selector to activate it.\r\n *\r\n * It accepts a domain model as an optional `Input`. If you have a one-way binding\r\n * to `ngModel` with `[]` syntax, changing the value of the domain model in the component\r\n * class sets the value in the view. If you have a two-way binding with `[()]` syntax\r\n * (also known as 'banana-box syntax'), the value in the UI always syncs back to\r\n * the domain model in your class.\r\n *\r\n * To inspect the properties of the associated `FormControl` (like validity state),\r\n * export the directive into a local template variable using `ngModel` as the key (ex:\r\n * `#myVar=\"ngModel\"`). You then access the control using the directive's `control` property, but\r\n * most properties used (like `valid` and `dirty`) fall through to the control anyway for direct\r\n * access. See a full list of properties directly available in `AbstractControlDirective`.\r\n *\r\n * @see `RadioControlValueAccessor`\r\n * @see `SelectControlValueAccessor`\r\n *\r\n * @usageNotes\r\n *\r\n * ### Using ngModel on a standalone control\r\n *\r\n * The following examples show a simple standalone control using `ngModel`:\r\n *\r\n * {@example forms/ts/simpleNgModel/simple_ng_model_example.ts region='Component'}\r\n *\r\n * When using the `ngModel` within `<form>` tags, you'll also need to supply a `name` attribute\r\n * so that the control can be registered with the parent form under that name.\r\n *\r\n * In the context of a parent form, it's often unnecessary to include one-way or two-way binding,\r\n * as the parent form syncs the value for you. You access its properties by exporting it into a\r\n * local template variable using `ngForm` such as (`#f=\"ngForm\"`). Use the variable where\r\n * needed on form submission.\r\n *\r\n * If you do need to populate initial values into your form, using a one-way binding for\r\n * `ngModel` tends to be sufficient as long as you use the exported form's value rather\r\n * than the domain model's value on submit.\r\n *\r\n * ### Using ngModel within a form\r\n *\r\n * The following example shows controls using `ngModel` within a form:\r\n *\r\n * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}\r\n *\r\n * ### Using a standalone ngModel within a group\r\n *\r\n * The following example shows you how to use a standalone ngModel control\r\n * within a form. This controls the display of the form, but doesn't contain form data.\r\n *\r\n * ```html\r\n * <form>\r\n *   <input name=\"login\" ngModel placeholder=\"Login\">\r\n *   <input type=\"checkbox\" ngModel [ngModelOptions]=\"{standalone: true}\"> Show more options?\r\n * </form>\r\n * <!-- form value: {login: ''} -->\r\n * ```\r\n *\r\n * ### Setting the ngModel name attribute through options\r\n *\r\n * The following example shows you an alternate way to set the name attribute. The name attribute is\r\n * used within a custom form component, and the name `@Input` property serves a different purpose.\r\n *\r\n * ```html\r\n * <form>\r\n *   <my-person-control name=\"Nancy\" ngModel [ngModelOptions]=\"{name: 'user'}\">\r\n *   </my-person-control>\r\n * </form>\r\n * <!-- form value: {user: ''} -->\r\n * ```\r\n *\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class NgModel extends NgControl implements OnChanges, OnDestroy {\r\n    readonly control: FormControl;\r\n    /** @nodoc */\r\n    static ngAcceptInputType_isDisabled: boolean | string;\r\n    /**\r\n     * @description\r\n     * Internal reference to the view model value.\r\n     */\r\n    viewModel: any;\r\n    /**\r\n     * @description\r\n     * Tracks the name bound to the directive. The parent form\r\n     * uses this name as a key to retrieve this control's value.\r\n     */\r\n    name: string;\r\n    /**\r\n     * @description\r\n     * Tracks whether the control is disabled.\r\n     */\r\n    isDisabled: boolean;\r\n    /**\r\n     * @description\r\n     * Tracks the value bound to this directive.\r\n     */\r\n    model: any;\r\n    /**\r\n     * @description\r\n     * Tracks the configuration options for this `ngModel` instance.\r\n     *\r\n     * **name**: An alternative to setting the name attribute on the form control element. See\r\n     * the [example](api/forms/NgModel#using-ngmodel-on-a-standalone-control) for using `NgModel`\r\n     * as a standalone control.\r\n     *\r\n     * **standalone**: When set to true, the `ngModel` will not register itself with its parent form,\r\n     * and acts as if it's not in the form. Defaults to false.\r\n     *\r\n     * **updateOn**: Defines the event upon which the form control value and validity update.\r\n     * Defaults to 'change'. Possible values: `'change'` | `'blur'` | `'submit'`.\r\n     *\r\n     */\r\n    options: {\r\n        name?: string;\r\n        standalone?: boolean;\r\n        updateOn?: FormHooks;\r\n    };\r\n    /**\r\n     * @description\r\n     * Event emitter for producing the `ngModelChange` event after\r\n     * the view model updates.\r\n     */\r\n    update: EventEmitter<any>;\r\n    constructor(parent: ControlContainer, validators: Array<Validator | ValidatorFn>, asyncValidators: Array<AsyncValidator | AsyncValidatorFn>, valueAccessors: ControlValueAccessor[]);\r\n    /**\r\n     * @description\r\n     * A lifecycle method called when the directive's inputs change. For internal use\r\n     * only.\r\n     *\r\n     * @param changes A object of key/value pairs for the set of changed inputs.\r\n     */\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n    /**\r\n     * @description\r\n     * Lifecycle method called before the directive's instance is destroyed. For internal\r\n     * use only.\r\n     */\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * @description\r\n     * Returns an array that represents the path from the top-level form to this control.\r\n     * Each index is the string name of the control on that level.\r\n     */\r\n    get path(): string[];\r\n    /**\r\n     * @description\r\n     * The top-level directive for this control if present, otherwise null.\r\n     */\r\n    get formDirective(): any;\r\n    /**\r\n     * @description\r\n     * Synchronous validator function composed of all the synchronous validators\r\n     * registered with this directive.\r\n     */\r\n    get validator(): ValidatorFn | null;\r\n    /**\r\n     * @description\r\n     * Async validator function composed of all the async validators registered with this\r\n     * directive.\r\n     */\r\n    get asyncValidator(): AsyncValidatorFn | null;\r\n    /**\r\n     * @description\r\n     * Sets the new value for the view model and emits an `ngModelChange` event.\r\n     *\r\n     * @param newValue The new value emitted by `ngModelChange`.\r\n     */\r\n    viewToModelUpdate(newValue: any): void;\r\n    private _setUpControl;\r\n    private _setUpdateStrategy;\r\n    private _isStandalone;\r\n    private _setUpStandalone;\r\n    private _checkForErrors;\r\n    private _checkParentType;\r\n    private _checkName;\r\n    private _updateValue;\r\n    private _updateDisabled;\r\n}\r\n\r\n/**\r\n * @description\r\n * Creates and binds a `FormGroup` instance to a DOM element.\r\n *\r\n * This directive can only be used as a child of `NgForm` (within `<form>` tags).\r\n *\r\n * Use this directive to validate a sub-group of your form separately from the\r\n * rest of your form, or if some values in your domain model make more sense\r\n * to consume together in a nested object.\r\n *\r\n * Provide a name for the sub-group and it will become the key\r\n * for the sub-group in the form's full value. If you need direct access, export the directive into\r\n * a local template variable using `ngModelGroup` (ex: `#myGroup=\"ngModelGroup\"`).\r\n *\r\n * @usageNotes\r\n *\r\n * ### Consuming controls in a grouping\r\n *\r\n * The following example shows you how to combine controls together in a sub-group\r\n * of the form.\r\n *\r\n * {@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}\r\n *\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class NgModelGroup extends AbstractFormGroupDirective implements OnInit, OnDestroy {\r\n    /**\r\n     * @description\r\n     * Tracks the name of the `NgModelGroup` bound to the directive. The name corresponds\r\n     * to a key in the parent `NgForm`.\r\n     */\r\n    name: string;\r\n    constructor(parent: ControlContainer, validators: any[], asyncValidators: any[]);\r\n}\r\n\r\n/**\r\n * @description\r\n * Marks `<option>` as dynamic, so Angular can be notified when options change.\r\n *\r\n * @see `SelectControlValueAccessor`\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class NgSelectOption implements OnDestroy {\r\n    private _element;\r\n    private _renderer;\r\n    private _select;\r\n    /**\r\n     * @description\r\n     * ID of the option element\r\n     */\r\n    id: string;\r\n    constructor(_element: ElementRef, _renderer: Renderer2, _select: SelectControlValueAccessor);\r\n    /**\r\n     * @description\r\n     * Tracks the value bound to the option element. Unlike the value binding,\r\n     * ngValue supports binding to objects.\r\n     */\r\n    set ngValue(value: any);\r\n    /**\r\n     * @description\r\n     * Tracks simple string values bound to the option element.\r\n     * For objects, use the `ngValue` input binding.\r\n     */\r\n    set value(value: any);\r\n    /**\r\n     * @description\r\n     * Lifecycle method called before the directive's instance is destroyed. For internal use only.\r\n     */\r\n    ngOnDestroy(): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * The `ControlValueAccessor` for writing a number value and listening to number input changes.\r\n * The value accessor is used by the `FormControlDirective`, `FormControlName`, and  `NgModel`\r\n * directives.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Using a number input with a reactive form.\r\n *\r\n * The following example shows how to use a number input with a reactive form.\r\n *\r\n * ```ts\r\n * const totalCountControl = new FormControl();\r\n * ```\r\n *\r\n * ```\r\n * <input type=\"number\" [formControl]=\"totalCountControl\">\r\n * ```\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class NumberValueAccessor implements ControlValueAccessor {\r\n    private _renderer;\r\n    private _elementRef;\r\n    /**\r\n     * @description\r\n     * The registered callback function called when a change or input event occurs on the input\r\n     * element.\r\n     */\r\n    onChange: (_: any) => void;\r\n    /**\r\n     * @description\r\n     * The registered callback function called when a blur event occurs on the input element.\r\n     */\r\n    onTouched: () => void;\r\n    constructor(_renderer: Renderer2, _elementRef: ElementRef);\r\n    /**\r\n     * Sets the \"value\" property on the input element.\r\n     *\r\n     * @param value The checked value\r\n     */\r\n    writeValue(value: number): void;\r\n    /**\r\n     * @description\r\n     * Registers a function called when the control value changes.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnChange(fn: (_: number | null) => void): void;\r\n    /**\r\n     * @description\r\n     * Registers a function called when the control is touched.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnTouched(fn: () => void): void;\r\n    /**\r\n     * Sets the \"disabled\" property on the input element.\r\n     *\r\n     * @param isDisabled The disabled value\r\n     */\r\n    setDisabledState(isDisabled: boolean): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * A directive that adds regex pattern validation to controls marked with the\r\n * `pattern` attribute. The regex must match the entire control value.\r\n * The directive is provided with the `NG_VALIDATORS` multi-provider list.\r\n *\r\n * @see [Form Validation](guide/form-validation)\r\n *\r\n * @usageNotes\r\n *\r\n * ### Adding a pattern validator\r\n *\r\n * The following example shows how to add a pattern validator to an input attached to an\r\n * ngModel binding.\r\n *\r\n * ```html\r\n * <input name=\"firstName\" ngModel pattern=\"[a-zA-Z ]*\">\r\n * ```\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class PatternValidator implements Validator, OnChanges {\r\n    private _validator;\r\n    private _onChange?;\r\n    /**\r\n     * @description\r\n     * Tracks changes to the pattern bound to this directive.\r\n     */\r\n    pattern: string | RegExp;\r\n    /**\r\n     * @description\r\n     * A lifecycle method called when the directive's inputs change. For internal use\r\n     * only.\r\n     *\r\n     * @param changes A object of key/value pairs for the set of changed inputs.\r\n     */\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n    /**\r\n     * @description\r\n     * Method that validates whether the value matches the\r\n     * the pattern requirement.\r\n     */\r\n    validate(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * @description\r\n     * Registers a callback function to call when the validator inputs change.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnValidatorChange(fn: () => void): void;\r\n    private _createValidator;\r\n}\r\n\r\n/**\r\n * @description\r\n * The `ControlValueAccessor` for writing radio control values and listening to radio control\r\n * changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and\r\n * `NgModel` directives.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Using radio buttons with reactive form directives\r\n *\r\n * The follow example shows how to use radio buttons in a reactive form. When using radio buttons in\r\n * a reactive form, radio buttons in the same group should have the same `formControlName`.\r\n * Providing a `name` attribute is optional.\r\n *\r\n * {@example forms/ts/reactiveRadioButtons/reactive_radio_button_example.ts region='Reactive'}\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class RadioControlValueAccessor implements ControlValueAccessor, OnDestroy, OnInit {\r\n    private _renderer;\r\n    private _elementRef;\r\n    private _registry;\r\n    private _injector;\r\n    /**\r\n     * @description\r\n     * The registered callback function called when a change event occurs on the input element.\r\n     */\r\n    onChange: () => void;\r\n    /**\r\n     * @description\r\n     * The registered callback function called when a blur event occurs on the input element.\r\n     */\r\n    onTouched: () => void;\r\n    /**\r\n     * @description\r\n     * Tracks the name of the radio input element.\r\n     */\r\n    name: string;\r\n    /**\r\n     * @description\r\n     * Tracks the name of the `FormControl` bound to the directive. The name corresponds\r\n     * to a key in the parent `FormGroup` or `FormArray`.\r\n     */\r\n    formControlName: string;\r\n    /**\r\n     * @description\r\n     * Tracks the value of the radio input element\r\n     */\r\n    value: any;\r\n    constructor(_renderer: Renderer2, _elementRef: ElementRef, _registry: ɵangular_packages_forms_forms_n, _injector: Injector);\r\n    /**\r\n     * @description\r\n     * A lifecycle method called when the directive is initialized. For internal use only.\r\n     */\r\n    ngOnInit(): void;\r\n    /**\r\n     * @description\r\n     * Lifecycle method called before the directive's instance is destroyed. For internal use only.\r\n     */\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * @description\r\n     * Sets the \"checked\" property value on the radio input element.\r\n     *\r\n     * @param value The checked value\r\n     */\r\n    writeValue(value: any): void;\r\n    /**\r\n     * @description\r\n     * Registers a function called when the control value changes.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnChange(fn: (_: any) => {}): void;\r\n    /**\r\n     * Sets the \"value\" on the radio input element and unchecks it.\r\n     *\r\n     * @param value\r\n     */\r\n    fireUncheck(value: any): void;\r\n    /**\r\n     * @description\r\n     * Registers a function called when the control is touched.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnTouched(fn: () => {}): void;\r\n    /**\r\n     * Sets the \"disabled\" property on the input element.\r\n     *\r\n     * @param isDisabled The disabled value\r\n     */\r\n    setDisabledState(isDisabled: boolean): void;\r\n    private _checkName;\r\n    private _throwNameError;\r\n}\r\n\r\n/**\r\n * @description\r\n * The `ControlValueAccessor` for writing a range value and listening to range input changes.\r\n * The value accessor is used by the `FormControlDirective`, `FormControlName`, and  `NgModel`\r\n * directives.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Using a range input with a reactive form\r\n *\r\n * The following example shows how to use a range input with a reactive form.\r\n *\r\n * ```ts\r\n * const ageControl = new FormControl();\r\n * ```\r\n *\r\n * ```\r\n * <input type=\"range\" [formControl]=\"ageControl\">\r\n * ```\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class RangeValueAccessor implements ControlValueAccessor {\r\n    private _renderer;\r\n    private _elementRef;\r\n    /**\r\n     * @description\r\n     * The registered callback function called when a change or input event occurs on the input\r\n     * element.\r\n     */\r\n    onChange: (_: any) => void;\r\n    /**\r\n     * @description\r\n     * The registered callback function called when a blur event occurs on the input element.\r\n     */\r\n    onTouched: () => void;\r\n    constructor(_renderer: Renderer2, _elementRef: ElementRef);\r\n    /**\r\n     * Sets the \"value\" property on the input element.\r\n     *\r\n     * @param value The checked value\r\n     */\r\n    writeValue(value: any): void;\r\n    /**\r\n     * @description\r\n     * Registers a function called when the control value changes.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnChange(fn: (_: number | null) => void): void;\r\n    /**\r\n     * @description\r\n     * Registers a function called when the control is touched.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnTouched(fn: () => void): void;\r\n    /**\r\n     * Sets the \"disabled\" property on the range input element.\r\n     *\r\n     * @param isDisabled The disabled value\r\n     */\r\n    setDisabledState(isDisabled: boolean): void;\r\n}\r\n\r\n/**\r\n * Exports the required infrastructure and directives for reactive forms,\r\n * making them available for import by NgModules that import this module.\r\n *\r\n * @see [Forms Overview](guide/forms-overview)\r\n * @see [Reactive Forms Guide](guide/reactive-forms)\r\n *\r\n * @publicApi\r\n */\r\nexport declare class ReactiveFormsModule {\r\n    /**\r\n     * @description\r\n     * Provides options for configuring the reactive forms module.\r\n     *\r\n     * @param opts An object of configuration options\r\n     * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`\r\n     * binding is used with reactive form directives.\r\n     */\r\n    static withConfig(opts: {\r\n        /** @deprecated as of v6 */ warnOnNgModelWithFormControl: 'never' | 'once' | 'always';\r\n    }): ModuleWithProviders<ReactiveFormsModule>;\r\n}\r\n\r\n/**\r\n * @description\r\n * A directive that adds the `required` validator to any controls marked with the\r\n * `required` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\r\n *\r\n * @see [Form Validation](guide/form-validation)\r\n *\r\n * @usageNotes\r\n *\r\n * ### Adding a required validator using template-driven forms\r\n *\r\n * ```\r\n * <input name=\"fullName\" ngModel required>\r\n * ```\r\n *\r\n * @ngModule FormsModule\r\n * @ngModule ReactiveFormsModule\r\n * @publicApi\r\n */\r\nexport declare class RequiredValidator implements Validator {\r\n    private _required;\r\n    private _onChange?;\r\n    /**\r\n     * @description\r\n     * Tracks changes to the required attribute bound to this directive.\r\n     */\r\n    get required(): boolean | string;\r\n    set required(value: boolean | string);\r\n    /**\r\n     * @description\r\n     * Method that validates whether the control is empty.\r\n     * Returns the validation result if enabled, otherwise null.\r\n     */\r\n    validate(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * @description\r\n     * Registers a callback function to call when the validator inputs change.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnValidatorChange(fn: () => void): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * The `ControlValueAccessor` for writing select control values and listening to select control\r\n * changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and\r\n * `NgModel` directives.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Using select controls in a reactive form\r\n *\r\n * The following examples show how to use a select control in a reactive form.\r\n *\r\n * {@example forms/ts/reactiveSelectControl/reactive_select_control_example.ts region='Component'}\r\n *\r\n * ### Using select controls in a template-driven form\r\n *\r\n * To use a select in a template-driven form, simply add an `ngModel` and a `name`\r\n * attribute to the main `<select>` tag.\r\n *\r\n * {@example forms/ts/selectControl/select_control_example.ts region='Component'}\r\n *\r\n * ### Customizing option selection\r\n *\r\n * Angular uses object identity to select option. It's possible for the identities of items\r\n * to change while the data does not. This can happen, for example, if the items are produced\r\n * from an RPC to the server, and that RPC is re-run. Even if the data hasn't changed, the\r\n * second response will produce objects with different identities.\r\n *\r\n * To customize the default option comparison algorithm, `<select>` supports `compareWith` input.\r\n * `compareWith` takes a **function** which has two arguments: `option1` and `option2`.\r\n * If `compareWith` is given, Angular selects option by the return value of the function.\r\n *\r\n * ```ts\r\n * const selectedCountriesControl = new FormControl();\r\n * ```\r\n *\r\n * ```\r\n * <select [compareWith]=\"compareFn\"  [formControl]=\"selectedCountriesControl\">\r\n *     <option *ngFor=\"let country of countries\" [ngValue]=\"country\">\r\n *         {{country.name}}\r\n *     </option>\r\n * </select>\r\n *\r\n * compareFn(c1: Country, c2: Country): boolean {\r\n *     return c1 && c2 ? c1.id === c2.id : c1 === c2;\r\n * }\r\n * ```\r\n *\r\n * **Note:** We listen to the 'change' event because 'input' events aren't fired\r\n * for selects in Firefox and IE:\r\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1024350\r\n * https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/4660045/\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class SelectControlValueAccessor implements ControlValueAccessor {\r\n    private _renderer;\r\n    private _elementRef;\r\n    value: any;\r\n    /**\r\n     * @description\r\n     * The registered callback function called when a change event occurs on the input element.\r\n     */\r\n    onChange: (_: any) => void;\r\n    /**\r\n     * @description\r\n     * The registered callback function called when a blur event occurs on the input element.\r\n     */\r\n    onTouched: () => void;\r\n    /**\r\n     * @description\r\n     * Tracks the option comparison algorithm for tracking identities when\r\n     * checking for changes.\r\n     */\r\n    set compareWith(fn: (o1: any, o2: any) => boolean);\r\n    private _compareWith;\r\n    constructor(_renderer: Renderer2, _elementRef: ElementRef);\r\n    /**\r\n     * Sets the \"value\" property on the input element. The \"selectedIndex\"\r\n     * property is also set if an ID is provided on the option element.\r\n     *\r\n     * @param value The checked value\r\n     */\r\n    writeValue(value: any): void;\r\n    /**\r\n     * @description\r\n     * Registers a function called when the control value changes.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnChange(fn: (value: any) => any): void;\r\n    /**\r\n     * @description\r\n     * Registers a function called when the control is touched.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnTouched(fn: () => any): void;\r\n    /**\r\n     * Sets the \"disabled\" property on the select input element.\r\n     *\r\n     * @param isDisabled The disabled value\r\n     */\r\n    setDisabledState(isDisabled: boolean): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * The `ControlValueAccessor` for writing multi-select control values and listening to multi-select\r\n * control changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and\r\n * `NgModel` directives.\r\n *\r\n * @see `SelectControlValueAccessor`\r\n *\r\n * @usageNotes\r\n *\r\n * ### Using a multi-select control\r\n *\r\n * The follow example shows you how to use a multi-select control with a reactive form.\r\n *\r\n * ```ts\r\n * const countryControl = new FormControl();\r\n * ```\r\n *\r\n * ```\r\n * <select multiple name=\"countries\" [formControl]=\"countryControl\">\r\n *   <option *ngFor=\"let country of countries\" [ngValue]=\"country\">\r\n *     {{ country.name }}\r\n *   </option>\r\n * </select>\r\n * ```\r\n *\r\n * ### Customizing option selection\r\n *\r\n * To customize the default option comparison algorithm, `<select>` supports `compareWith` input.\r\n * See the `SelectControlValueAccessor` for usage.\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\nexport declare class SelectMultipleControlValueAccessor implements ControlValueAccessor {\r\n    private _renderer;\r\n    private _elementRef;\r\n    /**\r\n     * @description\r\n     * The current value\r\n     */\r\n    value: any;\r\n    /**\r\n     * @description\r\n     * The registered callback function called when a change event occurs on the input element.\r\n     */\r\n    onChange: (_: any) => void;\r\n    /**\r\n     * @description\r\n     * The registered callback function called when a blur event occurs on the input element.\r\n     */\r\n    onTouched: () => void;\r\n    /**\r\n     * @description\r\n     * Tracks the option comparison algorithm for tracking identities when\r\n     * checking for changes.\r\n     */\r\n    set compareWith(fn: (o1: any, o2: any) => boolean);\r\n    private _compareWith;\r\n    constructor(_renderer: Renderer2, _elementRef: ElementRef);\r\n    /**\r\n     * @description\r\n     * Sets the \"value\" property on one or of more\r\n     * of the select's options.\r\n     *\r\n     * @param value The value\r\n     */\r\n    writeValue(value: any): void;\r\n    /**\r\n     * @description\r\n     * Registers a function called when the control value changes\r\n     * and writes an array of the selected options.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnChange(fn: (value: any) => any): void;\r\n    /**\r\n     * @description\r\n     * Registers a function called when the control is touched.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnTouched(fn: () => any): void;\r\n    /**\r\n     * Sets the \"disabled\" property on the select input element.\r\n     *\r\n     * @param isDisabled The disabled value\r\n     */\r\n    setDisabledState(isDisabled: boolean): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * Defines the map of errors returned from failed validation checks.\r\n *\r\n * @publicApi\r\n */\r\nexport declare type ValidationErrors = {\r\n    [key: string]: any;\r\n};\r\n\r\n/**\r\n * @description\r\n * An interface implemented by classes that perform synchronous validation.\r\n *\r\n * @usageNotes\r\n *\r\n * ### Provide a custom validator\r\n *\r\n * The following example implements the `Validator` interface to create a\r\n * validator directive with a custom error key.\r\n *\r\n * ```typescript\r\n * @Directive({\r\n *   selector: '[customValidator]',\r\n *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]\r\n * })\r\n * class CustomValidatorDirective implements Validator {\r\n *   validate(control: AbstractControl): ValidationErrors|null {\r\n *     return {'custom': true};\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface Validator {\r\n    /**\r\n     * @description\r\n     * Method that performs synchronous validation against the provided control.\r\n     *\r\n     * @param control The control to validate against.\r\n     *\r\n     * @returns A map of validation errors if validation fails,\r\n     * otherwise null.\r\n     */\r\n    validate(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * @description\r\n     * Registers a callback function to call when the validator inputs change.\r\n     *\r\n     * @param fn The callback function\r\n     */\r\n    registerOnValidatorChange?(fn: () => void): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * A function that receives a control and synchronously returns a map of\r\n * validation errors if present, otherwise null.\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface ValidatorFn {\r\n    (control: AbstractControl): ValidationErrors | null;\r\n}\r\n\r\n/**\r\n * @description\r\n * Provides a set of built-in validators that can be used by form controls.\r\n *\r\n * A validator is a function that processes a `FormControl` or collection of\r\n * controls and returns an error map or null. A null map means that validation has passed.\r\n *\r\n * @see [Form Validation](/guide/form-validation)\r\n *\r\n * @publicApi\r\n */\r\nexport declare class Validators {\r\n    /**\r\n     * @description\r\n     * Validator that requires the control's value to be greater than or equal to the provided number.\r\n     * The validator exists only as a function and not as a directive.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Validate against a minimum of 3\r\n     *\r\n     * ```typescript\r\n     * const control = new FormControl(2, Validators.min(3));\r\n     *\r\n     * console.log(control.errors); // {min: {min: 3, actual: 2}}\r\n     * ```\r\n     *\r\n     * @returns A validator function that returns an error map with the\r\n     * `min` property if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static min(min: number): ValidatorFn;\r\n    /**\r\n     * @description\r\n     * Validator that requires the control's value to be less than or equal to the provided number.\r\n     * The validator exists only as a function and not as a directive.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Validate against a maximum of 15\r\n     *\r\n     * ```typescript\r\n     * const control = new FormControl(16, Validators.max(15));\r\n     *\r\n     * console.log(control.errors); // {max: {max: 15, actual: 16}}\r\n     * ```\r\n     *\r\n     * @returns A validator function that returns an error map with the\r\n     * `max` property if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static max(max: number): ValidatorFn;\r\n    /**\r\n     * @description\r\n     * Validator that requires the control have a non-empty value.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Validate that the field is non-empty\r\n     *\r\n     * ```typescript\r\n     * const control = new FormControl('', Validators.required);\r\n     *\r\n     * console.log(control.errors); // {required: true}\r\n     * ```\r\n     *\r\n     * @returns An error map with the `required` property\r\n     * if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static required(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * @description\r\n     * Validator that requires the control's value be true. This validator is commonly\r\n     * used for required checkboxes.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Validate that the field value is true\r\n     *\r\n     * ```typescript\r\n     * const control = new FormControl('', Validators.requiredTrue);\r\n     *\r\n     * console.log(control.errors); // {required: true}\r\n     * ```\r\n     *\r\n     * @returns An error map that contains the `required` property\r\n     * set to `true` if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static requiredTrue(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * @description\r\n     * Validator that requires the control's value pass an email validation test.\r\n     *\r\n     * Tests the value using a [regular\r\n     * expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)\r\n     * pattern suitable for common usecases. The pattern is based on the definition of a valid email\r\n     * address in the [WHATWG HTML\r\n     * specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with\r\n     * some enhancements to incorporate more RFC rules (such as rules related to domain names and the\r\n     * lengths of different parts of the address).\r\n     *\r\n     * The differences from the WHATWG version include:\r\n     * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).\r\n     * - Disallow `local-part` to be longer than 64 characters.\r\n     * - Disallow the whole address to be longer than 254 characters.\r\n     *\r\n     * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to\r\n     * validate the value against a different pattern.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Validate that the field matches a valid email pattern\r\n     *\r\n     * ```typescript\r\n     * const control = new FormControl('bad@', Validators.email);\r\n     *\r\n     * console.log(control.errors); // {email: true}\r\n     * ```\r\n     *\r\n     * @returns An error map with the `email` property\r\n     * if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static email(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * @description\r\n     * Validator that requires the length of the control's value to be greater than or equal\r\n     * to the provided minimum length. This validator is also provided by default if you use the\r\n     * the HTML5 `minlength` attribute. Note that the `minLength` validator is intended to be used\r\n     * only for types that have a numeric `length` property, such as strings or arrays. The\r\n     * `minLength` validator logic is also not invoked for values when their `length` property is 0\r\n     * (for example in case of an empty string or an empty array), to support optional controls. You\r\n     * can use the standard `required` validator if empty values should not be considered valid.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Validate that the field has a minimum of 3 characters\r\n     *\r\n     * ```typescript\r\n     * const control = new FormControl('ng', Validators.minLength(3));\r\n     *\r\n     * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}\r\n     * ```\r\n     *\r\n     * ```html\r\n     * <input minlength=\"5\">\r\n     * ```\r\n     *\r\n     * @returns A validator function that returns an error map with the\r\n     * `minlength` if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static minLength(minLength: number): ValidatorFn;\r\n    /**\r\n     * @description\r\n     * Validator that requires the length of the control's value to be less than or equal\r\n     * to the provided maximum length. This validator is also provided by default if you use the\r\n     * the HTML5 `maxlength` attribute. Note that the `maxLength` validator is intended to be used\r\n     * only for types that have a numeric `length` property, such as strings or arrays.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Validate that the field has maximum of 5 characters\r\n     *\r\n     * ```typescript\r\n     * const control = new FormControl('Angular', Validators.maxLength(5));\r\n     *\r\n     * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}\r\n     * ```\r\n     *\r\n     * ```html\r\n     * <input maxlength=\"5\">\r\n     * ```\r\n     *\r\n     * @returns A validator function that returns an error map with the\r\n     * `maxlength` property if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static maxLength(maxLength: number): ValidatorFn;\r\n    /**\r\n     * @description\r\n     * Validator that requires the control's value to match a regex pattern. This validator is also\r\n     * provided by default if you use the HTML5 `pattern` attribute.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ### Validate that the field only contains letters or spaces\r\n     *\r\n     * ```typescript\r\n     * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));\r\n     *\r\n     * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}\r\n     * ```\r\n     *\r\n     * ```html\r\n     * <input pattern=\"[a-zA-Z ]*\">\r\n     * ```\r\n     *\r\n     * @param pattern A regular expression to be used as is to test the values, or a string.\r\n     * If a string is passed, the `^` character is prepended and the `$` character is\r\n     * appended to the provided string (if not already present), and the resulting regular\r\n     * expression is used to test the values.\r\n     *\r\n     * @returns A validator function that returns an error map with the\r\n     * `pattern` property if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static pattern(pattern: string | RegExp): ValidatorFn;\r\n    /**\r\n     * @description\r\n     * Validator that performs no operation.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static nullValidator(control: AbstractControl): ValidationErrors | null;\r\n    /**\r\n     * @description\r\n     * Compose multiple validators into a single function that returns the union\r\n     * of the individual error maps for the provided control.\r\n     *\r\n     * @returns A validator function that returns an error map with the\r\n     * merged error maps of the validators if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static compose(validators: null): null;\r\n    static compose(validators: (ValidatorFn | null | undefined)[]): ValidatorFn | null;\r\n    /**\r\n     * @description\r\n     * Compose multiple async validators into a single function that returns the union\r\n     * of the individual error objects for the provided control.\r\n     *\r\n     * @returns A validator function that returns an error map with the\r\n     * merged error objects of the async validators if the validation check fails, otherwise `null`.\r\n     *\r\n     * @see `updateValueAndValidity()`\r\n     *\r\n     */\r\n    static composeAsync(validators: (AsyncValidatorFn | null)[]): AsyncValidatorFn | null;\r\n}\r\n\r\n/**\r\n * @publicApi\r\n */\r\nexport declare const VERSION: Version;\r\n\r\nexport declare const ɵangular_packages_forms_forms_a: Type<any>[];\r\n\r\nexport declare const ɵangular_packages_forms_forms_b: Type<any>[];\r\n\r\n/**\r\n * @description\r\n * Provider which adds `CheckboxRequiredValidator` to the `NG_VALIDATORS` multi-provider list.\r\n */\r\nexport declare const ɵangular_packages_forms_forms_ba: StaticProvider;\r\n\r\n/**\r\n * @description\r\n * Provider which adds `EmailValidator` to the `NG_VALIDATORS` multi-provider list.\r\n */\r\nexport declare const ɵangular_packages_forms_forms_bb: any;\r\n\r\n/**\r\n * @description\r\n * Provider which adds `MinLengthValidator` to the `NG_VALIDATORS` multi-provider list.\r\n */\r\nexport declare const ɵangular_packages_forms_forms_bc: any;\r\n\r\n/**\r\n * @description\r\n * Provider which adds `MaxLengthValidator` to the `NG_VALIDATORS` multi-provider list.\r\n */\r\nexport declare const ɵangular_packages_forms_forms_bd: any;\r\n\r\n/**\r\n * @description\r\n * Provider which adds `PatternValidator` to the `NG_VALIDATORS` multi-provider list.\r\n */\r\nexport declare const ɵangular_packages_forms_forms_be: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_c: Type<any>[];\r\n\r\nexport declare const ɵangular_packages_forms_forms_e: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_f: any;\r\n\r\nexport declare class ɵangular_packages_forms_forms_g {\r\n    private _cd;\r\n    constructor(cd: AbstractControlDirective);\r\n    get ngClassUntouched(): boolean;\r\n    get ngClassTouched(): boolean;\r\n    get ngClassPristine(): boolean;\r\n    get ngClassDirty(): boolean;\r\n    get ngClassValid(): boolean;\r\n    get ngClassInvalid(): boolean;\r\n    get ngClassPending(): boolean;\r\n}\r\n\r\nexport declare const ɵangular_packages_forms_forms_h: {\r\n    '[class.ng-untouched]': string;\r\n    '[class.ng-touched]': string;\r\n    '[class.ng-pristine]': string;\r\n    '[class.ng-dirty]': string;\r\n    '[class.ng-valid]': string;\r\n    '[class.ng-invalid]': string;\r\n    '[class.ng-pending]': string;\r\n};\r\n\r\nexport declare const ɵangular_packages_forms_forms_i: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_j: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_k: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_l: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_m: any;\r\n\r\n/**\r\n * @description\r\n * Class used by Angular to track radio buttons. For internal use only.\r\n */\r\nexport declare class ɵangular_packages_forms_forms_n {\r\n    private _accessors;\r\n    /**\r\n     * @description\r\n     * Adds a control to the internal registry. For internal use only.\r\n     */\r\n    add(control: NgControl, accessor: RadioControlValueAccessor): void;\r\n    /**\r\n     * @description\r\n     * Removes a control from the internal registry. For internal use only.\r\n     */\r\n    remove(accessor: RadioControlValueAccessor): void;\r\n    /**\r\n     * @description\r\n     * Selects a radio button. For internal use only.\r\n     */\r\n    select(accessor: RadioControlValueAccessor): void;\r\n    private _isSameGroup;\r\n}\r\n\r\nexport declare const ɵangular_packages_forms_forms_o: StaticProvider;\r\n\r\n/**\r\n * Token to provide to turn off the ngModel warning on formControl and formControlName.\r\n */\r\nexport declare const ɵangular_packages_forms_forms_p: InjectionToken<unknown>;\r\n\r\nexport declare const ɵangular_packages_forms_forms_q: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_r: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_s: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_t: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_u: any;\r\n\r\nexport declare const ɵangular_packages_forms_forms_v: StaticProvider;\r\n\r\nexport declare const ɵangular_packages_forms_forms_w: StaticProvider;\r\n\r\n/**\r\n * @description\r\n * Provider which adds `RequiredValidator` to the `NG_VALIDATORS` multi-provider list.\r\n */\r\nexport declare const ɵangular_packages_forms_forms_z: StaticProvider;\r\n\r\n/**\r\n * Internal module used for sharing directives between FormsModule and ReactiveFormsModule\r\n */\r\ndeclare class ɵInternalFormsSharedModule {\r\n}\r\nexport { ɵInternalFormsSharedModule }\r\nexport { ɵInternalFormsSharedModule as ɵangular_packages_forms_forms_d }\r\n\r\n\r\n/**\r\n * @description\r\n *\r\n * Adds `novalidate` attribute to all forms by default.\r\n *\r\n * `novalidate` is used to disable browser's native form validation.\r\n *\r\n * If you want to use native validation with Angular forms, just add `ngNativeValidate` attribute:\r\n *\r\n * ```\r\n * <form ngNativeValidate></form>\r\n * ```\r\n *\r\n * @publicApi\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n */\r\ndeclare class ɵNgNoValidate {\r\n}\r\nexport { ɵNgNoValidate }\r\nexport { ɵNgNoValidate as ɵangular_packages_forms_forms_y }\r\n\r\n/**\r\n * @description\r\n * Marks `<option>` as dynamic, so Angular can be notified when options change.\r\n *\r\n * @see `SelectMultipleControlValueAccessor`\r\n *\r\n * @ngModule ReactiveFormsModule\r\n * @ngModule FormsModule\r\n * @publicApi\r\n */\r\ndeclare class ɵNgSelectMultipleOption implements OnDestroy {\r\n    private _element;\r\n    private _renderer;\r\n    private _select;\r\n    id: string;\r\n    constructor(_element: ElementRef, _renderer: Renderer2, _select: SelectMultipleControlValueAccessor);\r\n    /**\r\n     * @description\r\n     * Tracks the value bound to the option element. Unlike the value binding,\r\n     * ngValue supports binding to objects.\r\n     */\r\n    set ngValue(value: any);\r\n    /**\r\n     * @description\r\n     * Tracks simple string values bound to the option element.\r\n     * For objects, use the `ngValue` input binding.\r\n     */\r\n    set value(value: any);\r\n    /**\r\n     * @description\r\n     * Lifecycle method called before the directive's instance is destroyed. For internal use only.\r\n     */\r\n    ngOnDestroy(): void;\r\n}\r\nexport { ɵNgSelectMultipleOption }\r\nexport { ɵNgSelectMultipleOption as ɵangular_packages_forms_forms_x }\r\n\r\nexport { }\r\n"]}
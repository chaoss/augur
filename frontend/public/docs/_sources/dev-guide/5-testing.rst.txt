Testing
====================================

To test augur, set up your environment for testing:

.. code:: bash

    export DB_TEST_URL=mysql+pymysql://<username>:<pass>@<host>:<post>/<database>

After that, run ``make test`` to run the plugin/data source unit tests.

To test the API, run ``make test-routes``.

Writing tests
-------------------------

Endpoints
^^^^^^^^^

As with our unit tests, we write our API tests in Python using the ``pytest`` framework.

API tests for a plugin live in the ``test_<plugin_name>_routes.py`` folder in the ``<plugin_name>/`` directory.
In this file, you'll need the following boilerplate:

.. code:: python

    import os
    import subprocess
    import time
    from subprocess import Popen
    import pytest
    import requests

    @pytest.fixture(scope="module")
    def <plugin_name>_routes():
        process = subprocess.Popen(['make', 'backend-restart'])
        time.sleep(5) #allow some time for the server to start
        return process

This will automatically spin up the web server when running your tests so that you don't have to do it yourself!

For the actual tests, for the most part not much logic is needed. Each endpoint should already have a unit test asserting that the 
metric is being calculate correctly: in most cases the endpoint tests exist primarily to make sure they're reachable and that the routes
we've documented are correct. These unit tests should not be strictly re-implemented, but each test needs to make sure that the output of the
corresponding metric is correct: since most endpoints are nothing more than a wrapper this usually means the test will just mirror the test cases of the corresponding unit test.

In some cases, endpoints will provide additional functionality beyond just the metric they're mapped to
(e.g. aggregation and filtering), and in these scenarios test cases are needed to cover these capabilities.

Let's look at a sample test:

.. code:: python

    def test_api_status(metrics_status):
        response = requests.get('http://localhost:5000/api/unstable').json()
        assert response['status'] == 'OK'
        assert response.status_code == 200


This is just making sure that the API is up and running by parsing the response from the ``/api/unstable``
health check endpoint. In this case simply checking the status code and that the response is not empty/has some data in it
is all that's really needed. If this were a metric endpoint, an appropriate assertion might be something like
``assert response[0]['commits'] = 20``.
